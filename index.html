<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Графічні бібліотеки Python</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }

        header {
            background: #333;
            color: #fff;
            padding: 1rem 0;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            justify-content: center;
        }

        nav ul li {
            margin: 0 15px;
        }

        nav ul li a {
            color: #fff;
            text-decoration: none;
            font-weight: bold;
        }

        nav ul li a:hover {
            color: #f39c12;
        }

        section {
            padding: 2rem;
            margin: 0 auto;
            max-width: 1200px; 
        }

        section h2 {
            text-align: center;
            margin-bottom: 1rem;
            color: #333;
        }

        footer {
            text-align: center;
            padding: 1rem;
            background: #333;
            color: #fff;
        }

        .intro {
            background: #f4f4f4;
        }

        .theory, .examples, .contact {
            background: #eaeaea;
            margin-top: 2rem;
        }
    </style>
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="#intro">Головна</a></li>
                <li><a href="#theory">Теорія</a></li>
                <li><a href="#examples">Приклади</a></li>
                <li><a href="#contact">Контакти</a></li>
            </ul>
        </nav>
        <h3>Графічні бібліотеки Python</h3>
    </header>

    <section id="intro" class="intro">
        <h2>Ласкаво просимо!</h2>
        <p>Цей сайт присвячений графічним бібліотекам мови Python. Тут ви знайдете огляд теорії, приклади реалізації задач та іншу корисну інформацію.</p>
    </section>

    <!-- Теорія -->

    <section id="theory" class="theory">
        <h2>Теорія</h2>
        <p>Python має багато потужних бібліотек для графіки, поділених на кілька категорій:</p>
        <ul>
            <li><strong>2D Графіки:</strong> Matplotlib, Seaborn, Plotly, Bokeh, ggplot, Altair, Chartify, pygal, Pandas Visualization, Holoviews, mplfinance</li>
            <li><strong>3D Візуалізації:</strong> Plotly (3D), Mayavi, VisPy, VTK, matplotlib.pyplot (3D), PyVista</li>
            <li><strong>Інтерактивна графіка та дашборди:</strong> Dash, Panel, Streamlit, Shiny for Python</li>
            <li><strong>Комп'ютерний зір і обробка зображень:</strong> OpenCV, Pillow (PIL), scikit-image, Imageio, PyTorch Vision, TensorFlow Image</li>
            <li><strong>Графічні інтерфейси користувача (GUI):</strong> Tkinter, PyQt / PySide, Kivy, wxPython, PyGTK</li>
            <li><strong>Наукова візуалізація:</strong> Matplotlib, Mayavi, SciPy Visualization, Cartopy</li>
            <li><strong>Графіка для ігор:</strong> Pygame, Pyglet, Arcade, Cocos2d</li>
            <li><strong>Спеціалізовані бібліотеки:</strong> Manim, Basemap, Cartopy, Folium, Blender Python API</li>
            <li><strong>Анімація:</strong> Manim, Matplotlib.animation, Pillow (GIF-анімація), MoviePy</li>
            <li><strong>Інші:</strong> Cairo, Aggdraw, SVGwrite, WeasyPrint</li>
        </ul>

        <h1>2D Графік</h1>
            <div class="tool">
                <h2>Matplotlib</h2>
                <p><strong>Призначення:</strong> Основна бібліотека для створення 2D-графіків у Python.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Гнучкість у створенні лінійних графіків, гістограм, діаграм розсіювання, діаграм з областями тощо.</li>
                    <li>Підтримує налаштування кольорів, шрифтів, маркерів, ліній.</li>
                    <li>Включає підмодуль pyplot, який спрощує синтаксис для створення графіків.</li>
                </ul>
                <p><strong>Переваги:</strong> Підходить для статичних графіків. Велика документація і активна спільнота.</p>
                <p><strong>Недоліки:</strong> Графіки менш інтерактивні, порівняно з іншими бібліотеками.</p>
            </div>
            
            <div class="tool">
                <h2>Seaborn</h2>
                <p><strong>Призначення:</strong> Бібліотека для статистичних графіків на основі Matplotlib.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Просте створення графіків, що показують розподіли даних, взаємозв’язки та категоріальні дані.</li>
                    <li>Інтеграція з pandas для роботи з DataFrame.</li>
                    <li>Додаткові графіки: теплові карти, парні графіки, boxplot тощо.</li>
                </ul>
                <p><strong>Переваги:</strong> Гарна естетика графіків за замовчуванням. Зручність у створенні складних статистичних візуалізацій.</p>
                <p><strong>Недоліки:</strong> Менше можливостей кастомізації порівняно з Matplotlib.</p>
            </div>
            
            <div class="tool">
                <h2>Plotly</h2>
                <p><strong>Призначення:</strong> Інтерактивна візуалізація графіків.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Підтримка 2D та 3D-графіків, діаграм, теплових карт, контурних графіків.</li>
                    <li>Можливість інтеграції у веб-додатки.</li>
                    <li>Інтерактивність: масштабування, наведення, виділення даних.</li>
                </ul>
                <p><strong>Переваги:</strong> Висока інтерактивність. Підходить для дашбордів.</p>
                <p><strong>Недоліки:</strong> Більш складна інтеграція з іншими інструментами.</p>
            </div>

            <div class="tool">
                <h2>Bokeh</h2>
                <p><strong>Призначення:</strong> Створення інтерактивних графіків для веб-додатків.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Генерує інтерактивні HTML-елементи.</li>
                    <li>Підтримує великі набори даних.</li>
                    <li>Графіки: лінії, бари, карти, теплові карти.</li>
                </ul>
                <p><strong>Переваги:</strong></p>
                <ul>
                    <li>Легко інтегрується у Flask або Django.</li>
                    <li>Підходить для роботи з великими наборами даних.</li>
                </ul>
                <p><strong>Недоліки:</strong> Менше готових шаблонів, ніж у Plotly.</p>
            </div>

            <div class="tool">
                <h2>ggplot (для Python)</h2>
                <p><strong>Призначення:</strong> Візуалізація у стилі ggplot2 з R.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Векторна графіка з фокусом на статистичні дані.</li>
                    <li>Простий синтаксис.</li>
                    <li>Підтримка граматики графіків.</li>
                </ul>
                <p><strong>Переваги:</strong> Чіткий синтаксис для створення статистичних графіків.</p>
                <p><strong>Недоліки:</strong> Обмежена функціональність порівняно з ggplot2 в R.</p>
            </div>

            <div class="tool">
                <h2>Altair</h2>
                <p><strong>Призначення:</strong> Декларативна бібліотека для інтерактивних графіків.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Простий синтаксис на основі граматики графіків.</li>
                    <li>Підтримка інтерактивності без складних налаштувань.</li>
                </ul>
                <p><strong>Переваги:</strong> Легке інтегрування з pandas, інтерактивні графіки за замовчуванням.</p>
                <p><strong>Недоліки:</strong> Менше підтримки великих наборів даних.</p>
            </div>

            <div class="tool">
                <h2>Chartify</h2>
                <p><strong>Призначення:</strong> Інструмент для швидкого створення графіків.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Інтуїтивно зрозумілий синтаксис.</li>
                    <li>Адаптований для роботи з pandas.</li>
                    <li>Орієнтований на бізнес-аналітиків.</li>
                </ul>
                <p><strong>Переваги:</strong> Легкість використання.</p>
                <p><strong>Недоліки:</strong> Менше можливостей кастомізації.</p>
            </div>

            <div class="tool">
                <h2>pygal</h2>
                <p><strong>Призначення:</strong> Генерація інтерактивної SVG-графіки.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Підтримка SVG для веб-додатків.</li>
                    <li>Вбудована інтерактивність.</li>
                </ul>
                <p><strong>Переваги:</strong> Легка інтеграція у веб, графіки масштабуються без втрати якості.</p>
                <p><strong>Недоліки:</strong> Не підтримує великі набори даних.</p>
            </div>

            <div class="tool">
                <h2>Pandas Visualization</h2>
                <p><strong>Призначення:</strong> Просте створення графіків з DataFrame.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Вбудовані функції для лінійних графіків, гістограм, розподілів.</li>
                    <li>Інтеграція з Matplotlib.</li>
                </ul>
                <p><strong>Переваги:</strong> Зручно використовувати з DataFrame, мінімальний код для базових графіків.</p>
                <p><strong>Недоліки:</strong> Не підтримує складні графіки.</p>
            </div>

            <div class="tool">
                <h2>Holoviews</h2>
                <p><strong>Призначення:</strong> Спрощення візуалізації великих наборів даних.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Підтримка інтерактивності.</li>
                    <li>Інтеграція з Matplotlib, Bokeh та Plotly.</li>
                </ul>
                <p><strong>Переваги:</strong> Простота інтеграції з різними бібліотеками.</p>
                <p><strong>Недоліки:</strong> Відносно нова бібліотека з меншою документацією.</p>
            </div>

            <div class="tool">
                <h2>mplfinance</h2>
                <p><strong>Призначення:</strong> Візуалізація фінансових даних.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Графіки японських свічок, лінійні графіки, обсяги торгів.</li>
                    <li>Пряме використання з pandas DataFrame.</li>
                </ul>
                <p><strong>Переваги:</strong> Спеціалізована для фінансових графіків.</p>
                <p><strong>Недоліки:</strong> Обмежена функціональність поза фінансовою сферою.</p>
            </div>

        <h1>3D Візуалізації</h1>
    
    <div class="tool">
        <h2>Plotly (3D)</h2>
        <p><strong>Призначення:</strong> Інтерактивна 3D-візуалізація даних.</p>
        <p><strong>Особливості:</strong></p>
        <ul>
            <li>Підтримка графіків поверхонь, об’ємів, діаграм розсіювання, сіток та ізоліній.</li>
            <li>Візуалізація у веб-браузері з інтерактивними функціями (масштабування, обертання, зміна перспективи).</li>
            <li>Інтеграція з Jupyter Notebook.</li>
        </ul>
        <p><strong>Переваги:</strong> Легко створювати інтерактивні 3D-графіки. Можливість експорту у HTML.</p>
        <p><strong>Недоліки:</strong> Менш придатний для великих даних у реальному часі. Залежність від веб-браузера для перегляду графіків.</p>
    </div>

    <div class="tool">
        <h2>Mayavi</h2>
        <p><strong>Призначення:</strong> Візуалізація наукових та інженерних даних у 3D.</p>
        <p><strong>Особливості:</strong></p>
        <ul>
            <li>Підтримка великих наборів даних і складних геометричних структур.</li>
            <li>Створення інтерактивних об’єктів, таких як ізолінії, сітки, поверхні та об'єми.</li>
            <li>Інтеграція з науковими бібліотеками Python (NumPy, SciPy).</li>
        </ul>
        <p><strong>Переваги:</strong> Потужний інструмент для наукової 3D-візуалізації. Графічний інтерфейс для редагування графіків.</p>
        <p><strong>Недоліки:</strong> Складний для початківців через багатий функціонал.</p>
    </div>

    <div class="tool">
        <h2>VisPy</h2>
        <p><strong>Призначення:</strong> Швидка візуалізація великих наборів даних з використанням OpenGL.</p>
        <p><strong>Особливості:</strong></p>
        <ul>
            <li>Ефективний рендеринг завдяки GPU-акселерації.</li>
            <li>Підтримка складних 3D-об'єктів, таких як поверхні, вектори, ізолінії.</li>
            <li>Сумісність із інтерактивними середовищами, такими як Jupyter Notebook.</li>
        </ul>
        <p><strong>Переваги:</strong> Підходить для реального часу та великих даних. Підтримка інтерактивності.</p>
        <p><strong>Недоліки:</strong> Відносно низький рівень абстракції, що ускладнює використання для новачків.</p>
    </div>

    <div class="tool">
        <h2>VTK (Visualization Toolkit)</h2>
        <p><strong>Призначення:</strong> Візуалізація наукових, медичних та інженерних даних.</p>
        <p><strong>Особливості:</strong></p>
        <ul>
            <li>Робота з великою кількістю форматів даних (об'єми, вектори, 3D-сітки).</li>
            <li>Підтримка як 3D-візуалізації, так і анімації.</li>
            <li>Інтеграція з іншими мовами програмування, такими як C++ та Java.</li>
        </ul>
        <p><strong>Переваги:</strong> Надійний інструмент для професійної 3D-візуалізації. Потужна підтримка користувацьких модифікацій.</p>
        <p><strong>Недоліки:</strong> Високий поріг входу через складність API. Вимагає більше часу для налаштування та вивчення.</p>
    </div>

    <div class="tool">
        <h2>matplotlib.pyplot (3D)</h2>
        <p><strong>Призначення:</strong> Створення базових 3D-графіків.</p>
        <p><strong>Особливості:</strong></p>
        <ul>
            <li>Додатковий модуль mpl_toolkits.mplot3d для 3D-візуалізації.</li>
            <li>Підтримка 3D-графіків: поверхонь, ліній, розсіювання.</li>
            <li>Гнучке налаштування кольорів, осей, видів тощо.</li>
        </ul>
        <p><strong>Переваги:</strong> Простий у використанні для базової 3D-візуалізації. Інтеграція з 2D-графіками у Matplotlib.</p>
        <p><strong>Недоліки:</strong> Обмежена інтерактивність. Не підходить для складних або великих даних.</p>
    </div>

    <div class="tool">
        <h2>PyVista</h2>
        <p><strong>Призначення:</strong> Інструмент для створення інтерактивної 3D-візуалізації.</p>
        <p><strong>Особливості:</strong></p>
        <ul>
            <li>Працює поверх VTK, спрощуючи синтаксис.</li>
            <li>Підтримка інтерактивної роботи з 3D-об’єктами.</li>
            <li>Інструменти для створення сіток, ізоліній, поверхонь, об’єму.</li>
        </ul>
        <p><strong>Переваги:</strong> Простий синтаксис порівняно з VTK. Інтерактивність у реальному часі.</p>
        <p><strong>Недоліки:</strong> Залежність від VTK для основних функцій.</p>

        <h1>Інтерактивна графіка та дашборди</h1>

        <div class="tool">
            <h2>Dash</h2>
            <p><strong>Призначення:</strong> Dash є фреймворком для створення інтерактивних веб-додатків для аналізу даних і візуалізації.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Побудований на основі Flask, Plotly та React.</li>
                <li>Підтримка інтерактивної 2D та 3D графіки, створеної за допомогою бібліотеки Plotly.</li>
                <li>Розширена можливість інтерактивності через використання колбеків (callbacks).</li>
                <li>Створення повноцінних веб-додатків без необхідності використовувати JavaScript.</li>
            </ul>
            <p><strong>Переваги:</strong> Потужний інструмент для створення аналітичних панелей. Добре інтегрується з іншими бібліотеками Python. Можливість хостингу на різних платформах (локально або в хмарі).</p>
            <p><strong>Недоліки:</strong> Відносно низька продуктивність при роботі з великими наборами даних. Потребує базових знань про Flask та HTML.</p>
        </div>
    
        <div class="tool">
            <h2>Panel</h2>
            <p><strong>Призначення:</strong> Інструмент для створення панелей візуалізації та аналітики, зосереджений на наукових і бізнесових задачах.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримує кілька бібліотек візуалізації, включаючи Bokeh, Matplotlib, Plotly, і Holoviews.</li>
                <li>Можливість додавати інтерактивні елементи: слайдери, випадаючі меню, кнопки тощо.</li>
                <li>Інтеграція з Jupyter Notebook і можливість розгортання як автономного веб-додатка.</li>
            </ul>
            <p><strong>Переваги:</strong> Гнучкий інструмент із багатою інтеграцією бібліотек. Проста розробка дашбордів із мінімальним кодом. Легка інтеграція з Python-середовищем для аналізу даних.</p>
            <p><strong>Недоліки:</strong> Менш популярний, ніж Dash, тому менше документації та прикладів.</p>
        </div>
    
        <div class="tool">
            <h2>Streamlit</h2>
            <p><strong>Призначення:</strong> Простий фреймворк для створення веб-додатків для аналізу даних.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Не потребує глибоких знань веб-розробки.</li>
                <li>Функції дозволяють створювати інтерактивні елементи, такі як графіки, таблиці, форми, слайдери, з декількома рядками коду.</li>
                <li>Автоматичне перезавантаження додатка при зміні коду.</li>
            </ul>
            <p><strong>Переваги:</strong> Дуже простий у використанні, підходить для швидкого створення прототипів. Можливість легко додавати інтерактивні елементи. Чудово підходить для Data Science-проєктів.</p>
            <p><strong>Недоліки:</strong> Обмежена інтерактивність у порівнянні з Dash. Підходить більше для швидкого створення прототипів, ніж для великих комерційних додатків.</p>
        </div>
    
        <div class="tool">
            <h2>Shiny for Python</h2>
            <p><strong>Призначення:</strong> Нещодавно перенесений з R, Shiny дозволяє створювати інтерактивні веб-додатки для Python.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Фреймворк спочатку популярний у спільноті R, але тепер доступний і для Python.</li>
                <li>Простий спосіб створення веб-додатків за допомогою Python-коду.</li>
                <li>Підтримка інтерактивних компонентів, таких як графіки, таблиці та текстові віджети.</li>
                <li>Використовує HTTP-протокол для інтерактивності в реальному часі.</li>
            </ul>
            <p><strong>Переваги:</strong> Чудово підходить для інтерактивної візуалізації та демонстрації даних. Висока гнучкість у налаштуванні.</p>
            <p><strong>Недоліки:</strong> Менш розвинута екосистема для Python у порівнянні з Dash або Streamlit. Більша складність для початківців, особливо тих, хто не знайомий із Shiny у R.</p>
        </div>
    
        <h1>Комп'ютерний зір і обробка зображень</h1>

        <div class="tool">
            <h2>OpenCV (Open Source Computer Vision Library)</h2>
            <p><strong>Призначення:</strong> Бібліотека для комп’ютерного зору, обробки зображень і відео.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримує широкий спектр функцій: обробка зображень, виявлення об’єктів, розпізнавання облич, аналіз руху, 3D-реконструкція.</li>
                <li>Працює з різними форматами зображень (JPEG, PNG, BMP тощо).</li>
                <li>Містить модулі для роботи з відео (наприклад, аналіз відеопотоку).</li>
                <li>Підтримує інтеграцію з Python, C++ та іншими мовами.</li>
            </ul>
            <p><strong>Переваги:</strong> Висока продуктивність завдяки використанню C++ ядра. Розширена документація та велика спільнота користувачів. Підтримка обчислень на GPU через CUDA.</p>
            <p><strong>Недоліки:</strong> Може бути складною для початківців. Обмежена підтримка сучасних моделей машинного навчання.</p>
        </div>
        
        <div class="tool">
            <h2>Pillow (PIL – Python Imaging Library)</h2>
            <p><strong>Призначення:</strong> Легка у використанні бібліотека для роботи із зображеннями.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримка різноманітних форматів зображень, таких як JPEG, PNG, GIF, TIFF.</li>
                <li>Функції для редагування зображень: зміна розміру, поворот, обрізання, накладення тексту.</li>
                <li>Легко інтегрується з іншими Python-бібліотеками.</li>
            </ul>
            <p><strong>Переваги:</strong> Простий синтаксис, ідеально підходить для базових операцій. Легка вага та швидка обробка невеликих зображень.</p>
            <p><strong>Недоліки:</strong> Обмежені можливості в порівнянні з OpenCV. Відсутність функцій комп’ютерного зору.</p>
        </div>
        
        <div class="tool">
            <h2>scikit-image</h2>
            <p><strong>Призначення:</strong> Бібліотека для обробки зображень, створена як доповнення до екосистеми SciPy.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримка різноманітних алгоритмів: сегментація, фільтрація, морфологічні операції, вимірювання властивостей об’єктів.</li>
                <li>Легко інтегрується з NumPy для роботи з масивами.</li>
                <li>Містить інструменти для обробки багатовимірних зображень.</li>
            </ul>
            <p><strong>Переваги:</strong> Відмінно підходить для наукових обчислень. Добра документація для академічних задач.</p>
            <p><strong>Недоліки:</strong> Менш продуктивна для реального часу в порівнянні з OpenCV.</p>
        </div>
        
        <div class="tool">
            <h2>Imageio</h2>
            <p><strong>Призначення:</strong> Інструмент для читання та запису зображень і відео.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримка безлічі форматів: JPEG, PNG, GIF, MP4.</li>
                <li>Простота використання для обробки файлів зображень і відео.</li>
                <li>Використовується для анімацій або роботи з відеопотоками.</li>
            </ul>
            <p><strong>Переваги:</strong> Мінімалістичний інтерфейс для роботи з файлами. Легко інтегрується з іншими бібліотеками.</p>
            <p><strong>Недоліки:</strong> Основний акцент на файлових операціях, обмежена обробка зображень.</p>
        </div>
        
        <div class="tool">
            <h2>PyTorch Vision</h2>
            <p><strong>Призначення:</strong> Модуль для обробки зображень і комп’ютерного зору, інтегрований у PyTorch.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Містить готові нейронні мережі для задач розпізнавання, сегментації тощо.</li>
                <li>Набори даних для навчання моделей (ImageNet, COCO, CIFAR).</li>
                <li>Легке перетворення та аугментація даних через torchvision.transforms.</li>
            </ul>
            <p><strong>Переваги:</strong> Глибока інтеграція з PyTorch для навчання моделей. Підтримка GPU для обчислень.</p>
            <p><strong>Недоліки:</strong> Фокус на машинному навчанні, менш зручний для базової обробки зображень.</p>
        </div>
        
        <div class="tool">
            <h2>TensorFlow Image (tf.image)</h2>
            <p><strong>Призначення:</strong> Модуль TensorFlow для обробки зображень і підготовки їх до навчання моделей.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Набір інструментів для аугментації даних, масштабування, обрізки та нормалізації.</li>
                <li>Інтеграція з TensorFlow для створення нейронних мереж.</li>
                <li>Підтримка обчислень на GPU та TPU.</li>
            </ul>
            <p><strong>Переваги:</strong> Оптимізований для великих обчислень. Сумісність із TensorFlow Extended (TFX) для розгортання моделей.</p>
            <p><strong>Недоліки:</strong> Високий вхідний поріг для новачків. Складність у реалізації базових операцій без глибокого знання TensorFlow.</p>
        </div>

        <h1>Графічні інтерфейси користувача (GUI)</h1>

        <div class="tool">
            <h2>Tkinter</h2>
            <p><strong>Призначення:</strong> Стандартна бібліотека для створення GUI в Python, заснована на інструментарії Tcl/Tk.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Вбудована в Python, не потребує додаткової установки.</li>
                <li>Підтримує основні компоненти GUI: кнопки, текстові поля, меню, слайдери.</li>
                <li>Інструменти для налаштування геометрії вікон (наприклад, pack, grid, place).</li>
            </ul>
            <p><strong>Переваги:</strong> Простота використання, підходить для початківців. Легка інтеграція з Python-кодом. Добра документація і багато прикладів.</p>
            <p><strong>Недоліки:</strong> Обмежені можливості дизайну. Базовий вигляд інтерфейсу, який може виглядати застарілим.</p>
        </div>
        
        <div class="tool">
            <h2>PyQt / PySide</h2>
            <p><strong>Призначення:</strong> Потужні інструментарії для створення сучасних, кросплатформених GUI на основі Qt Framework.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримує створення складних додатків з використанням сучасного дизайну.</li>
                <li>Містить готові віджети для роботи з таблицями, графіками, мультимедіа.</li>
                <li>Підтримка інтеграції з OpenGL для графічного рендерингу.</li>
                <li>PyQt має комерційну ліцензію, тоді як PySide є офіційним відкритим інтерфейсом Qt.</li>
            </ul>
            <p><strong>Переваги:</strong> Висока гнучкість і продуктивність. Широкі можливості кастомізації GUI. Підтримка кросплатформеності (Windows, macOS, Linux).</p>
            <p><strong>Недоліки:</strong> Вищий поріг входу для новачків. PyQt може вимагати придбання ліцензії для комерційного використання.</p>
        </div>
        
        <div class="tool">
            <h2>Kivy</h2>
            <p><strong>Призначення:</strong> Фреймворк для створення сучасних, кросплатформених і сенсорних GUI-додатків, зокрема для мобільних платформ.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримує розробку на Android, iOS, Windows, macOS і Linux.</li>
                <li>Зосереджений на сенсорних інтерфейсах, жестах і анімаціях.</li>
                <li>Використовує власний мову розмітки (Kv Language) для налаштування інтерфейсу.</li>
            </ul>
            <p><strong>Переваги:</strong> Кросплатформеність (особливо для мобільних додатків). Легке створення інтерактивних елементів. Адаптованість до сенсорних екранів.</p>
            <p><strong>Недоліки:</strong> Потребує вивчення додаткового синтаксису (Kv Language). Продуктивність може бути нижчою для складних додатків.</p>
        </div>
        
        <div class="tool">
            <h2>wxPython</h2>
            <p><strong>Призначення:</strong> Python-обгортка для інструментарію wxWidgets, орієнтованого на створення кросплатформених GUI.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримує широкий спектр віджетів і компонентів.</li>
                <li>Надає можливості для створення додатків, що виглядають нативно для різних ОС.</li>
                <li>Має вбудовані інструменти для роботи з мультимедіа, друком, графікою.</li>
            </ul>
            <p><strong>Переваги:</strong> Нативний вигляд інтерфейсу для кожної платформи. Велика кількість готових компонентів.</p>
            <p><strong>Недоліки:</strong> Потребує більше коду для створення базових інтерфейсів. Менш популярний у порівнянні з PyQt або Tkinter, через що є менше ресурсів для навчання.</p>
        </div>
        
        <div class="tool">
            <h2>PyGTK (GObject Introspection)</h2>
            <p><strong>Призначення:</strong> Бібліотека для створення GUI на основі GTK+, широко використовується в середовищі GNOME.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Розробка сучасних графічних додатків для Linux (хоча також підтримує Windows і macOS).</li>
                <li>Інтеграція з GObject Introspection для роботи з іншими бібліотеками.</li>
                <li>Підтримка сучасних технологій, таких як Wayland.</li>
            </ul>
            <p><strong>Переваги:</strong> Добре підходить для Linux-додатків. Сучасний вигляд інтерфейсів.</p>
            <p><strong>Недоліки:</strong> Підходить більше для Linux, ніж для Windows чи macOS. Обмежена документація для Python у порівнянні з іншими бібліотеками.</p>
        </div>

        <h1>Наукова візуалізація</h1>

        <div class="tool">
            <h2>Matplotlib</h2>
            <p><strong>Призначення:</strong> Базова бібліотека для 2D і частково 3D візуалізації в Python, широко використовується в наукових і технічних дослідженнях.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримує створення різноманітних графіків: лінійних, гістограм, розсіяння, спектральних, 3D.</li>
                <li>Велика кількість параметрів для кастомізації (колір, шрифти, осі, мітки).</li>
                <li>Інтеграція з іншими бібліотеками, такими як NumPy, Pandas і SciPy.</li>
            </ul>
            <p><strong>Переваги:</strong> Гнучкість у налаштуваннях. Велика кількість прикладів і документації. Можливість збереження графіків у різних форматах (PNG, PDF, SVG).</p>
            <p><strong>Недоліки:</strong> Висока складність для початківців. Для інтерактивної графіки потрібні додаткові бібліотеки (наприклад, Plotly).</p>
        </div>
        
        <div class="tool">
            <h2>Mayavi</h2>
            <p><strong>Призначення:</strong> Бібліотека для візуалізації 3D-даних і об’єктів у наукових дослідженнях.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримка створення складних 3D-візуалізацій, таких як поверхні, ізолінії, векторні поля.</li>
                <li>Інтеграція з NumPy для обробки даних.</li>
                <li>Використовує движок VTK (Visualization Toolkit) для рендерингу графіки.</li>
            </ul>
            <p><strong>Переваги:</strong> Потужна візуалізація складних тривимірних структур. Можливість створення інтерактивних вікон. Підходить для наукових симуляцій і великих обсягів даних.</p>
            <p><strong>Недоліки:</strong> Висока складність для освоєння. Не завжди підходить для інтерактивного графічного інтерфейсу.</p>
        </div>
        
        <div class="tool">
            <h2>SciPy Visualization</h2>
            <p><strong>Призначення:</strong> Модулі для базової візуалізації, що входять до складу SciPy, орієнтовані на наукові розрахунки та побудову графіків.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Інтеграція з Matplotlib для візуалізації результатів чисельних методів.</li>
                <li>Базова підтримка 2D-графіків і спеціалізованих діаграм.</li>
                <li>Підтримує побудову функцій, графіків оптимізації та інтеграції.</li>
            </ul>
            <p><strong>Переваги:</strong> Простота інтеграції з науковими обчисленнями. Сумісність із іншими модулями SciPy.</p>
            <p><strong>Недоліки:</strong> Обмежена функціональність для складних графіків. Для 3D-візуалізації потрібні додаткові бібліотеки.</p>
        </div>
        
        <div class="tool">
            <h2>Cartopy</h2>
            <p><strong>Призначення:</strong> Бібліотека для геопросторової візуалізації даних.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Створення географічних карт із нанесенням даних.</li>
                <li>Інтеграція з іншими бібліотеками, такими як Matplotlib.</li>
                <li>Підтримка різних картографічних проєкцій (наприклад, азимутальна, меркаторська).</li>
            </ul>
            <p><strong>Переваги:</strong> Висока якість географічних візуалізацій. Можливість використання супутникових даних та API для геокодування.</p>
            <p><strong>Недоліки:</strong> Вимагає значних обчислювальних ресурсів. Вузька спеціалізація, не підходить для загальної наукової візуалізації.</p>
        </div>

        <h1>Графіка для ігор</h1>

        <div class="tool">
            <h2>Pygame</h2>
            <p><strong>Призначення:</strong> Бібліотека для створення 2D-ігор і простих мультимедіа-додатків.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Побудована на основі SDL (Simple DirectMedia Layer), забезпечує підтримку графіки, звуку та введення.</li>
                <li>Проста для вивчення, підходить новачкам у розробці ігор.</li>
                <li>Підтримує анімацію спрайтів, обробку подій, музичні ефекти та об’єкти.</li>
                <li>Може працювати на різних платформах (Windows, macOS, Linux).</li>
            </ul>
            <p><strong>Переваги:</strong> Легка інтеграція із зовнішніми файлами (зображення, звуки, шрифти). Велика спільнота користувачів і багато навчальних матеріалів. Ідеально підходить для навчальних проєктів та прототипування.</p>
            <p><strong>Недоліки:</strong> Обмежена підтримка 3D-графіки. Не оптимізована для великих ігрових проєктів.</p>
        </div>
        
        <div class="tool">
            <h2>Pyglet</h2>
            <p><strong>Призначення:</strong> Бібліотека для розробки 2D- і 3D-ігор із глибоким контролем графічного рендерингу.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримка OpenGL для високоякісної графіки.</li>
                <li>Легка обробка мультимедіа (звуки, відео, текстури).</li>
                <li>Можливість створення повноекранних додатків і віконних програм.</li>
                <li>Інтеграція з 3D-графікою без додаткових бібліотек.</li>
            </ul>
            <p><strong>Переваги:</strong> Легка у використанні для проєктів середньої складності. Широкі можливості для роботи з графікою через OpenGL. Підходить для створення інтерактивних програм, не лише ігор.</p>
            <p><strong>Недоліки:</strong> Потребує базового розуміння OpenGL для складних ефектів. Менша популярність, ніж у Pygame, тому обмежена кількість прикладів.</p>
        </div>
        
        <div class="tool">
            <h2>Arcade</h2>
            <p><strong>Призначення:</strong> Сучасна бібліотека для створення 2D-ігор із простим інтерфейсом і високою продуктивністю.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Побудована на основі OpenGL 3.3, забезпечує швидку рендеринг-графіку.</li>
                <li>Простий у використанні API для роботи зі спрайтами, фізикою та текстурами.</li>
                <li>Підтримує системи зіткнень, інтеграцію з текстом, анімацією та аудіо.</li>
                <li>Орієнтована на простоту використання, особливо для початківців.</li>
            </ul>
            <p><strong>Переваги:</strong> Дуже легкий у вивченні, підходить для розробників-початківців. Висока продуктивність завдяки OpenGL. Чітка структура коду для великих ігрових проєктів.</p>
            <p><strong>Недоліки:</strong> Фокус лише на 2D-графіці. Порівняно нова бібліотека, менша спільнота користувачів.</p>
        </div>
        
        <div class="tool">
            <h2>Cocos2d</h2>
            <p><strong>Призначення:</strong> Рамковий інструмент для створення 2D-ігор з великою кількістю функцій і підтримкою анімації.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримка спрайтів, сцен, шарів, анімацій і системи зіткнень.</li>
                <li>Модульна архітектура, яка дозволяє легко розширювати функціонал.</li>
                <li>Включає інструменти для роботи зі звуком, фізикою та текстом.</li>
                <li>Підтримує кросплатформний розвиток (Windows, macOS, iOS, Android).</li>
            </ul>
            <p><strong>Переваги:</strong> Можливість створення складних ігор із багатим функціоналом. Хороша інтеграція з іншими бібліотеками Python. Велика кількість готових модулів для фізики та анімації.</p>
            <p><strong>Недоліки:</strong> Потребує більше часу для вивчення через велику кількість функцій. Може бути надмірним для простих ігор.</p>
        </div>

        <h1>Спеціалізовані бібліотеки</h1>

        <div class="tool">
            <h2>Manim</h2>
            <p><strong>Призначення:</strong> Потужна бібліотека для створення математичних анімацій і наукових презентацій.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Створення анімованих пояснень математичних понять, геометрії та графіків.</li>
                <li>Підтримка Latex для форматування математичних рівнянь.</li>
                <li>Використання сцени, об'єктів, ефектів і анімацій для побудови відео.</li>
                <li>Можливість роботи з геометричними формами, векторними графіками та 3D-об’єктами.</li>
            </ul>
            <p><strong>Переваги:</strong> Ідеально підходить для створення освітнього контенту. Висока якість графіки та відео. Велика спільнота та багато готових шаблонів.</p>
            <p><strong>Недоліки:</strong> Потребує розуміння концепцій програмування. Вимагає час на освоєння для складних проєктів.</p>
        </div>
        
        <div class="tool">
            <h2>Basemap</h2>
            <p><strong>Призначення:</strong> Спеціалізована бібліотека для створення картографічних візуалізацій.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Інтеграція з Matplotlib для нанесення карт на графіки.</li>
                <li>Підтримка різних картографічних проєкцій (наприклад, Mercator, Lambert).</li>
                <li>Можливість додавання об’єктів на карту, таких як річки, дороги, міста.</li>
                <li>Робота з географічними даними (широта, довгота).</li>
            </ul>
            <p><strong>Переваги:</strong> Легка у використанні для створення базових карт. Інтегрується з існуючими екосистемами Python.</p>
            <p><strong>Недоліки:</strong> Обмежений функціонал у порівнянні з сучаснішими бібліотеками. Припинено підтримку; рекомендовано використовувати Cartopy.</p>
        </div>
        
        <div class="tool">
            <h2>Cartopy</h2>
            <p><strong>Призначення:</strong> Сучасна бібліотека для створення картографічних візуалізацій із підтримкою наукових даних.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Розширена підтримка картографічних проєкцій і геопросторових даних.</li>
                <li>Підтримка роботи з супутниковими зображеннями та географічними даними.</li>
                <li>Можливість створення спеціалізованих карт, таких як кліматичні, океанографічні та екологічні.</li>
            </ul>
            <p><strong>Переваги:</strong> Сучасна та активно підтримується. Інтеграція з Matplotlib для побудови складних графіків. Підтримка інтерактивності та великих наборів даних.</p>
            <p><strong>Недоліки:</strong> Відносно складна для освоєння. Вимагає установки додаткових залежностей.</p>
        </div>
        
        <div class="tool">
            <h2>Folium</h2>
            <p><strong>Призначення:</strong> Бібліотека для створення інтерактивних карт на основі Leaflet.js.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Інтеграція з Jupyter Notebook для візуалізації карт у браузері.</li>
                <li>Підтримка інтерактивних функцій: додавання маркерів, спливаючих вікон, шарів.</li>
                <li>Робота з геопросторовими файлами (GeoJSON, Shapefiles).</li>
                <li>Можливість накладення теплових карт і хлороплетних карт.</li>
            </ul>
            <p><strong>Переваги:</strong> Простий API для створення інтерактивних карт. Легка інтеграція з pandas для роботи з геоданими. Висока продуктивність навіть на великих картах.</p>
            <p><strong>Недоліки:</strong> Обмежена у функціоналі 3D-візуалізації. Потребує вебінтерфейсу для перегляду карт.</p>
        </div>
        
        <div class="tool">
            <h2>Blender Python API</h2>
            <p><strong>Призначення:</strong> Програмний інтерфейс для автоматизації та налаштування функцій у Blender — професійному інструменті для 3D-моделювання.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Дозволяє створювати, редагувати та анімувати 3D-об’єкти через Python-скрипти.</li>
                <li>Доступ до всіх функцій Blender, включаючи текстурування, рендеринг і симуляції.</li>
                <li>Можливість автоматизації рутинних завдань у 3D-дизайні.</li>
                <li>Підтримка імпорту/експорту у різні формати файлів (OBJ, FBX, STL).</li>
            </ul>
            <p><strong>Переваги:</strong> Потужний інструмент для роботи з 3D-графікою. Підтримка створення високоякісних моделей та анімацій. Велика спільнота користувачів і документація.</p>
            <p><strong>Недоліки:</strong> Потребує знань як Python, так і основ роботи в Blender. Високий поріг входу для складних сценаріїв.</p>
        </div>

        <h1>Анімація</h1>

        <div class="tool">
            <h2>Manim</h2>
            <p><strong>Призначення:</strong> Manim — це спеціалізована бібліотека для створення математичних анімацій та освітніх відео.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримка анімації геометричних фігур, функцій і графіків.</li>
                <li>Інтеграція з Latex для відображення математичних формул у відео.</li>
                <li>Побудова складних сцен із багатьма ефектами: обертання, масштабування, поступове з'явлення елементів.</li>
                <li>Можливість роботи з 3D-об'єктами та камерними рухами.</li>
            </ul>
            <p><strong>Переваги:</strong> Підходить для створення освітніх відео високої якості. Велика кількість готових прикладів і шаблонів. Можливість створення кастомних анімацій з точним контролем.</p>
            <p><strong>Недоліки:</strong> Високий поріг входу для новачків. Для рендерингу потрібні потужні ресурси.</p>
        </div>
        
        <div class="tool">
            <h2>Matplotlib.animation</h2>
            <p><strong>Призначення:</strong> Модуль для створення простих анімацій на основі графіків.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Створення 2D-анімацій шляхом поступового оновлення графіка.</li>
                <li>Підтримка збереження анімацій у форматах GIF або відео (MP4).</li>
                <li>Просте управління кадрами через функцію оновлення.</li>
                <li>Сумісність з іншими інструментами Matplotlib.</li>
            </ul>
            <p><strong>Переваги:</strong> Легка інтеграція в наукові звіти. Простий API для створення анімацій із графіками.</p>
            <p><strong>Недоліки:</strong> Обмежений функціонал для складних анімацій. Придатний лише для графічних представлень.</p>
        </div>
        
        <div class="tool">
            <h2>Pillow (GIF-анімація)</h2>
            <p><strong>Призначення:</strong> Бібліотека для роботи із зображеннями, включаючи створення та редагування GIF-анімацій.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Злиття серії зображень у GIF із можливістю налаштування затримки між кадрами.</li>
                <li>Підтримка створення простих анімацій з нерухомими об'єктами.</li>
                <li>Інтеграція з іншими бібліотеками для підготовки зображень.</li>
            </ul>
            <p><strong>Переваги:</strong> Легка у використанні. Можливість роботи з різними форматами зображень.</p>
            <p><strong>Недоліки:</strong> Обмежені можливості для складних анімацій.</p>
        </div>
        
        <div class="tool">
            <h2>MoviePy</h2>
            <p><strong>Призначення:</strong> Потужна бібліотека для редагування відео та створення анімацій.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Створення анімацій із фреймів або зображень.</li>
                <li>Підтримка додавання тексту, звуку, ефектів переходу.</li>
                <li>Редагування та об’єднання відеофайлів.</li>
                <li>Можливість створення складних відеоефектів.</li>
            </ul>
            <p><strong>Переваги:</strong> Гнучкий інструмент для створення кастомних відео. Сумісність із багатьма форматами файлів. Інтеграція з іншими бібліотеками Python.</p>
            <p><strong>Недоліки:</strong> Повільна обробка великих відеофайлів. Не підходить для реального часу.</p>
        </div>

        <h1>Інші</h1>

        <div class="tool">
            <h2>Cairo</h2>
            <p><strong>Призначення:</strong> 2D-графічна бібліотека для створення високоякісної векторної графіки.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримка векторної графіки та високоякісного рендерингу.</li>
                <li>Інтеграція з різними мовами програмування, включаючи Python (через бібліотеку Pycairo).</li>
                <li>Підтримка створення кривих Безьє, тексту, градієнтів та інших графічних елементів.</li>
            </ul>
            <p><strong>Переваги:</strong> Надзвичайно точне відображення векторних зображень. Можливість створення файлів для друку (PDF, PS). Широкі можливості роботи з шрифтами.</p>
            <p><strong>Недоліки:</strong> Високий поріг входу для новачків. Не інтерактивна (статична графіка).</p>
        </div>
        
        <div class="tool">
            <h2>Aggdraw</h2>
            <p><strong>Призначення:</strong> Розширення для бібліотеки Pillow, що дозволяє створювати складну графіку.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Розширені можливості для малювання, включаючи криві, контури, заповнення та текст.</li>
                <li>Використання антиаліасингу для згладжених зображень.</li>
                <li>Призначений для роботи з растровою графікою.</li>
            </ul>
            <p><strong>Переваги:</strong> Висока продуктивність завдяки AGG. Простий у використанні для роботи з Pillow.</p>
            <p><strong>Недоліки:</strong> Обмежена документація. Застаріла підтримка у порівнянні з сучасними бібліотеками.</p>
        </div>
        
        <div class="tool">
            <h2>SVGwrite</h2>
            <p><strong>Призначення:</strong> Бібліотека для створення SVG-файлів (Scalable Vector Graphics).</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Генерація SVG-документів у форматі XML.</li>
                <li>Створення геометричних фігур, тексту, градієнтів та інших елементів.</li>
                <li>Підтримка стилів CSS.</li>
            </ul>
            <p><strong>Переваги:</strong> Простий API для створення SVG-файлів. Сумісність із веб-технологіями. Можливість створення адаптивної графіки.</p>
            <p><strong>Недоліки:</strong> Підходить лише для роботи з векторними зображеннями.</p>
        </div>
        
        <div class="tool">
            <h2>WeasyPrint</h2>
            <p><strong>Призначення:</strong> Бібліотека для створення PDF-документів і векторної графіки на основі HTML та CSS.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Перетворення HTML-документів у PDF або PNG із використанням CSS для стилізації.</li>
                <li>Підтримка багатосторінкових документів із таблицями, графіками та текстом.</li>
                <li>Використання стандартів веб-технологій для створення документів.</li>
            </ul>
            <p><strong>Переваги:</strong> Інтуїтивно зрозумілий спосіб створення PDF через HTML. Висока якість вихідних файлів. Підтримка адаптивної верстки.</p>
            <p><strong>Недоліки:</strong> Потрібно знати HTML і CSS. Не підтримує складну інтерактивну графіку.</p>
        </div>
    </section>


<!-- Приклад -->

<section id="examples" class="examples">
    <h2>Приклади задач</h2>
    <article>
        <h2>Приклади 2D Графіки: Matplotlib</h2>
        <h3>1. Побудова лінійного графіка</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(-10, 10, 100)
y = 2 * x + 3

plt.plot(x, y, label="y = 2x + 3", color="blue", linestyle="--")

plt.title("Лінійний графік")
plt.xlabel("x")
plt.ylabel("y")
plt.axhline(0, color="black", linewidth=0.5)  # Лінія осі x
plt.axvline(0, color="black", linewidth=0.5)  # Лінія осі y
plt.grid(True)
plt.legend()

plt.show()
        </code></pre>
        <h3>2. Побудова гістограми</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

data = np.random.normal(0, 1, 1000)  # Нормальний розподіл

plt.hist(data, bins=30, color="purple", edgecolor="black", alpha=0.7)

plt.title("Гістограма розподілу")
plt.xlabel("Значення")
plt.ylabel("Частота")
plt.grid(True)

plt.show()
        </code></pre>
        <h3>3. Кругова діаграма</h3>
        <pre><code>
import matplotlib.pyplot as plt

labels = ["Company A", "Company B", "Company C", "Company D"]
sizes = [30, 45, 15, 10]  # Відсотки ринку
colors = ["gold", "lightblue", "lightgreen", "pink"]

plt.pie(sizes, labels=labels, colors=colors, autopct="%1.1f%%", startangle=90)
plt.title("Поділ ринку між компаніями")

plt.show()
        </code></pre>
        <h3>4. Точкова діаграма (Scatter Plot)</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

x = np.random.rand(100)
y = np.random.rand(100)
sizes = np.random.randint(10, 200, size=100)  # Розмір точок
colors = np.random.rand(100)  # Кольори точок

plt.scatter(x, y, s=sizes, c=colors, alpha=0.5, cmap="viridis")
plt.colorbar(label="Інтенсивність кольору")

plt.title("Точкова діаграма")
plt.xlabel("x")
plt.ylabel("y")
plt.grid(True)

plt.show()
        </code></pre>
        <h3>5. Побудова кількох графіків в одному вікні</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)

plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.plot(x, y1, label="sin(x)", color="blue")
plt.title("Синус")
plt.grid(True)
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(x, y2, label="cos(x)", color="green")
plt.title("Косинус")
plt.grid(True)
plt.legend()

plt.tight_layout()
plt.show()
        </code></pre>
        <h3>6. Графік теплової карти (Heatmap)</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

matrix = np.random.rand(10, 10)

plt.imshow(matrix, cmap="hot", interpolation="nearest")
plt.colorbar(label="Інтенсивність")

plt.title("Теплова карта")
plt.show()
        </code></pre>
    </article>

    <h2>Приклади 2D Графіки: Seaborn</h2>
    <article>
        <h3>1. Гістограма (Histogram)</h3>
        <pre><code>
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

data = np.random.normal(0, 1, 1000)

sns.histplot(data, kde=True, color="blue", bins=30)

plt.title("Гістограма розподілу")
plt.xlabel("Значення")
plt.ylabel("Частота")

plt.show()
        </code></pre>
        <h3>2. Графік розсіювання (Scatter Plot)</h3>
        <pre><code>
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

data = pd.DataFrame({
    "x": np.random.rand(100),
    "y": np.random.rand(100),
    "size": np.random.randint(10, 200, 100)
})

sns.scatterplot(data=data, x="x", y="y", size="size", sizes=(10, 200), hue="y", palette="viridis")

plt.title("Точковий графік")
plt.xlabel("x")
plt.ylabel("y")

plt.show()
        </code></pre>
        <h3>3. Парні графіки (Pairplot)</h3>
        <pre><code>
import seaborn as sns
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

data = pd.DataFrame({
    "feature_1": np.random.rand(100),
    "feature_2": np.random.rand(100),
    "feature_3": np.random.rand(100),
    "class": np.random.choice(["A", "B"], size=100)
})

sns.pairplot(data, hue="class", palette="coolwarm")

plt.show()
        </code></pre>
        <h3>4. Ящик з вусами (Boxplot)</h3>
        <pre><code>
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

data = pd.DataFrame({
    "group": np.random.choice(["Group A", "Group B", "Group C"], size=100),
    "value": np.random.normal(0, 1, 100)
})

sns.boxplot(data=data, x="group", y="value", hue="group", palette="Set2", legend=False)

plt.title("Boxplot для груп")
plt.xlabel("Група")
plt.ylabel("Значення")

plt.show()
        </code></pre>
        <h3>5. Теплова карта (Heatmap)</h3>
        <pre><code>
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

data = np.random.rand(10, 10)

sns.heatmap(data, annot=True, cmap="coolwarm", cbar_kws={"label": "Інтенсивність"})

plt.title("Теплова карта")
plt.xlabel("X")
plt.ylabel("Y")

plt.show()
        </code></pre>
        <h3>6. Лінійна регресія (Regression Plot)</h3>
        <pre><code>
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

x = np.linspace(0, 10, 100)
y = 2 * x + np.random.normal(0, 2, 100)
data = pd.DataFrame({"x": x, "y": y})

sns.regplot(data=data, x="x", y="y", color="green")

plt.title("Лінійна регресія")
plt.xlabel("x")
plt.ylabel("y")

plt.show()
        </code></pre>
        <h3>7. Категоріальні дані (Bar Plot)</h3>
        <pre><code>
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd

data = pd.DataFrame({
    "group": ["A", "B", "C", "D"],
    "value": [10, 20, 15, 30]
})

data["hue"] = data["group"]

sns.barplot(data=data, x="group", y="value", hue="hue", dodge=False, palette="Blues")

plt.title("Стовпчиковий графік")
plt.xlabel("Група")
plt.ylabel("Значення")
plt.legend([], [], frameon=False)  # Вимикаємо легенду

plt.show()
        </code></pre>
        </article>

            <h2>Приклади 2D Графіки: Plotly</h2>
        <article>
        <h3>1. Лінійний графік</h3>
        <pre><code>
import plotly.graph_objects as go
import numpy as np

x = np.linspace(-10, 10, 100)
y = x ** 2

fig = go.Figure(data=go.Scatter(x=x, y=y, mode='lines', name='y = x^2'))
fig.update_layout(title="Лінійний графік", xaxis_title="x", yaxis_title="y")

fig.show()
        </code></pre>
        <h3>2. Графік розсіювання (Scatter Plot)</h3>
        <pre><code>
import plotly.express as px
import pandas as pd
import numpy as np

data = pd.DataFrame({
    "x": np.random.rand(100),
    "y": np.random.rand(100),
    "size": np.random.randint(10, 50, 100),
    "color": np.random.choice(["A", "B", "C"], size=100)
})

fig = px.scatter(
    data,
    x="x",
    y="y",
    size="size",
    color="color",
    title="Графік розсіювання"
)

fig.show()
        </code></pre>
        <h3>3. Стовпчиковий графік (Bar Chart)</h3>
        <pre><code>
import plotly.express as px
import pandas as pd

data = pd.DataFrame({
    "group": ["A", "B", "C", "D"],
    "value": [10, 20, 15, 30]
})

fig = px.bar(data, x="group", y="value", title="Стовпчиковий графік", text="value")
fig.update_traces(textposition='outside')

fig.show()
        </code></pre>
        <h3>4. Теплова карта (Heatmap)</h3>
        <pre><code>
import plotly.graph_objects as go
import numpy as np

data = np.random.rand(10, 10)

fig = go.Figure(data=go.Heatmap(
    z=data,
    colorscale='Viridis'
))
fig.update_layout(title="Теплова карта", xaxis_title="X", yaxis_title="Y")

fig.show()
        </code></pre>
        <h3>5. Boxplot (Ящик з вусами)</h3>
        <pre><code>
import plotly.express as px
import pandas as pd
import numpy as np

data = pd.DataFrame({
    "group": np.random.choice(["Group A", "Group B", "Group C"], size=100),
    "value": np.random.normal(0, 1, 100)
})

fig = px.box(data, x="group", y="value", title="Boxplot для груп")
fig.update_traces(boxmean='sd')  # Додати середнє та стандартне відхилення

fig.show()
        </code></pre>
        <h3>6. Лінійна регресія</h3>
        <pre><code>
import plotly.express as px
import pandas as pd
import numpy as np

x = np.linspace(0, 10, 100)
y = 2 * x + np.random.normal(0, 2, 100)
data = pd.DataFrame({"x": x, "y": y})

fig = px.scatter(data, x="x", y="y", trendline="ols", title="Лінійна регресія")
fig.update_traces(marker=dict(size=6))

fig.show()
        </code></pre>
        <h3>7. Кільцевий графік (Pie / Donut Chart)</h3>
        <pre><code>
import plotly.express as px
import pandas as pd

data = pd.DataFrame({
    "category": ["A", "B", "C", "D"],
    "value": [10, 20, 15, 30]
})

fig = px.pie(data, names="category", values="value", title="Кільцевий графік", hole=0.4)

fig.show()
        </code></pre>
        <h3>8. Підграфіки (Subplots)</h3>
        <pre><code>
from plotly.subplots import make_subplots
import plotly.graph_objects as go
import numpy as np

x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)

fig = make_subplots(rows=1, cols=2, subplot_titles=("Синус", "Косинус"))

fig.add_trace(go.Scatter(x=x, y=y1, mode="lines", name="sin(x)"), row=1, col=1)
fig.add_trace(go.Scatter(x=x, y=y2, mode="lines", name="cos(x)"), row=1, col=2)

fig.update_layout(title="Підграфіки")
fig.show()
        </code></pre>
    </article>
        
    <h2>Приклади 2D Графіки: Bokeh</h2>
    <article>
        <h3>1. Лінійний графік</h3>
        <pre><code>
from bokeh.plotting import figure, show
import numpy as np

x = np.linspace(-10, 10, 100)
y = x ** 2

p = figure(title="Лінійний графік", x_axis_label="x", y_axis_label="y")
p.line(x, y, legend_label="y = x^2", line_width=2)

show(p)
        </code></pre>
        <h3>2. Графік розсіювання (Scatter Plot)</h3>
        <pre><code>
from bokeh.plotting import figure, show
from bokeh.models import HoverTool
import numpy as np

x = np.random.rand(100)
y = np.random.rand(100)
sizes = np.random.randint(5, 20, size=100)

p = figure(title="Графік розсіювання", x_axis_label="x", y_axis_label="y", tools="pan,box_zoom,reset")
p.scatter(x, y, size=sizes, color="navy", alpha=0.6)

hover = HoverTool()
hover.tooltips = [("x", "@x"), ("y", "@y")]
p.add_tools(hover)

show(p)
        </code></pre>
        <h3>3. Стовпчиковий графік (Bar Chart)</h3>
        <pre><code>
from bokeh.plotting import figure, show
from bokeh.io import output_notebook

groups = ["A", "B", "C", "D"]
values = [10, 20, 15, 30]

p = figure(x_range=groups, title="Стовпчиковий графік", x_axis_label="Групи", y_axis_label="Значення")
p.vbar(x=groups, top=values, width=0.5, color="skyblue")

show(p)
        </code></pre>
        <h3>4. Теплова карта (Heatmap)</h3>
        <pre><code>
from bokeh.plotting import figure, show
from bokeh.models import LinearColorMapper, ColorBar
import numpy as np

data = np.random.rand(10, 10)

p = figure(title="Теплова карта", x_axis_label="X", y_axis_label="Y", x_range=(0, 10), y_range=(0, 10))
mapper = LinearColorMapper(palette="Viridis256", low=data.min(), high=data.max())
p.image(image=[data], x=0, y=0, dw=10, dh=10, color_mapper=mapper)

color_bar = ColorBar(color_mapper=mapper, label_standoff=12, location=(0, 0))
p.add_layout(color_bar, 'right')

show(p)
        </code></pre>
        <h3>5. Boxplot (Ящик з вусами)</h3>
        <pre><code>
from bokeh.plotting import figure, show
from bokeh.models import ColumnDataSource
from bokeh.io import output_file
import pandas as pd
import numpy as np

data = pd.DataFrame({
    "group": np.random.choice(["Group A", "Group B", "Group C"], size=100),
    "value": np.random.normal(0, 1, 100)
})

q1 = data.groupby("group")["value"].quantile(0.25)
q2 = data.groupby("group")["value"].quantile(0.5)
q3 = data.groupby("group")["value"].quantile(0.75)
iqr = q3 - q1
upper = q3 + 1.5 * iqr
lower = q1 - 1.5 * iqr

groups = ["Group A", "Group B", "Group C"]
source = ColumnDataSource(data=dict(groups=groups, q1=q1, q2=q2, q3=q3, upper=upper, lower=lower))

p = figure(title="Boxplot (Ящик з вусами)", x_range=groups, y_axis_label="Value")

p.vbar(x="groups", top="q3", bottom="q1", width=0.7, source=source, fill_color="lightblue", line_color="black")
p.segment("groups", "upper", "groups", "q3", source=source, line_color="black")
p.segment("groups", "lower", "groups", "q1", source=source, line_color="black")

p.vbar(x="groups", top="q2", bottom="q2", width=0.7, source=source, line_color="black")

output_file("boxplot.html")
show(p)
        </code></pre>
        <h3>6. Лінійна регресія</h3>
        <pre><code>
from bokeh.plotting import figure, show
import numpy as np

x = np.linspace(0, 10, 100)
y = 2 * x + np.random.normal(0, 2, 100)

m, b = np.polyfit(x, y, 1)
regression_line = m * x + b

p = figure(title="Лінійна регресія", x_axis_label="x", y_axis_label="y")
p.scatter(x, y, color="blue", alpha=0.6, legend_label="Дані")
p.line(x, regression_line, color="red", line_width=2, legend_label="Лінія регресії")

show(p)
        </code></pre>
        <h3>7. Кільцевий графік (Donut Chart)</h3>
        <pre><code>
from bokeh.plotting import figure, show
from bokeh.transform import cumsum
from bokeh.palettes import Category20c
import pandas as pd
import numpy as np

data = pd.Series([10, 20, 15, 30], index=["A", "B", "C", "D"])

data = data.reset_index(name='value').rename(columns={'index': 'category'})
data['angle'] = data['value'] / data['value'].sum() * 2 * np.pi
data['color'] = Category20c[len(data)]

p = figure(title="Кільцевий графік", height=350, toolbar_location=None, tools="hover", tooltips="@category: @value")
p.wedge(x=0, y=1, radius=0.4, start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
        line_color="white", fill_color='color', legend_field='category', source=data)

show(p)
        </code></pre>
    </article>
    
    <h2>Приклади 2D Графіки: ggplot</h2>
    <article>
        <h3>1. Лінійний графік (Line Plot)</h3>
        <pre><code>
from plotnine import ggplot, aes, geom_line, ggtitle
import pandas as pd

x = range(-10, 11)
y = [i ** 2 for i in x]
data = pd.DataFrame({"x": x, "y": y})

plot = (
    ggplot(data, aes(x="x", y="y")) +
    geom_line(color="blue", size=1.5) +
    ggtitle("Лінійний графік: y = x^2")
)

plot.show()
        </code></pre>
        <h3>2. Графік розсіювання (Scatter Plot)</h3>
        <pre><code>
from plotnine import ggplot, aes, geom_point, ggtitle
import pandas as pd

data = pd.DataFrame({
    "x": [1, 2, 3, 4, 5],
    "y": [2, 4, 6, 8, 10]
})

plot = (
    ggplot(data, aes(x="x", y="y")) +
    geom_point(color="green", size=3) +
    ggtitle("Графік розсіювання")
)

plot.show()
        </code></pre>
        <h3>3. Стовпчиковий графік (Bar Plot)</h3>
        <pre><code>
from plotnine import ggplot, aes, geom_bar, ggtitle
import pandas as pd

data = pd.DataFrame({
    "category": ["A", "B", "C", "D", "E"],
    "values": [10, 20, 15, 25, 30]
})

plot = (
    ggplot(data, aes(x="category", y="values")) +
    geom_bar(stat="identity", fill="blue", color="black") +
    ggtitle("Стовпчиковий графік")
)

plot.show()
        </code></pre>
        <h3>4. Гістограма</h3>
        <pre><code>
from plotnine import ggplot, aes, geom_histogram, ggtitle
import pandas as pd
import numpy as np

data = pd.DataFrame({"values": np.random.normal(0, 1, 1000)})

plot = (
    ggplot(data, aes(x="values")) +
    geom_histogram(binwidth=0.2, fill="orange", color="black") +
    ggtitle("Гістограма")
)

plot.show()
        </code></pre>
        <h3>5. Boxplot (Ящик з вусами)</h3>
        <pre><code>
from plotnine import ggplot, aes, geom_boxplot, ggtitle
import pandas as pd

data = pd.DataFrame({
    "category": ["A", "A", "B", "B", "C", "C"],
    "values": [5, 7, 8, 6, 9, 11]
})

plot = (
    ggplot(data, aes(x="category", y="values")) +
    geom_boxplot(fill="cyan", color="black") +
    ggtitle("Boxplot (Ящик з вусами)")
)

plot.show()
        </code></pre>
        <h3>6. Лінійна регресія</h3>
        <pre><code>
from plotnine import ggplot, aes, geom_point, geom_smooth, ggtitle
import pandas as pd

data = pd.DataFrame({
    "x": range(1, 11),
    "y": [2.3, 2.9, 3.6, 4.5, 5.1, 6.2, 6.8, 7.4, 8.5, 9.2]
})

plot = (
    ggplot(data, aes(x="x", y="y")) +
    geom_point(color="blue", size=3) +
    geom_smooth(method="lm", color="red", se=False) +
    ggtitle("Лінійна регресія")
)

plot.show()
        </code></pre>
        <h3>7. Теплова карта (Heatmap)</h3>
        <pre><code>
from plotnine import ggplot, aes, geom_tile, ggtitle
import pandas as pd

data = pd.DataFrame({
    "x": ["A", "A", "B", "B", "C", "C"],
    "y": ["X", "Y", "X", "Y", "X", "Y"],
    "value": [1, 2, 3, 4, 5, 6]
})

plot = (
    ggplot(data, aes(x="x", y="y", fill="value")) +
    geom_tile() +
    ggtitle("Теплова карта (Heatmap)")
)

plot.show()
        </code></pre>
        <h3>8. Фасетний графік (Facet Grid)</h3>
        <pre><code>
from plotnine import ggplot, aes, geom_point, facet_wrap, ggtitle
import pandas as pd

data = pd.DataFrame({
    "x": [1, 2, 3, 4, 1, 2, 3, 4],
    "y": [2, 4, 6, 8, 1, 3, 5, 7],
    "group": ["A", "A", "A", "A", "B", "B", "B", "B"]
})

plot = (
    ggplot(data, aes(x="x", y="y")) +
    geom_point(color="green", size=3) +
    facet_wrap("~group") +
    ggtitle("Фасетний графік (Facet Grid)")
)

plot.show()
        </code></pre>
    </article>
    
    <h2>Приклади 2D Графіки: Altair</h2>
    <article>
        <h3>1. Лінійний графік</h3>
        <pre><code>
import altair as alt
import pandas as pd

data = pd.DataFrame({
    "x": range(10),
    "y": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
})

chart = alt.Chart(data).mark_line().encode(
    x="x",
    y="y"
).properties(
    title="Лінійний графік"
)

chart.save("chart.html")
        </code></pre>
        <h3>2. Графік розсіювання (Scatter Plot)</h3>
        <pre><code>
import altair as alt
import pandas as pd

data = pd.DataFrame({
    "x": range(10),
    "y": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29],
    "category": ["A", "B"] * 5
})

chart = alt.Chart(data).mark_circle(size=100).encode(
    x="x",
    y="y",
    color="category",
    tooltip=["x", "y", "category"]
).properties(
    title="Графік розсіювання"
)

chart.save("chart.html")
        </code></pre>
        <h3>3. Стовпчиковий графік (Bar Plot)</h3>
        <pre><code>
import altair as alt
import pandas as pd

data = pd.DataFrame({
    "category": ["A", "B", "C", "D"],
    "values": [10, 20, 15, 25]
})

chart = alt.Chart(data).mark_bar().encode(
    x="category",
    y="values",
    color="category"
).properties(
    title="Стовпчиковий графік"
)

chart.save("chart.html")
        </code></pre>
        <h3>4. Гістограма</h3>
        <pre><code>
import altair as alt
import pandas as pd
import numpy as np

data = pd.DataFrame({
    "values": np.random.normal(0, 1, 1000)
})

chart = alt.Chart(data).mark_bar().encode(
    alt.X("values:Q", bin=alt.Bin(maxbins=30)),
    y="count()"
).properties(
    title="Гістограма"
)

chart.save("chart.html")
        </code></pre>
        <h3>5. Boxplot (Ящик з вусами)</h3>
        <pre><code>
import altair as alt
import pandas as pd

data = pd.DataFrame({
    "category": ["A", "A", "B", "B", "C", "C"],
    "values": [5, 7, 8, 6, 9, 11]
})

chart = alt.Chart(data).mark_boxplot().encode(
    x="category",
    y="values"
).properties(
    title="Boxplot (Ящик з вусами)"
)

chart.save("chart.html")
        </code></pre>
        <h3>6. Лінійна регресія</h3>
        <pre><code>
import altair as alt
import pandas as pd

data = pd.DataFrame({
    "x": range(10),
    "y": [2.3, 2.9, 3.6, 4.5, 5.1, 6.2, 6.8, 7.4, 8.5, 9.2]
})

base = alt.Chart(data).mark_point().encode(
    x="x",
    y="y"
)

line = base.transform_regression("x", "y").mark_line(color="red")

chart = (base + line).properties(
    title="Лінійна регресія"
)

chart.save("chart.html")
        </code></pre>
        <h3>7. Теплова карта (Heatmap)</h3>
        <pre><code>
import altair as alt
import pandas as pd

data = pd.DataFrame({
    "x": ["A", "A", "B", "B", "C", "C"],
    "y": ["X", "Y", "X", "Y", "X", "Y"],
    "value": [1, 2, 3, 4, 5, 6]
})

chart = alt.Chart(data).mark_rect().encode(
    x="x",
    y="y",
    color="value:Q"
).properties(
    title="Теплова карта"
)

chart.save("chart.html")
        </code></pre>
        <h3>8. Фасетний графік (Facet Grid)</h3>
        <pre><code>
import altair as alt
import pandas as pd

data = pd.DataFrame({
    "x": range(10),
    "y": [2.3, 2.9, 3.6, 4.5, 5.1, 6.2, 6.8, 7.4, 8.5, 9.2],
    "category": ["A", "B", "A", "B", "A", "B", "A", "B", "A", "B"]
})

chart = alt.Chart(data).mark_point().encode(
    x="x",
    y="y",
    color="category",
    column="category"
).properties(
    title="Фасетний графік"
)

chart.save("chart.html")
        </code></pre>
    </article>
    
    <h2>Приклади 2D Графіки: Chartify</h2>
    <article>
        <h3>1. Лінійний графік (Line Plot)</h3>
        <pre><code>
import chartify
import pandas as pd

data = pd.DataFrame({
    "date": pd.date_range(start="2023-01-01", periods=10, freq="D"),
    "value": [10, 15, 20, 25, 22, 24, 27, 30, 35, 40]
})

ch = chartify.Chart(x_axis_type='datetime', blank_labels=True)
ch.plot.line(
    data_frame=data,
    x_column="date",
    y_column="value"
)

ch.set_title("Лінійний графік")
ch.axes.set_xaxis_label("Дата")
ch.axes.set_yaxis_label("Значення")

ch.show()
        </code></pre>
        <h3>2. Графік розсіювання (Scatter Plot)</h3>
        <pre><code>
import chartify
import pandas as pd

data = pd.DataFrame({
    "x_value": range(10),
    "y_value": [2, 5, 7, 6, 9, 3, 8, 4, 5, 10]
})

ch = chartify.Chart(blank_labels=True)
ch.plot.scatter(
    data_frame=data,
    x_column="x_value",
    y_column="y_value"
)

ch.set_title("Графік розсіювання")
ch.axes.set_xaxis_label("X-значення")
ch.axes.set_yaxis_label("Y-значення")

ch.show()
        </code></pre>
        <h3>3. Стовпчиковий графік (Bar Plot)</h3>
        <pre><code>
import chartify
import pandas as pd

data = pd.DataFrame({
    "category": ["A", "B", "C", "D"],
    "value": [15, 25, 35, 20]
})

ch = chartify.Chart(x_axis_type='categorical', y_axis_type='linear')
ch.plot.bar(
    data_frame=data,
    categorical_columns=["category"],
    numeric_column="value"
)

ch.set_title("Стовпчиковий графік")
ch.axes.set_xaxis_label("Категорія")
ch.axes.set_yaxis_label("Значення")

ch.show()
        </code></pre>
        <h3>4. Гістограма (Histogram)</h3>
        <pre><code>
import chartify
import pandas as pd
import numpy as np

data = pd.DataFrame({
    "values": np.random.normal(loc=0, scale=1, size=500)
})

bin_counts, bin_edges = np.histogram(data["values"], bins=30)
bins_df = pd.DataFrame({
    "bin_left": bin_edges[:-1],
    "bin_right": bin_edges[1:],
    "count": bin_counts
})

bins_df["bin_label"] = bins_df["bin_left"].round(2).astype(str) + "-" + bins_df["bin_right"].round(2).astype(str)

ch = chartify.Chart(x_axis_type='categorical', y_axis_type='linear')

ch.plot.bar(
    data_frame=bins_df,
    categorical_columns="bin_label",
    numeric_column="count"
)

ch.set_title("Гістограма")
ch.axes.set_xaxis_label("Значення")
ch.axes.set_yaxis_label("Частота")

ch.axes.set_xaxis_tick_orientation('vertical')  # Вертикальні мітки

ch.show()
        </code></pre>
        <h3>5. Теплова карта (Heatmap)</h3>
        <pre><code>
import chartify
import pandas as pd
import numpy as np

data = pd.DataFrame({
    "x_category": ["A", "A", "B", "B", "C", "C"],
    "y_category": ["X", "Y", "X", "Y", "X", "Y"],
    "value": [10, 20, 30, 40, 50, 60]
})

ch = chartify.Chart(x_axis_type='categorical', y_axis_type='categorical')
ch.plot.heatmap(
    data_frame=data,
    x_column="x_category",
    y_column="y_category",
    color_column="value"
)

ch.set_title("Теплова карта")
ch.axes.set_xaxis_label("X Категорія")
ch.axes.set_yaxis_label("Y Категорія")

ch.show()
        </code></pre>
    </article>

    <h2>Приклади 2D Графіки: Pygal</h2>
    <article>
        <h3>1. Лінійний графік (Line Chart)</h3>
        <pre><code>
import pygal

line_chart = pygal.Line(title="Лінійний графік")
line_chart.x_labels = ['Січень', 'Лютий', 'Березень', 'Квітень', 'Травень']
line_chart.add('Продукт A', [10, 20, 15, 30, 25])
line_chart.add('Продукт B', [15, 10, 20, 25, 30])
line_chart.render_to_file('line_chart.svg')
        </code></pre>
        <h3>2. Стовпчиковий графік (Bar Chart)</h3>
        <pre><code>
import pygal

bar_chart = pygal.Bar(title="Стовпчиковий графік")
bar_chart.x_labels = ['Січень', 'Лютий', 'Березень', 'Квітень', 'Травень']
bar_chart.add('Продажі', [5, 15, 10, 25, 20])
bar_chart.render_to_file('bar_chart.svg')
        </code></pre>
        <h3>3. Гістограма (Histogram)</h3>
        <pre><code>
import pygal

hist_chart = pygal.Histogram(
    title="Гістограма оцінок студентів",
    x_title="Інтервали балів",
    y_title="Кількість студентів",
    show_legend=True,
    style=pygal.style.Style(colors=('#ff9999',))
)

hist_chart.add('Оцінки', [
    (3, 0, 5),
    (5, 5, 10),
    (7, 10, 15),
    (4, 15, 20)
])

hist_chart.render_to_file('histogram.svg')
        </code></pre>
        <h3>4. Точковий графік (Scatter Plot)</h3>
        <pre><code>
import pygal

scatter_chart = pygal.XY(title="Точковий графік")
scatter_chart.add('Точки', [(1, 1), (2, 4), (3, 9), (4, 16)])
scatter_chart.render_to_file('scatter_chart.svg')
        </code></pre>
    </article>

    <h2>Приклади 2D Графіки: Pandas Visualization</h2>
    <article>
        <h3>1. Лінійний графік (Line Chart)</h3>
        <pre><code>
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

data = {
    "Місяць": ['Січень', 'Лютий', 'Березень', 'Квітень', 'Травень'],
    "Продажі A": [10, 20, 15, 30, 25],
    "Продажі B": [15, 10, 20, 25, 30],
}
df = pd.DataFrame(data)

df.plot(x="Місяць", y=["Продажі A", "Продажі B"], kind="line", title="Лінійний графік")
plt.ylabel("Продажі")
plt.grid(True)
plt.show()
        </code></pre>
        <h3>2. Стовпчиковий графік (Bar Chart)</h3>
        <pre><code>
df.plot(x="Місяць", y=["Продажі A", "Продажі B"], kind="bar", title="Стовпчиковий графік")
plt.ylabel("Продажі")
plt.grid(axis='y')
plt.show()
        </code></pre>
        <h3>3. Кругова діаграма (Pie Chart)</h3>
        <pre><code>
df_sum = df[["Продажі A", "Продажі B"]].sum()
df_sum.plot(kind="pie", autopct="%.1f%%", title="Розподіл продажів A та B")
plt.ylabel("")  # Прибираємо підпис осі
plt.show()
        </code></pre>
        <h3>4. Точковий графік (Scatter Plot)</h3>
        <pre><code>
df.plot(x="Продажі A", y="Продажі B", kind="scatter", title="Точковий графік")
plt.xlabel("Продажі A")
plt.ylabel("Продажі B")
plt.grid(True)
plt.show()
        </code></pre>
        <h3>5. Гістограма (Histogram)</h3>
        <pre><code>
random_data = pd.Series(np.random.normal(0, 1, 1000))  
random_data.plot(kind="hist", bins=30, title="Гістограма")
plt.xlabel("Значення")
plt.grid(True)
plt.show()
        </code></pre>
    </article>

    <h2>Приклади 2D Графіки: Holoviews</h2>
    <article>
        <h3>1. Лінійний графік (Line Chart)</h3>
        <pre><code>
import holoviews as hv
import numpy as np
import pandas as pd
from bokeh.resources import CDN
from bokeh.embed import file_html
from holoviews import renderer
import plotly.graph_objects as go

hv.extension('bokeh')

x = np.linspace(0, 10, 100)
y = np.sin(x)
line_plot = hv.Curve((x, y), "x", "y").opts(
    title="Лінійний графік", xlabel="Час", ylabel="Амплітуда", color="blue")
        </code></pre>
        <h3>2. Стовпчиковий графік (Bar Chart)</h3>
        <pre><code>
bar_data = pd.DataFrame({
    "Категорія": ["A", "B", "C", "D"],
    "Значення": [10, 20, 15, 25]
})
bar_plot = hv.Bars(bar_data, kdims=["Категорія"], vdims=["Значення"]).opts(
    title="Стовпчиковий графік", color="orange", xlabel="Категорії", ylabel="Значення")
        </code></pre>
        <h3>3. Точковий графік (Scatter Plot)</h3>
        <pre><code>
x_scatter = np.random.randn(100)
y_scatter = np.random.randn(100)
scatter_plot = hv.Scatter((x_scatter, y_scatter), "x", "y").opts(
    title="Точковий графік", size=8, color="green", xlabel="X", ylabel="Y")
        </code></pre>
        <h3>4. Кругова діаграма (Pie Chart)</h3>
        <pre><code>
pie_labels = ["A", "B", "C"]
pie_values = [30, 20, 50]

pie_fig = go.Figure(data=[go.Pie(labels=pie_labels, values=pie_values)])
pie_fig.update_layout(title_text="Кругова діаграма")
        </code></pre>
        <h3>5. Гістограма (Histogram)</h3>
        <pre><code>
hist_data = np.random.normal(size=1000)
hist, edges = np.histogram(hist_data, bins=30)
hist_plot = hv.Histogram((edges, hist)).opts(
    title="Гістограма", xlabel="Значення", ylabel="Частота", color="purple")

# Об'єднання всіх Holoviews графіків
layout = (line_plot + bar_plot + scatter_plot + hist_plot).cols(2)
bokeh_layout = renderer('bokeh').get_plot(layout).state
html_bokeh = file_html(bokeh_layout, CDN, "Holoviews графіки")

html_plotly = pie_fig.to_html(full_html=False, include_plotlyjs='cdn')

final_html = html_bokeh.replace('</body>', f'{html_plotly}</body>')

with open("output.html", "w", encoding='utf-8') as f:
    f.write(final_html)
        </code></pre>
    </article>

    <h2>Приклади 2D Графіки: mplfinance</h2>
    <article>
        <h3>1. Свічковий графік (Candlestick)</h3>
        <pre><code>
import mplfinance as mpf
import pandas as pd
import numpy as np

np.random.seed(42)
dates = pd.date_range("2023-01-01", periods=50)
data = {
    "Open": np.random.uniform(100, 200, size=50),
    "High": np.random.uniform(200, 300, size=50),
    "Low": np.random.uniform(50, 100, size=50),
    "Close": np.random.uniform(100, 200, size=50),
    "Volume": np.random.randint(1000, 5000, size=50),
}
df = pd.DataFrame(data, index=dates)

mpf.plot(df, type="candle", title="Свічковий графік", style="yahoo", volume=True)
        </code></pre>
        <h3>2. OHLC графік (Open-High-Low-Close)</h3>
        <pre><code>
mpf.plot(df, type="ohlc", title="OHLC графік", style="default")
        </code></pre>
        <h3>3. Лінійний графік</h3>
        <pre><code>
mpf.plot(df, type="line", title="Лінійний графік цін", style="charles", ylabel="Ціна")
        </code></pre>
        <h3>4. Свічковий графік з EMA та SMA</h3>
        <pre><code>
add_ema = mpf.make_addplot(df["Close"].rolling(window=5).mean(), color="blue", label="EMA (5)")
add_sma = mpf.make_addplot(df["Close"].rolling(window=10).mean(), color="orange", label="SMA (10)")
mpf.plot(df, type="candle", title="Свічковий графік з EMA та SMA", style="yahoo", addplot=[add_ema, add_sma], volume=True)
        </code></pre>
        <h3>5. Спрощений графік об'ємів</h3>
        <pre><code>
mpf.plot(df, type="line", title="Об'єми торгів", style="classic", ylabel="Об'єми", volume=True)
        </code></pre>
    </article>

    <h2>Приклади 3D Візуалізації: Plotly (3D)</h2>
    <article>
        <h3>1. 3D Точка (Scatter 3D)</h3>
        <pre><code>
import plotly.graph_objects as go
import numpy as np

x = np.random.uniform(-10, 10, 100)
y = np.random.uniform(-10, 10, 100)
z = np.random.uniform(-10, 10, 100)

scatter_3d = go.Figure(
    data=[go.Scatter3d(x=x, y=y, z=z, mode='markers', marker=dict(size=5, color=z, colorscale='Viridis'))]
)
scatter_3d.update_layout(title="3D Точки", scene=dict(xaxis_title="X", yaxis_title="Y", zaxis_title="Z"))
scatter_3d.show()
        </code></pre>
        <h3>2. 3D Поверхня (Surface)</h3>
        <pre><code>
x = np.linspace(-10, 10, 50)
y = np.linspace(-10, 10, 50)
x, y = np.meshgrid(x, y)
z = np.sin(np.sqrt(x ** 2 + y ** 2))

surface_3d = go.Figure(
    data=[go.Surface(z=z, x=x, y=y, colorscale='Viridis')]
)
surface_3d.update_layout(title="3D Поверхня", scene=dict(xaxis_title="X", yaxis_title="Y", zaxis_title="Z"))
surface_3d.show()
        </code></pre>
        <h3>3. 3D Лінія (Line 3D)</h3>
        <pre><code>
t = np.linspace(0, 4 * np.pi, 100)
x = np.sin(t)
y = np.cos(t)
z = t

line_3d = go.Figure(
    data=[go.Scatter3d(x=x, y=y, z=z, mode='lines', line=dict(width=3, color='blue'))]
)
line_3d.update_layout(title="3D Лінія", scene=dict(xaxis_title="X", yaxis_title="Y", zaxis_title="Z"))
line_3d.show()
        </code></pre>
        <h3>4. 3D Стрічка (Ribbon 3D)</h3>
        <pre><code>
x = np.linspace(0, 1, 50)
y = np.linspace(0, 1, 50)
z = np.linspace(0, 1, 50)
z_offset = np.outer(np.sin(x * np.pi), np.cos(y * np.pi))

ribbon_3d = go.Figure(
    data=[go.Surface(z=z_offset, x=x, y=y, colorscale='Cividis')]
)
ribbon_3d.update_layout(title="3D Стрічка", scene=dict(xaxis_title="X", yaxis_title="Y", zaxis_title="Z"))
ribbon_3d.show()
        </code></pre>
        <h3>5. 3D Гістограма (Bar 3D)</h3>
        <pre><code>
x = ['1', '2', '3', '4']
y = ['1', '2', '3', '4']
z_values = np.array([[1, 3, 5, 7], [2, 4, 6, 8], [1, 5, 2, 7], [3, 8, 4, 6]])

# Створення 3D-графіка
fig = go.Figure()

for i, x_val in enumerate(x):
    for j, y_val in enumerate(y):
        fig.add_trace(
            go.Scatter3d(
                x=[x_val], y=[y_val], z=[0],
                mode='lines',
                line=dict(width=0.5, color='blue'),
                showlegend=False
            )
        )
        fig.add_trace(
            go.Scatter3d(
                x=[x_val, x_val], y=[y_val, y_val], z=[0, z_values[i][j]],
                mode='lines',
                line=dict(width=2, color='blue'),
                showlegend=False
            )
        )

# Налаштування графіка
fig.update_layout(
    title="3D Гістограма",
    scene=dict(
        xaxis_title="X",
        yaxis_title="Y",
        zaxis_title="Z"
    )
)

# Відображення графіка
fig.show()
        </code></pre>
    </article>

    <h2>Приклади 3D Візуалізації: Mayavi</h2>
    <article>
        <h3>1. 3D Точки (Scatter 3D)</h3>
        <pre><code>
from mayavi import mlab
import numpy as np

mlab.figure(size=(800, 600), bgcolor=(1, 1, 1))

n = 200
x = np.random.uniform(-5, 5, n)
y = np.random.uniform(-5, 5, n)
z = np.random.uniform(-5, 5, n)
s = np.random.uniform(1, 10, n)
scatter = mlab.points3d(x, y, z, s, scale_factor=0.3, colormap="coolwarm")

mlab.show()
        </code></pre>
        <h3>2. 3D Поверхня (Surface)</h3>
        <pre><code>
X, Y = np.mgrid[-3:3:100j, -3:3:100j]
Z = np.sin(X ** 2 + Y ** 2)
surface = mlab.surf(X, Y, Z, colormap='coolwarm')
mlab.colorbar(surface, title="Значення Z", orientation='vertical')
mlab.show()
        </code></pre>
        <h3>3. 3D Лінія (Line 3D)</h3>
        <pre><code>
t = np.linspace(0, 4 * np.pi, 100)
x = np.sin(t)
y = np.cos(t)
z = t / np.pi
line = mlab.plot3d(x, y, z, t, tube_radius=0.05, colormap="plasma")
mlab.show()
        </code></pre>
        <h3>4. 3D Стрічка (Ribbon 3D)</h3>
        <pre><code>
x = np.linspace(-5, 5, 50)
y = np.sin(x)
z = np.zeros_like(x)
ribbon = mlab.mesh(np.array([x, x]), np.array([y, y + 1]), np.array([z, z + 1]), colormap="viridis")
mlab.show()
        </code></pre>
        <h3>5. 3D Гістограма (Bar 3D)</h3>
        <pre><code>
x, y = np.mgrid[-4:4:10j, -4:4:10j]
z = np.random.rand(*x.shape) * 5
bars = mlab.barchart(x.flatten(), y.flatten(), z.flatten(), color=(0, 0.5, 1))
mlab.show()
        </code></pre>
    </article>

    <h2>Приклади 3D Візуалізації: VisPy</h2>
    <article>
        <h3>1. 3D Точки (Scatter 3D)</h3>
        <pre><code>
import numpy as np
from vispy import app, scene

canvas = scene.SceneCanvas(keys='interactive', size=(800, 600), show=True)
view = canvas.central_widget.add_view()
view.camera = 'turntable'

n = 100
scatter_data = np.random.normal(size=(n, 3), scale=10)
scatter = scene.visuals.Markers(pos=scatter_data, edge_color='blue', face_color='red', size=5, parent=view.scene)

if __name__ == '__main__':
    app.run()
        </code></pre>
        <h3>2. 3D Поверхня (Surface)</h3>
        <pre><code>
x = np.linspace(-10, 10, 50)
y = np.linspace(-10, 10, 50)
x, y = np.meshgrid(x, y)
z = np.sin(0.5 * x) * np.cos(0.5 * y)
surface = scene.visuals.SurfacePlot(x=x, y=y, z=z, shading='smooth', color=(0.3, 0.5, 0.8, 1), parent=view.scene)
        </code></pre>
        <h3>3. 3D Лінія (Line 3D)</h3>
        <pre><code>
n = 100
t = np.linspace(0, 6 * np.pi, n)
x = np.cos(t) * t
y = np.sin(t) * t
z = t

line_data = np.column_stack((x, y, z))

line = scene.visuals.Line(pos=line_data, color='lime', width=2, parent=view.scene)

        </code></pre>
        <h3>4. 3D Стрічка (Ribbon 3D)</h3>
        <pre><code>
t = np.linspace(0, 4*np.pi, 100)
x_ribbon = np.sin(t) * 10
y_ribbon = np.cos(t) * 10
z_ribbon = t
ribbon_data = np.c_[x_ribbon, y_ribbon, z_ribbon]
ribbon = scene.visuals.Tube(points=ribbon_data, radius=0.5, color='green', parent=view.scene)

        </code></pre>
        <h3>5. 3D Гістограма (Bar 3D)</h3>
        <pre><code>
import numpy as np
from vispy import app, scene
from vispy.visuals.transforms import STTransform

canvas = scene.SceneCanvas(keys='interactive', size=(800, 600), show=True)
view = canvas.central_widget.add_view()
view.camera = 'turntable'

x_bins = 6
y_bins = 6
heights = np.random.randint(1, 10, size=(x_bins, y_bins))

for i in range(x_bins):
    for j in range(y_bins):
        height = heights[i, j]

        cube = scene.visuals.Cube(size=(0.9, 0.9, height),
                                  color=(0.4, 0.7, 1, 1), edge_color='black', parent=view.scene)

        cube.transform = STTransform(translate=(i, j, height / 2))

if __name__ == '__main__':
    app.run()
        </code></pre>
    </article>

    <h2>Приклади 3D Візуалізації: VTK</h2>
    <article>
        <h3>1. 3D Точки (Scatter 3D)</h3>
        <pre><code>
import vtk
import random

renderer = vtk.vtkRenderer()
render_window = vtk.vtkRenderWindow()
render_window.AddRenderer(renderer)

interactor = vtk.vtkRenderWindowInteractor()
interactor.SetRenderWindow(render_window)

for _ in range(100):
    x, y, z = random.uniform(-10, 10), random.uniform(-10, 10), random.uniform(-10, 10)

    sphere = vtk.vtkSphereSource()
    sphere.SetCenter(x, y, z)
    sphere.SetRadius(0.3)
    sphere.SetThetaResolution(16)
    sphere.SetPhiResolution(16)

    mapper = vtk.vtkPolyDataMapper()
    mapper.SetInputConnection(sphere.GetOutputPort())

    actor = vtk.vtkActor()
    actor.SetMapper(mapper)

    actor.GetProperty().SetColor(random.random(), random.random(), random.random())

    renderer.AddActor(actor)

renderer.SetBackground(0.1, 0.1, 0.2)
render_window.Render()
interactor.Start()
        </code></pre>
        <h3>2. 3D Поверхня (Surface)</h3>
        <pre><code>
import vtk
import numpy as np

grid_size = 50
points = vtk.vtkPoints()
for i in range(grid_size):
    for j in range(grid_size):
        z = np.sin(i / 5.0) * np.cos(j / 5.0) * 5
        points.InsertNextPoint(i, j, z)

polys = vtk.vtkCellArray()
for i in range(grid_size - 1):
    for j in range(grid_size - 1):
        id1 = i * grid_size + j
        id2 = id1 + 1
        id3 = id1 + grid_size + 1
        id4 = id1 + grid_size

        quad = vtk.vtkQuad()
        quad.GetPointIds().SetId(0, id1)
        quad.GetPointIds().SetId(1, id2)
        quad.GetPointIds().SetId(2, id3)
        quad.GetPointIds().SetId(3, id4)

        polys.InsertNextCell(quad)

polydata = vtk.vtkPolyData()
polydata.SetPoints(points)
polydata.SetPolys(polys)

mapper = vtk.vtkPolyDataMapper()
mapper.SetInputData(polydata)

actor = vtk.vtkActor()
actor.SetMapper(mapper)

renderer = vtk.vtkRenderer()
renderer.AddActor(actor)
renderer.SetBackground(0.1, 0.2, 0.3)

render_window = vtk.vtkRenderWindow()
render_window.AddRenderer(renderer)

interactor = vtk.vtkRenderWindowInteractor()
interactor.SetRenderWindow(render_window)

render_window.Render()
interactor.Start()
        </code></pre>
        <h3>3. 3D Лінія (Line 3D)</h3>
        <pre><code>
import vtk

points = vtk.vtkPoints()
points.InsertNextPoint(0, 0, 0)
points.InsertNextPoint(10, 10, 10)

line = vtk.vtkLine()
line.GetPointIds().SetId(0, 0)
line.GetPointIds().SetId(1, 1)

cells = vtk.vtkCellArray()
cells.InsertNextCell(line)

polydata = vtk.vtkPolyData()
polydata.SetPoints(points)
polydata.SetLines(cells)

mapper = vtk.vtkPolyDataMapper()
mapper.SetInputData(polydata)

actor = vtk.vtkActor()
actor.SetMapper(mapper)
actor.GetProperty().SetLineWidth(4)

renderer = vtk.vtkRenderer()
renderer.AddActor(actor)
renderer.SetBackground(0.2, 0.2, 0.2)

render_window = vtk.vtkRenderWindow()
render_window.AddRenderer(renderer)

interactor = vtk.vtkRenderWindowInteractor()
interactor.SetRenderWindow(render_window)

render_window.Render()
interactor.Start()
        </code></pre>
        <h3>4. 3D Стрічка (Ribbon 3D)</h3>
        <pre><code>
import vtk
import math

points = vtk.vtkPoints()
for i in range(100):
    x = i * 0.2
    y = math.sin(i * 0.1) * 5
    z = math.cos(i * 0.1) * 5
    points.InsertNextPoint(x, y, z)

polyline = vtk.vtkPolyLine()
polyline.GetPointIds().SetNumberOfIds(100)
for i in range(100):
    polyline.GetPointIds().SetId(i, i)

cells = vtk.vtkCellArray()
cells.InsertNextCell(polyline)

polydata = vtk.vtkPolyData()
polydata.SetPoints(points)
polydata.SetLines(cells)

ribbon_filter = vtk.vtkRibbonFilter()
ribbon_filter.SetInputData(polydata)
ribbon_filter.SetWidth(1.0)
ribbon_filter.Update()

mapper = vtk.vtkPolyDataMapper()
mapper.SetInputConnection(ribbon_filter.GetOutputPort())

actor = vtk.vtkActor()
actor.SetMapper(mapper)

renderer = vtk.vtkRenderer()
renderer.AddActor(actor)
renderer.SetBackground(0.2, 0.3, 0.4)

render_window = vtk.vtkRenderWindow()
render_window.AddRenderer(renderer)

interactor = vtk.vtkRenderWindowInteractor()
interactor.SetRenderWindow(render_window)

render_window.Render()
interactor.Start()
        </code></pre>
        <h3>5. 3D Гістограма (Bar 3D)</h3>
        <pre><code>
import vtk
import random

renderer = vtk.vtkRenderer()

for i in range(5):
    for j in range(5):
        height = random.uniform(1, 10)

        cube = vtk.vtkCubeSource()
        cube.SetXLength(0.9)
        cube.SetYLength(0.9)
        cube.SetZLength(height)
        cube.SetCenter(i, j, height / 2)

        mapper = vtk.vtkPolyDataMapper()
        mapper.SetInputConnection(cube.GetOutputPort())

        actor = vtk.vtkActor()
        actor.SetMapper(mapper)

        r = random.random()
        g = random.random()
        b = random.random()
        actor.GetProperty().SetColor(r, g, b)

        renderer.AddActor(actor)

renderer.SetBackground(0.2, 0.2, 0.3)

render_window = vtk.vtkRenderWindow()
render_window.AddRenderer(renderer)

interactor = vtk.vtkRenderWindowInteractor()
interactor.SetRenderWindow(render_window)

render_window.Render()
interactor.Start()
        </code></pre>
    </article>

    <h2>Приклади 3D Візуалізації: Matplotlib (3D)</h2>
    <article>
        <h3>1. 3D Точка (Scatter 3D)</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(figsize=(15, 10))

ax1 = fig.add_subplot(231, projection='3d')
x = np.random.rand(50)
y = np.random.rand(50)
z = np.random.rand(50)
ax1.scatter(x, y, z, c='r', marker='o')
ax1.set_title('3D Точка (Scatter)')
        </code></pre>
        <h3>2. 3D Поверхня (Surface)</h3>
        <pre><code>
ax2 = fig.add_subplot(232, projection='3d')
X = np.linspace(-5, 5, 50)
Y = np.linspace(-5, 5, 50)
X, Y = np.meshgrid(X, Y)
Z = np.sin(np.sqrt(X**2 + Y**2))
ax2.plot_surface(X, Y, Z, cmap='viridis')
ax2.set_title('3D Поверхня (Surface)')
        </code></pre>
        <h3>3. 3D Лінія (Line 3D)</h3>
        <pre><code>
ax3 = fig.add_subplot(233, projection='3d')
z_line = np.linspace(0, 15, 100)
x_line = np.sin(z_line)
y_line = np.cos(z_line)
ax3.plot3D(x_line, y_line, z_line, color='g')
ax3.set_title('3D Лінія (Line)')
        </code></pre>
        <h3>4. 3D Стрічка (Ribbon 3D)</h3>
        <pre><code>
ax4 = fig.add_subplot(234, projection='3d')
z_ribbon = np.linspace(0, 10, 100)
x_ribbon1 = np.sin(z_ribbon)
y_ribbon1 = np.ones_like(z_ribbon)
x_ribbon2 = np.sin(z_ribbon)
y_ribbon2 = np.ones_like(z_ribbon) * 2
for i in range(len(z_ribbon)-1):
    xs = [x_ribbon1[i], x_ribbon2[i]]
    ys = [y_ribbon1[i], y_ribbon2[i]]
    zs = [z_ribbon[i], z_ribbon[i]]
    ax4.plot(xs, ys, zs, color='orange')
ax4.set_title('3D Стрічка (Ribbon)')
        </code></pre>
        <h3>5. 3D Гістограма (Bar 3D)</h3>
        <pre><code>
ax5 = fig.add_subplot(235, projection='3d')
_x = np.arange(4)
_y = np.arange(3)
_xx, _yy = np.meshgrid(_x, _y)
x_bar, y_bar = _xx.ravel(), _yy.ravel()
z_bar = np.zeros_like(x_bar)
dx = dy = 0.5
dz = np.random.randint(1, 10, size=len(z_bar))
ax5.bar3d(x_bar, y_bar, z_bar, dx, dy, dz, shade=True, color='purple')
ax5.set_title('3D Гістограма (Bar)')

plt.tight_layout()
plt.savefig("3D_visualizations.png")
plt.show()
        </code></pre>
    </article>

    <h2>Приклади 3D Візуалізації: PyVista</h2>
    <article>
        <h3>1. 3D Точка (Scatter 3D)</h3>
        <pre><code>
import pyvista as pv
import numpy as np

plotter = pv.Plotter()

points = np.random.rand(50, 3) * 10
point_cloud = pv.PolyData(points)
plotter.add_mesh(point_cloud, color="red", point_size=10, render_points_as_spheres=True, label="3D Scatter")
        </code></pre>
        <h3>2. 3D Поверхня (Surface)</h3>
        <pre><code>
x = np.linspace(-5, 5, 50)
y = np.linspace(-5, 5, 50)
x, y = np.meshgrid(x, y)
z = np.sin(np.sqrt(x**2 + y**2))
surface = pv.StructuredGrid(x, y, z)
plotter.add_mesh(surface, cmap="viridis", label="3D Surface")
        </code></pre>
        <h3>3. 3D Лінія (Line 3D)</h3>
        <pre><code>
line_points = np.array([[i, np.sin(i), np.cos(i)] for i in np.linspace(0, 10, 100)])
line = pv.Spline(line_points, 100)
plotter.add_mesh(line, color="blue", line_width=3, label="3D Line")
        </code></pre>
        <h3>4. 3D Стрічка (Ribbon 3D)</h3>
        <pre><code>
ribbon_points = np.array([[i, np.sin(i), 0] for i in np.linspace(0, 10, 100)])
spline = pv.Spline(ribbon_points, 100)
ribbon = spline.ribbon(normal=(0, 0, 1), width=1.0)
plotter.add_mesh(ribbon, color="magenta", label="3D Ribbon")
        </code></pre>
        <h3>5. 3D Гістограма (Bar 3D)</h3>
        <pre><code>
x = np.arange(5)
y = np.arange(5)
z = np.zeros((5, 5))
dx = dy = 0.5
dz = np.random.randint(1, 10, size=(5, 5))

for i in range(5):
    for j in range(5):
        center = (x[i], y[j], dz[i, j] / 2)
        cube = pv.Cube(center=center, x_length=dx, y_length=dy, z_length=dz[i, j])
        plotter.add_mesh(cube, color="cyan", label="3D Histogram" if (i == 0 and j == 0) else None)

plotter.add_legend()
plotter.show()
        </code></pre>
    </article>

    <h2>Приклади Інтерактивної Графіки та Дашбордів: Dash</h2>
    <article>
        <h3>1. Лінійний графік з вибором країни</h3>
        <pre><code>
import dash
from dash import dcc, html, Input, Output
import plotly.express as px

app = dash.Dash(__name__)

df = px.data.gapminder()
countries = df['country'].unique()

app.layout = html.Div([
    html.H2("GDP на душу населення за роками"),
    dcc.Dropdown(
        id='country-selector',
        options=[{'label': c, 'value': c} for c in countries],
        value='Ukraine',
        clearable=False
    ),
    dcc.Graph(id='gdp-line')
])

@app.callback(
    Output('gdp-line', 'figure'),
    Input('country-selector', 'value')
)
def update_graph(selected_country):
    filtered = df[df['country'] == selected_country]
    fig = px.line(filtered, x="year", y="gdpPercap", markers=True, title=f"GDP на душу населення: {selected_country}")
    fig.update_traces(text=filtered['gdpPercap'], textposition="top center")
    fig.update_layout(hovermode="x unified")
    return fig

if __name__ == '__main__':
    app.run(debug=True)
        </code></pre>
        <h3>2. Стовпчиковий графік населення по континентах</h3>
        <pre><code>
import dash
from dash import html, dcc
import plotly.express as px

app = dash.Dash(__name__)

df = px.data.gapminder().query("year == 2007")

fig = px.bar(df, x="continent", y="pop", color="continent", title="Населення по континентах у 2007")

app.layout = html.Div([
    html.H2("Стовпчиковий графік"),
    dcc.Graph(figure=fig)
])

if __name__ == '__main__':
    app.run(debug=True)
        </code></pre>
        <h3>3. Кругова діаграма (Pie Chart)</h3>
        <pre><code>
import dash
from dash import html, dcc
import plotly.express as px

df = px.data.tips()
fig = px.pie(df, names='day', values='total_bill', title='Розподіл прибутку за днями')

app = dash.Dash(__name__)
app.layout = html.Div([
    html.H2("Кругова діаграма (Pie)"),
    dcc.Graph(figure=fig)
])

if __name__ == '__main__':
    app.run(debug=True)
        </code></pre>
        <h3>4. Кореляційна діаграма (Scatter Plot)</h3>
        <pre><code>
import dash
from dash import html, dcc
import plotly.express as px

df = px.data.iris()
fig = px.scatter(df, x="sepal_width", y="sepal_length", color="species",
                 size="petal_length", title="Кореляція розмірів у квітів")

app = dash.Dash(__name__)
app.layout = html.Div([
    html.H2("Кореляційна діаграма (Iris Dataset)"),
    dcc.Graph(figure=fig)
])

if __name__ == '__main__':
    app.run(debug=True)
        </code></pre>
        <h3>5. Інтерактивна гістограма з вибором стовпців</h3>
        <pre><code>
import dash
from dash import dcc, html, Input, Output
import plotly.express as px

df = px.data.tips()

app = dash.Dash(__name__)

app.layout = html.Div([
    html.H2("Гістограма з вибором стовпця"),
    dcc.Dropdown(
        id='column-selector',
        options=[{'label': col, 'value': col} for col in ['total_bill', 'tip']],
        value='total_bill',
        clearable=False
    ),
    dcc.Graph(id='histogram')
])

@app.callback(
    Output('histogram', 'figure'),
    Input('column-selector', 'value')
)
def update_hist(column):
    fig = px.histogram(df, x=column, nbins=20, title=f"Гістограма: {column}")
    return fig

if __name__ == '__main__':
    app.run(debug=True)
        </code></pre>
    </article>

    <h2>Приклади Інтерактивної Графіки та Дашбордів: Panel</h2>
    <article>
        <h3>1. Інтерактивний слайдер для синусоїди</h3>
        <pre><code>
import numpy as np
import panel as pn
import matplotlib.pyplot as plt

pn.extension()

def plot(freq=1.0):
    x = np.linspace(0, 10, 500)
    y = np.sin(x * freq)
    plt.figure()
    plt.plot(x, y)
    plt.title(f"Синусоїда з частотою {freq}")
    return pn.pane.Matplotlib(plt.gcf(), tight=True)

slider = pn.widgets.FloatSlider(name='Частота', start=0.1, end=5, step=0.1, value=1)
interactive_plot = pn.bind(plot, freq=slider)

pn.Column(slider, interactive_plot).show()
        </code></pre>
        <h3>2. Дропдаун + гістограма (Seaborn)</h3>
        <pre><code>
import seaborn as sns
import panel as pn
import matplotlib.pyplot as plt

pn.extension()
df = sns.load_dataset("penguins")

def plot(column):
    plt.figure()
    sns.histplot(df[column].dropna(), kde=True)
    plt.title(f"Гістограма '{column}'")
    return pn.pane.Matplotlib(plt.gcf(), tight=True)

dropdown = pn.widgets.Select(name='Ознака', options=list(df.columns))
hist = pn.bind(plot, column=dropdown)

pn.Column(dropdown, hist).servable().show()
        </code></pre>
        <h3>3. Вкладки з різними графіками</h3>
        <pre><code>
import panel as pn
import holoviews as hv
import numpy as np

pn.extension()
hv.extension('bokeh')

x = np.linspace(0, 10, 100)
sin_plot = hv.Curve((x, np.sin(x)), 'x', 'y').opts(title='Синус')
cos_plot = hv.Curve((x, np.cos(x)), 'x', 'y').opts(title='Косинус')

tabs = pn.Tabs(
    ('Синус', sin_plot),
    ('Косинус', cos_plot)
)

tabs.servable().show()
        </code></pre>
        <h3>4. Інтерактивний DataFrame</h3>
        <pre><code>
import panel as pn
import pandas as pd
import numpy as np

pn.extension()
df = pd.DataFrame(np.random.randn(10, 3), columns=['A', 'B', 'C'])
data_table = pn.widgets.DataFrame(df, name="Таблиця", width=400, height=300)

pn.Column("# Інтерактивна таблиця", data_table).servable().show()
        </code></pre>
        <h3>5. Графік з вибором Plotly</h3>
        <pre><code>
import panel as pn
import plotly.express as px

pn.extension()

df = px.data.iris()

def create_plot(column):
    fig = px.histogram(df, x=column, title=f"Plotly: Гістограма '{column}'")
    return pn.pane.Plotly(fig)

dropdown = pn.widgets.Select(name='Ознака', options=list(df.columns))
plot = pn.bind(create_plot, column=dropdown)

pn.Column("# Plotly інтерактивна гістограма", dropdown, plot).show()
       </code></pre>
    </article>

    <h2>Приклади Інтерактивної Графіки та Дашбордів: Streamlit</h2>
    <article>
        <h3>1. ВВП на душу населення у вибраній країні</h3>
        <pre><code>
import streamlit as st
import pandas as pd
import plotly.express as px

st.title("GDP per Capita у вибраній країні")

df_all = px.data.gapminder()

countries = sorted(df_all["country"].unique())
selected_country = st.selectbox("Оберіть країну:", countries, index=countries.index("Germany"))

df = df_all[df_all["country"] == selected_country]

years = df["year"].unique()
min_year, max_year = st.slider(
    "Виберіть діапазон років:",
    int(years.min()),
    int(years.max()),
    (int(years.min()), int(years.max())),
    step=5
)

filtered_df = df[(df["year"] >= min_year) & (df["year"] <= max_year)]

fig = px.line(
    filtered_df,
    x="year",
    y="gdpPercap",
    title=f"GDP per Capita у {selected_country}",
    markers=True,
    labels={"gdpPercap": "GDP per Capita", "year": "Рік"},
)

fig.update_traces(line=dict(color="royalblue", width=3), marker=dict(size=8, color="red"))

st.plotly_chart(fig, use_container_width=True)
        </code></pre>
        <h3>2. Слайдер для побудови графіка y = A * sin(x)</h3>
        <pre><code>
import streamlit as st
import numpy as np
import matplotlib.pyplot as plt

st.title("Графік y = A * sin(x)")

A = st.slider("Амплітуда (A)", 0.0, 10.0, 1.0)
x = np.linspace(0, 10, 100)
y = A * np.sin(x)

fig, ax = plt.subplots()
ax.plot(x, y)
ax.set_title("y = A * sin(x)")

st.pyplot(fig)
        </code></pre>
        <h3>3. Інтерактивна гістограма з вибором стовпця</h3>
        <pre><code>
import streamlit as st
import seaborn as sns
import matplotlib.pyplot as plt

st.title("Інтерактивна гістограма")

df = sns.load_dataset("iris")
column = st.selectbox("Оберіть стовпець", df.select_dtypes(include='number').columns)

fig, ax = plt.subplots()
sns.histplot(df[column], bins=20, kde=True, ax=ax)
st.pyplot(fig)
        </code></pre>
        <h3>4. Віджет для введення тексту + виведення</h3>
        <pre><code>
import streamlit as st

st.title("Привіт, користувач!")

name = st.text_input("Введи своє ім’я")
if name:
    st.success(f"Привіт, {name}!")
        </code></pre>
        <h3>5. Dash-like інтерактивний дашборд</h3>
        <pre><code>
import streamlit as st
import pandas as pd
import plotly.express as px

st.set_page_config(layout="wide")

df = px.data.gapminder().query("year == 2007")

col1, col2 = st.columns(2)

with col1:
    country = st.selectbox("Оберіть країну", df["country"].unique())
    country_data = df[df["country"] == country]
    st.write(f"Інфо про {country}")
    st.write(country_data)

with col2:
    fig = px.scatter(df, x="gdpPercap", y="lifeExp", size="pop", color="continent", hover_name="country",
                     log_x=True, size_max=60)
    st.plotly_chart(fig, use_container_width=True)
        </code></pre>
    </article>

    <h2>Приклади Інтерактивної Графіки та Дашбордів: Shiny for Python</h2>
    <article>
        <h3>1. Інтерактивна лінійна діаграма з matplotlib</h3>
        <pre><code>
from shiny import App, render, ui, reactive
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

df = pd.DataFrame({
    "Рік": np.arange(2000, 2021),
    "Значення": [round(i ** 1.3 + 50 + np.random.randint(-10, 10), 2) for i in range(21)]
})

app_ui = ui.page_fluid(
    ui.h2("Інтерактивна лінійна діаграма"),
    ui.input_slider("min_year", "Початковий рік", min=df["Рік"].min(), max=df["Рік"].max(), value=df["Рік"].min(),
                    step=1),
    ui.input_select("color", "Оберіть колір лінії", choices=["blue", "green", "red", "orange", "purple"],
                    selected="blue"),
    ui.output_plot("line_plot"),
    ui.output_text_verbatim("avg_output")
)

def server(input, output, session):
    @reactive.calc
    def filtered_df():
        return df[df["Рік"] >= input.min_year()]

    @output
    @render.plot
    def line_plot():
        data = filtered_df()
        plt.plot(data["Рік"], data["Значення"], color=input.color(), marker='o')
        plt.axhline(data["Значення"].mean(), color='gray', linestyle='--', label='Середнє')
        plt.title("Значення по роках")
        plt.xlabel("Рік")
        plt.ylabel("Значення")
        plt.legend()

    @output
    @render.text
    def avg_output():
        data = filtered_df()
        return f"Середнє значення: {round(data['Значення'].mean(), 2)}"


app = App(app_ui, server)
        </code></pre>
        <h3>2. Інтерактивний слайдер з відображенням синуса</h3>
        <pre><code>
from shiny import App, ui, render, reactive
import numpy as np
import matplotlib.pyplot as plt

app_ui = ui.page_fluid(
    ui.input_slider("frequency", "Частота", 1, 10, 2),
    ui.output_plot("sine_plot")
)

def server(input, output, session):
    @output
    @render.plot
    def sine_plot():
        x = np.linspace(0, 2 * np.pi, 400)
        y = np.sin(input.frequency() * x)
        plt.plot(x, y)
        plt.title(f"sin({input.frequency()}x)")

app = App(app_ui, server)
        </code></pre>
        <h3>3. Вибір колонки для гістограми з pandas + plotly</h3>
        <pre><code>
from shiny import App, ui, render
import pandas as pd
import plotly.express as px

df = px.data.iris()

app_ui = ui.page_fluid(
    ui.input_select("column", "Оберіть колонку:", choices=list(df.select_dtypes(include="number").columns)),
    ui.output_plot("hist_plot")
)

def server(input, output, session):
    @output
    @render.plot
    def hist_plot():
        fig = px.histogram(df, x=input.column())
        fig.update_layout(title=f"Гістограма по {input.column()}")
        fig.show()

app = App(app_ui, server)
        </code></pre>
        <h3>4. Динамічне оновлення діаграми з вибором країни</h3>
        <pre><code>
from shiny import App, ui, render
import plotly.express as px
import pandas as pd

df = px.data.gapminder()

app_ui = ui.page_fluid(
    ui.input_select("country", "Оберіть країну:", choices=sorted(df["country"].unique())),
    ui.output_plot("gdp_plot")
)

def server(input, output, session):
    @output
    @render.plot
    def gdp_plot():
        country_df = df[df["country"] == input.country()]
        fig = px.line(country_df, x="year", y="gdpPercap", title=f"GDP per Capita: {input.country()}")
        fig.show()

app = App(app_ui, server)
        </code></pre>
        <h3>5. Таблиця з фільтрацією по року</h3>
        <pre><code>
from shiny import App, ui, render
import pandas as pd
import plotly.express as px

df = px.data.gapminder()

app_ui = ui.page_fluid(
    ui.input_numeric("year", "Оберіть рік", 2007, min=1952, max=2007),
    ui.output_table("filtered_table")
)

def server(input, output, session):
    @output
    @render.table
    def filtered_table():
        return df[df["year"] == input.year()]

app = App(app_ui, server)
        </code></pre>
    </article>

    <h2>Комп'ютерний зір і обробка зображень: OpenCV</h2>
    <article>
        <h3>1. Завантаження та показ зображення</h3>
        <pre><code>
import cv2
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

img = cv2.imread(path)

if img is None:
    print("Помилка: файл не знайдено або шлях неправильний!")
else:
    cv2.imshow('Зображення', img)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
        </code></pre>
        <h3>2. Перетворення в чорно-біле</h3>
        <pre><code>
import cv2
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

img = cv2.imread(path)

if img is None:
    print("Error: File not found or incorrect path!")
else:
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    cv2.imshow('Original', img)
    cv2.imshow('Gray', gray)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
        </code></pre>
        <h3>3. Перетворення в чорно-біле</h3>
        <pre><code>
import cv2
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

img = cv2.imread(path)

if img is None:
    print("Error: File not found or incorrect path!")
else:
    blurred = cv2.GaussianBlur(img, (15, 15), 0)
    cv2.imshow('Original', img)
    cv2.imshow('Blurred', blurred)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
        </code></pre>
        <h3>4. Детекція країв (Canny Edge Detection)</h3>
        <pre><code>
import cv2
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

img = cv2.imread(path)

if img is None:
    print("Error: File not found or incorrect path!")
else:
    edges = cv2.Canny(img, 100, 200)
    cv2.imshow('Original', img)
    cv2.imshow('Edges', edges)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
        </code></pre>
        <h3>5. Малювання прямокутника на зображенні</h3>
        <pre><code>
import cv2
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

img = cv2.imread(path)

if img is None:
    print("Error: File not found or incorrect path!")
else:
    start_point = (5, 5)
    end_point = (217, 220)
    color = (0, 25, 0)
    thickness = 3
    img_rect = cv2.rectangle(img.copy(), start_point, end_point, color, thickness)

    cv2.imshow('Original', img)
    cv2.imshow('Rectangle', img_rect)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
        </code></pre>
    </article>

    <h2>Комп'ютерний зір і обробка зображень: Pillow (PIL)</h2>
    <article>
        <h3>1. Завантаження та відображення зображення</h3>
        <pre><code>
from PIL import Image
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

try:
    img = Image.open(path)
    img.show()
except FileNotFoundError:
    print("Error: File not found or incorrect path!")
        </code></pre>
        <h3>2. Перетворення в чорно-білий режим (Grayscale)</h3>
        <pre><code>
from PIL import Image
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

try:
    img = Image.open(path)
    gray = img.convert('L')
    gray.show()
except FileNotFoundError:
    print("Error: File not found or incorrect path!")
        </code></pre>
        <h3>3. Обрізання частини зображення (Crop)</h3>
        <pre><code>
from PIL import Image
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

try:
    img = Image.open(path)
    cropped = img.crop((100, 100, 400, 400))
    cropped.show()
except FileNotFoundError:
    print("Error: File not found or incorrect path!")
        </code></pre>
        <h3>4. Зміна розміру зображення (Resize)</h3>
        <pre><code>
from PIL import Image
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

try:
    img = Image.open(path)
    resized = img.resize((300, 300))
    resized.show()
except FileNotFoundError:
    print("Error: File not found or incorrect path!")
        </code></pre>
        <h3>5. Поворот зображення (Rotate)</h3>
        <pre><code>
from PIL import Image
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

try:
    img = Image.open(path)
    rotated = img.rotate(90)
    rotated.show()
except FileNotFoundError:
    print("Error: File not found or incorrect path!")
        </code></pre>
    </article>

    <h2>Комп'ютерний зір і обробка зображень: scikit-image</h2>
    <article>
        <h3>1. Завантаження і показ зображення</h3>
        <pre><code>
from skimage.io import imread, imshow
import matplotlib.pyplot as plt
import os

path = os.path.join(r"E:\NewFolder", "image.jpg")
image = imread(path)

plt.imshow(image)
plt.title("Зображення")
plt.axis('off')
plt.show()
        </code></pre>
        <h3>2. Перетворення в чорно-біле</h3>
        <pre><code>
from skimage.color import rgb2gray
from skimage.io import imread
import matplotlib.pyplot as plt
import os

path = os.path.join(r"E:\NewFolder", "image.jpg")
image = imread(path)
gray = rgb2gray(image)

plt.imshow(gray, cmap='gray')
plt.title("Grayscale")
plt.axis('off')
plt.show()
        </code></pre>
        <h3>3. Обрізка зображення</h3>
        <pre><code>
from skimage.io import imread
import matplotlib.pyplot as plt
import os

path = os.path.join(r"E:\NewFolder", "image.jpg")
image = imread(path)
cropped = image[100:400, 100:400]  # [y1:y2, x1:x2]

plt.imshow(cropped)
plt.title("Обрізане зображення")
plt.axis('off')
plt.show()
        </code></pre>
        <h3>4. Зміна розміру зображення</h3>
        <pre><code>
from skimage.transform import resize
from skimage.io import imread
import matplotlib.pyplot as plt
import os

path = os.path.join(r"E:\NewFolder", "image.jpg")
image = imread(path)
resized = resize(image, (300, 300))  # (height, width)

plt.imshow(resized)
plt.title("Змінене зображення")
plt.axis('off')
plt.show()
        </code></pre>
        <h3>5. Фільтрація (розмиття) зображення</h3>
        <pre><code>
from skimage.io import imread
from skimage.filters import gaussian
import matplotlib.pyplot as plt
import os

path = os.path.join(r"E:\NewFolder", "image.jpg")
image = imread(path)
blurred = gaussian(image, sigma=2, channel_axis=-1)

plt.imshow(blurred)
plt.title("Розмите зображення")
plt.axis('off')
plt.show()
        </code></pre>
    </article>

    <h2>Комп'ютерний зір і обробка зображень: Imageio</h2>
    <article>
        <h3>1. Завантаження і показ зображення</h3>
        <pre><code>
import imageio.v3 as iio
import matplotlib.pyplot as plt

path = r"E:\NewFolder\image.jpg"

img = iio.imread(path)

plt.imshow(img)
plt.title("Зображення")
plt.axis("off")
plt.show()
        </code></pre>
        <h3>2. Збереження нового зображення</h3>
        <pre><code>
import imageio.v3 as iio
import matplotlib.pyplot as plt
import os

folder = r"E:\NewFolder"
img1_path = os.path.join(folder, "image.jpg")
img2_path = os.path.join(folder, "new image.jpg")

img1 = iio.imread(img1_path)
img2 = iio.imread(img2_path)

fig, axs = plt.subplots(1, 2, figsize=(10, 5))

axs[0].imshow(img1)
axs[0].set_title("Перше зображення")
axs[0].axis("off")

axs[1].imshow(img2)
axs[1].set_title("Друге зображення")
axs[1].axis("off")

plt.tight_layout()
plt.show()
        </code></pre>
        <h3>3. Читання кадрів з GIF</h3>
        <pre><code>
import imageio.v3 as iio
import matplotlib.pyplot as plt

gif_path = r"E:\NewFolder\GIF.gif"

frames = list(iio.imiter(gif_path))

plt.imshow(frames[0])
plt.title("Перший кадр GIF")
plt.axis("off")
plt.show()

print("Кількість кадрів:", len(frames)) 
        </code></pre>
        <h3>4. Запис відео з кількох зображень</h3>
        <pre><code>
import imageio.v3 as iio
import os
from PIL import Image

folder = r"E:\NewFolder"

filenames = ["image.jpg", "new image.jpg", "image.jpg", "new image.jpg"]

target_size = (240, 240)

images = []
for name in filenames:
    path = os.path.join(folder, name)
    img = Image.open(path).resize(target_size)
    images.append(img)

output_path = os.path.join(folder, "output_video.mp4")
iio.imwrite(output_path, images, fps=1)

print(f"Відео збережено: {output_path}")

os.startfile(output_path)
        </code></pre>
        <h3>5. Читання відео покадрово</h3>
        <pre><code>
import imageio.v3 as iio
import matplotlib.pyplot as plt
import time

video_path = r"E:\NewFolder\output_video.mp4"

frames = list(iio.imiter(video_path))

print("Кількість кадрів:", len(frames))

for i, frame in enumerate(frames):
    plt.imshow(frame)
    plt.title(f"Кадр {i + 1}")
    plt.axis("off")
    plt.pause(1)
    plt.clf()

plt.close()
        </code></pre>
    </article>

    <h2>Комп'ютерний зір і обробка зображень: PyTorch Vision</h2>
    <article>
        <h3>1. Завантаження зображення та перетворення в тензор</h3>
        <pre><code>
from torchvision import transforms, models
from PIL import Image
import torch
import matplotlib.pyplot as plt

image_path = r"E:\NewFolder\image.jpg"
image = Image.open(image_path)

transform = transforms.ToTensor()
tensor_image = transform(image)

print("Розмір тензора:", tensor_image.shape)

plt.imshow(tensor_image.permute(1, 2, 0))
plt.title("Tensor Image")
plt.axis("off")
plt.show()
        </code></pre>
        <h3>2. Попередня обробка зображення з кількома перетвореннями</h3>
        <pre><code>
from torchvision import transforms
from PIL import Image
import torch
import matplotlib.pyplot as plt

image_path = r"E:\NewFolder\image.jpg"
image = Image.open(image_path)

preprocess = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize(
        mean=[0.485, 0.456, 0.406],
        std=[0.229, 0.224, 0.225]
    )
])

input_tensor = preprocess(image)
input_batch = input_tensor.unsqueeze(0)

print("Форма обробленого тензора:", input_batch.shape)

unnormalize = transforms.Normalize(
    mean=[-0.485 / 0.229, -0.456 / 0.224, -0.406 / 0.225],
    std=[1 / 0.229, 1 / 0.224, 1 / 0.225]
)
img_for_show = unnormalize(input_tensor).permute(1, 2, 0).clamp(0, 1)

plt.imshow(img_for_show)
plt.title("Оброблене зображення")
plt.axis("off")
plt.show() 
        </code></pre>
        <h3>3. Класифікація зображення за допомогою ResNet-18</h3>
        <pre><code>
from torchvision import transforms, models
from PIL import Image
import torch
import json
import matplotlib.pyplot as plt

image_path = r"E:\NewFolder\image.jpg"
image = Image.open(image_path)

preprocess = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406],
                         std=[0.229, 0.224, 0.225])
])
input_tensor = preprocess(image).unsqueeze(0)

model = models.resnet18(weights="IMAGENET1K_V1")
model.eval()

with torch.no_grad():
    output = model(input_tensor)
    probabilities = torch.nn.functional.softmax(output[0], dim=0)

class_idx_path = "https://raw.githubusercontent.com/pytorch/hub/master/imagenet_classes.txt"
import requests
labels = requests.get(class_idx_path).text.strip().split("\n")

top5_prob, top5_catid = torch.topk(probabilities, 5)
print("🔍 Top-5 передбачень:")
for i in range(5):
    print(f"{labels[top5_catid[i]]}: {top5_prob[i].item():.4f}")

plt.imshow(image)
plt.title("Image for Classification")
plt.axis("off")
plt.show()
        </code></pre>
        <h3>4. Застосування фільтра Sobel до тензора</h3>
        <pre><code>
from torchvision import transforms
from torchvision.transforms import functional as TF
from PIL import Image
import torch
import matplotlib.pyplot as plt
import torchvision.transforms.functional as F
import torchvision.transforms.v2 as T2

image_path = r"E:\NewFolder\image.jpg"
image = Image.open(image_path)

tensor = transforms.ToTensor()(image)

gray_tensor = TF.rgb_to_grayscale(tensor)

plt.imshow(gray_tensor[0], cmap='gray')
plt.title("Grayscale Image")
plt.axis("off")
plt.show()
        </code></pre>
        <h3>5. Аугментація зображення — випадковий поворот, горизонтальне дзеркалення</h3>
        <pre><code>
from torchvision import transforms
from PIL import Image
import matplotlib.pyplot as plt

image_path = r"E:\NewFolder\image.jpg"
image = Image.open(image_path)

augment = transforms.Compose([
    transforms.RandomHorizontalFlip(p=1.0),
    transforms.RandomRotation(degrees=30),
])

augmented = augment(image)

fig, axs = plt.subplots(1, 2, figsize=(10, 5))
axs[0].imshow(image)
axs[0].set_title("Оригінал")
axs[0].axis("off")
axs[1].imshow(augmented)
axs[1].set_title("Аугментоване зображення")
axs[1].axis("off")
plt.tight_layout()
plt.show()
        </code></pre>
    </article>

    <h2>Комп'ютерний зір і обробка зображень: TensorFlow Image</h2>
    <article>
        <h3>1. Завантаження та відображення зображення</h3>
        <pre><code>
import tensorflow as tf
import matplotlib.pyplot as plt

image_path = r"E:\NewFolder\image.jpg"
image = tf.io.read_file(image_path)
image = tf.image.decode_jpeg(image, channels=3)

plt.imshow(image.numpy())
plt.title("Завантажене зображення")
plt.axis("off")
plt.show()
        </code></pre>
        <h3>2. Масштабування та нормалізація зображення</h3>
        <pre><code>
import tensorflow as tf
import matplotlib.pyplot as plt

image_path = r"E:\NewFolder\image.jpg"
image = tf.io.read_file(image_path)
image = tf.image.decode_jpeg(image, channels=3)

image = tf.image.resize(image, [324, 324])
image = tf.cast(image, tf.float32) / 255.0

plt.imshow(image.numpy())
plt.title("Масштабоване і нормалізоване зображення")
plt.axis("off")
plt.show()
        </code></pre>
        <h3>3. Аугментація зображення</h3>
        <pre><code>
import tensorflow as tf
import matplotlib.pyplot as plt

image_path = r"E:\NewFolder\image.jpg"
image = tf.io.read_file(image_path)
image = tf.image.decode_jpeg(image, channels=3)

aug_image = tf.image.random_flip_left_right(image)
aug_image = tf.image.random_brightness(aug_image, max_delta=0.1)

plt.imshow(aug_image.numpy())
plt.title("Аугментоване зображення")
plt.axis("off")
plt.show()
        </code></pre>
        <h3>4. Підготовка зображення для моделі MobileNetV2</h3>
        <pre><code>
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.applications.mobilenet_v2 import preprocess_input

image_path = r"E:\NewFolder\image.jpg"
image = tf.io.read_file(image_path)
image = tf.image.decode_jpeg(image, channels=3)

image = tf.image.resize(image, [224, 224])
image = tf.cast(image, tf.float32)

input_tensor = preprocess_input(image)

input_tensor = tf.expand_dims(input_tensor, axis=0)

print("Форма тензора:", input_tensor.shape)
        </code></pre>
        <h3>5. Класифікація зображення з MobileNetV2</h3>
        <pre><code>
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.applications.mobilenet_v2 import preprocess_input, decode_predictions

image_path = r"E:\NewFolder\image.jpg"
image = tf.io.read_file(image_path)
image = tf.image.decode_jpeg(image, channels=3)
image = tf.image.resize(image, [224, 224])
image = tf.cast(image, tf.float32)

input_tensor = preprocess_input(image)
input_tensor = tf.expand_dims(input_tensor, axis=0)

model = MobileNetV2(weights="imagenet")

preds = model.predict(input_tensor)

decoded = decode_predictions(preds, top=3)[0]
for i, (id, label, score) in enumerate(decoded):
    print(f"{i+1}. {label}: {score:.2%}")
        </code></pre>
    </article>

    <h2>Графічні інтерфейси користувача (GUI): Tkinter</h2>
    <article>
        <h3>1. Просте вікно з кнопкою</h3>
        <pre><code>
import tkinter as tk

def say_hello():
    label.config(text="Привіт, Користувач!")

root = tk.Tk()
root.title("Просте вікно")

label = tk.Label(root, text="Натисни кнопку")
label.pack(pady=10)

btn = tk.Button(root, text="Привіт", command=say_hello)
btn.pack()

root.mainloop()
        </code></pre>
        <h3>2. Текстове поле та введення користувача</h3>
        <pre><code>
import tkinter as tk

def show_text():
    text = entry.get()
    label.config(text=f"Ви ввели: {text}")

root = tk.Tk()
root.title("Введення тексту")

entry = tk.Entry(root)
entry.pack(pady=5)

btn = tk.Button(root, text="Показати", command=show_text)
btn.pack()

label = tk.Label(root, text="")
label.pack()

root.mainloop() 
        </code></pre>
        <h3>3. Обробка подій миші</h3>
        <pre><code>
import tkinter as tk

def on_click(event):
    label.config(text=f"Координати кліку: {event.x}, {event.y}")

root = tk.Tk()
root.title("Обробка кліку")

canvas = tk.Canvas(root, width=300, height=200, bg="lightgray")
canvas.pack()
canvas.bind("<Button-1>", on_click)

label = tk.Label(root, text="")
label.pack()

root.mainloop() 
        </code></pre>
        <h3>4. Створення меню</h3>
        <pre><code>
import tkinter as tk

def show_about():
    label.config(text="Це просте GUI-застосування")

root = tk.Tk()
root.title("Меню")

menubar = tk.Menu(root)
root.config(menu=menubar)

file_menu = tk.Menu(menubar, tearoff=0)
file_menu.add_command(label="Вихід", command=root.quit)
menubar.add_cascade(label="Файл", menu=file_menu)

help_menu = tk.Menu(menubar, tearoff=0)
help_menu.add_command(label="Про програму", command=show_about)
menubar.add_cascade(label="Допомога", menu=help_menu)

label = tk.Label(root, text="Головне вікно")
label.pack(pady=20)

root.mainloop() 
        </code></pre>
        <h3>5. Слайдер для вибору значення</h3>
        <pre><code>
import tkinter as tk

def update_label(value):
    label.config(text=f"Обране значення: {value}")

root = tk.Tk()
root.title("Слайдер")

slider = tk.Scale(root, from_=0, to=100, orient="horizontal", command=update_label)
slider.pack()

label = tk.Label(root, text="Обране значення: 0")
label.pack()

root.mainloop() 
        </code></pre>
    </article>

    <h2>Графічні інтерфейси користувача (GUI): PyQt / PySide</h2>
    <article>
        <h3>1. Просте вікно з кнопкою</h3>
        <pre><code>
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QLabel, QVBoxLayout
import sys

def on_click():
    label.setText("Привіт, Користувач!")

app = QApplication(sys.argv)
window = QWidget()
window.setWindowTitle("Простий інтерфейс")

label = QLabel("Натисни кнопку")
button = QPushButton("Натисни")
button.clicked.connect(on_click)

layout = QVBoxLayout()
layout.addWidget(label)
layout.addWidget(button)
window.setLayout(layout)

window.show()
sys.exit(app.exec_())
        </code></pre>
        <h3>2. Ввід тексту (QLineEdit)</h3>
        <pre><code>
from PyQt5.QtWidgets import QApplication, QWidget, QLineEdit, QLabel, QPushButton, QVBoxLayout
import sys

def on_click():
    user_text = input_field.text()
    label.setText(f"Ви ввели: {user_text}")

app = QApplication(sys.argv)
window = QWidget()
window.setWindowTitle("Ввід тексту")

input_field = QLineEdit()
label = QLabel("")
button = QPushButton("Показати текст")
button.clicked.connect(on_click)

layout = QVBoxLayout()
layout.addWidget(input_field)
layout.addWidget(button)
layout.addWidget(label)
window.setLayout(layout)

window.show()
sys.exit(app.exec_())
        </code></pre>
        <h3>3. Завантаження зображення</h3>
        <pre><code>
from PyQt5.QtWidgets import QApplication, QLabel, QWidget, QVBoxLayout
from PyQt5.QtGui import QPixmap
import sys

app = QApplication(sys.argv)
window = QWidget()
window.setWindowTitle("Зображення")

label = QLabel()
pixmap = QPixmap(r"E:\NewFolder\image.jpg")
label.setPixmap(pixmap)

layout = QVBoxLayout()
layout.addWidget(label)
window.setLayout(layout)

window.show()
sys.exit(app.exec_())
        </code></pre>
        <h3>4. Повідомлення (Message Box)</h3>
        <pre><code>
from PyQt5.QtWidgets import QApplication, QMessageBox, QWidget, QPushButton, QVBoxLayout
import sys

def show_message():
    QMessageBox.information(window, "Привіт", "Це повідомлення для користувача")

app = QApplication(sys.argv)
window = QWidget()
window.setWindowTitle("Повідомлення")

button = QPushButton("Показати повідомлення")
button.clicked.connect(show_message)

layout = QVBoxLayout()
layout.addWidget(button)
window.setLayout(layout)

window.show()
sys.exit(app.exec_())
        </code></pre>
        <h3>5. Слайдер (QSlider)</h3>
        <pre><code>
from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QSlider, QVBoxLayout
from PyQt5.QtCore import Qt
import sys

def update_value(value):
    label.setText(f"Значення: {value}")

app = QApplication(sys.argv)
window = QWidget()
window.setWindowTitle("Слайдер")

slider = QSlider(Qt.Horizontal)
slider.setMinimum(0)
slider.setMaximum(100)
slider.valueChanged.connect(update_value)

label = QLabel("Значення: 0")

layout = QVBoxLayout()
layout.addWidget(slider)
layout.addWidget(label)
window.setLayout(layout)

window.show()
sys.exit(app.exec_())
        </code></pre>
    </article>

    <h2>Графічні інтерфейси користувача (GUI): Kivy</h2>
    <article>
        <h3>1. Кнопка + Лейбл + лічильник</h3>
        <pre><code>
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label

class MyApp(App):
    def build(self):
        self.counter = 0
        layout = BoxLayout(orientation='vertical')
        self.label = Label(text="Натискань: 0")
        btn = Button(text="Додати")

        btn.bind(on_press=self.on_press)
        layout.add_widget(self.label)
        layout.add_widget(btn)
        return layout

    def on_press(self, instance):
        self.counter += 1
        self.label.text = f"Натискань: {self.counter}"

MyApp().run()
        </code></pre>
        <h3>2. Перемикачі (Radio Button / ToggleButton)</h3>
        <pre><code>
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.togglebutton import ToggleButton
from kivy.uix.label import Label

class MyApp(App):
    def build(self):
        layout = BoxLayout(orientation='vertical')
        self.label = Label(text="Оберіть колір:")
        layout.add_widget(self.label)

        for color in ['Red', 'Green', 'Blue']:
            btn = ToggleButton(text=color, group='color')
            btn.bind(on_press=self.on_toggle)
            layout.add_widget(btn)

        return layout

    def on_toggle(self, instance):
        self.label.text = f"Обрано: {instance.text}"

MyApp().run()
        </code></pre>
        <h3>3. Чекбокси</h3>
        <pre><code>
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.checkbox import CheckBox
from kivy.uix.label import Label

class MyApp(App):
    def build(self):
        layout = BoxLayout(orientation='horizontal', spacing=10)
        self.label = Label(text="Вибрано: Ні")

        self.checkbox = CheckBox()
        self.checkbox.bind(active=self.on_checkbox_active)

        layout.add_widget(self.checkbox)
        layout.add_widget(self.label)
        return layout

    def on_checkbox_active(self, checkbox, value):
        self.label.text = "Вибрано: Так" if value else "Вибрано: Ні"

MyApp().run()
        </code></pre>
        <h3>4. Слайдер (Slider)</h3>
        <pre><code>
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.slider import Slider
from kivy.uix.label import Label

class MyApp(App):
    def build(self):
        layout = BoxLayout(orientation='vertical')
        self.label = Label(text="Значення: 0")
        slider = Slider(min=0, max=100, value=0)
        slider.bind(value=self.on_value_change)

        layout.add_widget(self.label)
        layout.add_widget(slider)
        return layout

    def on_value_change(self, instance, value):
        self.label.text = f"Значення: {int(value)}"

MyApp().run()
        </code></pre>
        <h3>5. Вивід спливаючого повідомлення (Popup)</h3>
        <pre><code>
from kivy.app import App
from kivy.uix.popup import Popup
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.boxlayout import BoxLayout

class MyApp(App):
    def build(self):
        layout = BoxLayout()
        btn = Button(text="Показати повідомлення")
        btn.bind(on_press=self.show_popup)
        layout.add_widget(btn)
        return layout

    def show_popup(self, instance):
        popup = Popup(title="Важливо!",
                      content=Label(text="Це спливаюче вікно"),
                      size_hint=(None, None), size=(300, 200))
        popup.open()

MyApp().run()
        </code></pre>
    </article>

    <h2>Графічні інтерфейси користувача (GUI): wxPython</h2>
    <article>
        <h3>1. Вікно з кількома кнопками</h3>
        <pre><code>
import wx

class CounterApp(wx.Frame):
    def __init__(self):
        super().__init__(None, title="Лічильник", size=(300, 200))
        panel = wx.Panel(self)

        self.count = 0

        self.label = wx.StaticText(panel, label="Значення: 0", pos=(30, 30))
        inc_btn = wx.Button(panel, label="Збільшити", pos=(30, 60))
        dec_btn = wx.Button(panel, label="Зменшити", pos=(150, 60))

        inc_btn.Bind(wx.EVT_BUTTON, self.increment)
        dec_btn.Bind(wx.EVT_BUTTON, self.decrement)

    def increment(self, event):
        self.count += 1
        self.label.SetLabel(f"Значення: {self.count}")

    def decrement(self, event):
        self.count -= 1
        self.label.SetLabel(f"Значення: {self.count}")

app = wx.App(False)
frame = CounterApp()
frame.Show()
app.MainLoop()
        </code></pre>
        <h3>2. Програма з вкладками (Notebook)</h3>
        <pre><code>
import wx

class TabApp(wx.Frame):
    def __init__(self):
        super().__init__(None, title="Вкладки", size=(400, 300))
        notebook = wx.Notebook(self)

        panel1 = wx.Panel(notebook)
        wx.StaticText(panel1, label="Вміст першої вкладки", pos=(20, 20))

        panel2 = wx.Panel(notebook)
        wx.StaticText(panel2, label="Вміст другої вкладки", pos=(20, 20))

        notebook.AddPage(panel1, "Вкладка 1")
        notebook.AddPage(panel2, "Вкладка 2")

app = wx.App(False)
frame = TabApp()
frame.Show()
app.MainLoop()
        </code></pre>
        <h3>3. Завантаження зображення та його показ</h3>
        <pre><code>
import wx

class ImageViewer(wx.Frame):
    def __init__(self):
        super().__init__(None, title="Перегляд зображення", size=(500, 400))
        panel = wx.Panel(self)
        self.bitmap = wx.StaticBitmap(panel)

        btn = wx.Button(panel, label="Вибрати зображення", pos=(20, 20))
        btn.Bind(wx.EVT_BUTTON, self.on_open)

        self.sizer = wx.BoxSizer(wx.VERTICAL)
        self.sizer.Add(btn, 0, wx.ALL, 5)
        self.sizer.Add(self.bitmap, 1, wx.EXPAND | wx.ALL, 5)
        panel.SetSizer(self.sizer)

    def on_open(self, event):
        with wx.FileDialog(self, "Вибрати зображення", wildcard="*.jpg;*.png;*.bmp",
                           style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST) as dialog:
            if dialog.ShowModal() == wx.ID_CANCEL:
                return
            path = dialog.GetPath()
            img = wx.Image(path, wx.BITMAP_TYPE_ANY).Scale(400, 300)
            self.bitmap.SetBitmap(wx.Bitmap(img))
            self.Layout()

app = wx.App(False)
frame = ImageViewer()
frame.Show()
app.MainLoop()
        </code></pre>
        <h3>4. Ввід, обробка тексту і збереження у файл</h3>
        <pre><code>
import wx

class TextEditor(wx.Frame):
    def __init__(self):
        super().__init__(None, title="Текстовий редактор", size=(500, 400))
        panel = wx.Panel(self)

        self.text_ctrl = wx.TextCtrl(panel, style=wx.TE_MULTILINE)
        save_btn = wx.Button(panel, label="Зберегти текст")

        save_btn.Bind(wx.EVT_BUTTON, self.on_save)

        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.text_ctrl, 1, wx.EXPAND | wx.ALL, 5)
        sizer.Add(save_btn, 0, wx.ALIGN_CENTER | wx.ALL, 5)

        panel.SetSizer(sizer)

    def on_save(self, event):
        with wx.FileDialog(self, "Зберегти файл", wildcard="Текст (*.txt)|*.txt",
                           style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as dialog:
            if dialog.ShowModal() == wx.ID_CANCEL:
                return
            path = dialog.GetPath()
            with open(path, 'w', encoding='utf-8') as file:
                file.write(self.text_ctrl.GetValue())

app = wx.App(False)
frame = TextEditor()
frame.Show()
app.MainLoop()
        </code></pre>
        <h3>5. Програма з Progress Bar</h3>
        <pre><code>
import wx
import time
import threading

class ProgressBarFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title="Прогрес", size=(400, 150))
        panel = wx.Panel(self)

        self.gauge = wx.Gauge(panel, range=100, size=(300, 25), pos=(50, 30))
        self.button = wx.Button(panel, label="Старт", pos=(150, 70))
        self.button.Bind(wx.EVT_BUTTON, self.on_start)

    def on_start(self, event):
        self.button.Disable()
        threading.Thread(target=self.run_progress).start()

    def run_progress(self):
        for i in range(101):
            wx.CallAfter(self.gauge.SetValue, i)
            time.sleep(0.05)
        wx.CallAfter(self.button.Enable)

app = wx.App(False)
frame = ProgressBarFrame()
frame.Show()
app.MainLoop()
        </code></pre>
    </article>

    <h2>Графічні інтерфейси користувача (GUI): PyGTK</h2>
    <article>
        <h3>1. Зображення + кнопка для його заміни</h3>
        <pre><code>
import gi
gi.require_version("Gtk", "3.0")
from gi.repository import Gtk

class ImageApp(Gtk.Window):
    def __init__(self):
        super().__init__(title="Зображення у GTK")
        self.set_default_size(400, 300)

        self.box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.add(self.box)

        self.image_path_1 = r"E:\NewFolder\image.jpg"
        self.image_path_2 = r"E:\NewFolder\new image.jpg"

        self.image = Gtk.Image.new_from_file(self.image_path_1)
        self.box.pack_start(self.image, True, True, 0)

        self.button = Gtk.Button(label="Змінити зображення")
        self.button.connect("clicked", self.change_image)
        self.box.pack_start(self.button, False, False, 0)

    def change_image(self, widget):
        self.image.set_from_file(self.image_path_2)

win = ImageApp()
win.connect("destroy", Gtk.main_quit)
win.show_all()
Gtk.main()
        </code></pre>
        <h3>2. Таблиця зі списком (TreeView)</h3>
        <pre><code>
import gi
gi.require_version("Gtk", "3.0")
from gi.repository import Gtk

class TreeViewExample(Gtk.Window):
    def __init__(self):
        super().__init__(title="Список студентів")
        self.set_default_size(300, 200)

        self.store = Gtk.ListStore(str, int)
        self.store.append(["Денис", 21])
        self.store.append(["Олена", 19])
        self.store.append(["Ігор", 22])

        self.view = Gtk.TreeView(model=self.store)

        for i, column_title in enumerate(["Ім'я", "Вік"]):
            renderer = Gtk.CellRendererText()
            column = Gtk.TreeViewColumn(column_title, renderer, text=i)
            self.view.append_column(column)

        scroll = Gtk.ScrolledWindow()
        scroll.add(self.view)
        self.add(scroll)

win = TreeViewExample()
win.connect("destroy", Gtk.main_quit)
win.show_all()
Gtk.main()
        </code></pre>
        <h3>3. Вибір файлу та відображення імені</h3>
        <pre><code>
import gi
gi.require_version("Gtk", "3.0")
from gi.repository import Gtk

class FileChooserExample(Gtk.Window):
    def __init__(self):
        super().__init__(title="Вибір файлу")

        self.set_default_size(400, 100)
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.add(box)

        self.label = Gtk.Label(label="Файл ще не вибрано")
        box.pack_start(self.label, True, True, 0)

        button = Gtk.Button(label="Вибрати файл")
        button.connect("clicked", self.open_dialog)
        box.pack_start(button, False, False, 0)

    def open_dialog(self, widget):
        dialog = Gtk.FileChooserDialog(
            title="Оберіть файл",
            parent=self,
            action=Gtk.FileChooserAction.OPEN,
        )
        dialog.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
                           Gtk.STOCK_OPEN, Gtk.ResponseType.OK)

        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            filename = dialog.get_filename()
            self.label.set_text(f"Обраний файл: {filename}")

        dialog.destroy()

win = FileChooserExample()
win.connect("destroy", Gtk.main_quit)
win.show_all()
Gtk.main()
        </code></pre>
        <h3>4. Перемикачі (ToggleButton) + логіка</h3>
        <pre><code>
import gi
gi.require_version("Gtk", "3.0")
from gi.repository import Gtk

class ToggleButtonExample(Gtk.Window):
    def __init__(self):
        super().__init__(title="Перемикачі")
        self.set_default_size(300, 150)

        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.add(box)

        self.toggle1 = Gtk.ToggleButton(label="Опція 1")
        self.toggle1.connect("toggled", self.on_toggled)
        box.pack_start(self.toggle1, True, True, 0)

        self.toggle2 = Gtk.ToggleButton(label="Опція 2")
        self.toggle2.connect("toggled", self.on_toggled)
        box.pack_start(self.toggle2, True, True, 0)

        self.label = Gtk.Label(label="Статус: ---")
        box.pack_start(self.label, True, True, 0)

    def on_toggled(self, button):
        states = []
        if self.toggle1.get_active():
            states.append("Опція 1")
        if self.toggle2.get_active():
            states.append("Опція 2")
        self.label.set_text(f"Статус: {', '.join(states) or '---'}")

win = ToggleButtonExample()
win.connect("destroy", Gtk.main_quit)
win.show_all()
Gtk.main()
        </code></pre>
        <h3>5. Вікно з прогрес-баром (імітація процесу)</h3>
        <pre><code>
import gi
import time
gi.require_version("Gtk", "3.0")
from gi.repository import Gtk, GLib

class ProgressBarExample(Gtk.Window):
    def __init__(self):
        super().__init__(title="Прогрес бар")
        self.set_default_size(300, 100)

        self.progressbar = Gtk.ProgressBar()
        self.add(self.progressbar)

        GLib.timeout_add(100, self.on_timeout)

    def on_timeout(self):
        new_val = self.progressbar.get_fraction() + 0.01
        if new_val > 1.0:
            new_val = 0.0
        self.progressbar.set_fraction(new_val)
        self.progressbar.set_text(f"{int(new_val * 100)}%")
        return True  # щоб не зупиняти таймер

win = ProgressBarExample()
win.connect("destroy", Gtk.main_quit)
win.show_all()
Gtk.main()
        </code></pre>
    </article>

    <h2>Наукова візуалізація: Matplotlib</h2>
    <article>
        <h3>1. Кілька функцій на одному графіку</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(0, 2*np.pi, 200)
y1 = np.sin(x)
y2 = np.cos(x)
y3 = np.sin(2*x)

plt.figure(figsize=(10, 5))
plt.plot(x, y1, label='sin(x)', linewidth=2)
plt.plot(x, y2, label='cos(x)', linewidth=2)
plt.plot(x, y3, label='sin(2x)', linestyle='--', linewidth=2)
plt.title('Графіки тригонометричних функцій')
plt.xlabel('x')
plt.ylabel('Значення')
plt.legend()
plt.grid(True)
plt.show()
        </code></pre>
        <h3>2. Гістограма з нормальним розподілом</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

data = np.random.normal(loc=0, scale=1, size=1000)

plt.figure(figsize=(8, 5))
plt.hist(data, bins=30, density=True, color='skyblue', edgecolor='black')
plt.title('Гістограма нормального розподілу')
plt.xlabel('Значення')
plt.ylabel('Щільність ймовірності')
plt.grid(True)
plt.show()
        </code></pre>
        <h3>3. Теплова карта (heatmap)</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

data = np.random.rand(10, 10)

plt.figure(figsize=(6, 5))
plt.imshow(data, cmap='viridis', interpolation='nearest')
plt.colorbar(label="Інтенсивність")
plt.title('Теплова карта')
plt.show()
        </code></pre>
        <h3>4. 3D-поверхня</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(figsize=(10, 6))
ax = fig.add_subplot(111, projection='3d')

X = np.linspace(-5, 5, 50)
Y = np.linspace(-5, 5, 50)
X, Y = np.meshgrid(X, Y)
Z = np.sin(np.sqrt(X**2 + Y**2))

surf = ax.plot_surface(X, Y, Z, cmap='plasma')
fig.colorbar(surf, ax=ax, shrink=0.5, aspect=10)
ax.set_title('3D поверхня: sin(√(x² + y²))')
plt.show()
        </code></pre>
        <h3>5. Векторне поле (Quiver plot)</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(-2, 2, 20)
y = np.linspace(-2, 2, 20)
X, Y = np.meshgrid(x, y)
U = -Y
V = X

plt.figure(figsize=(6, 6))
plt.quiver(X, Y, U, V)
plt.title('Векторне поле: обертання')
plt.xlabel('X')
plt.ylabel('Y')
plt.grid(True)
plt.axis('equal')
plt.show()
        </code></pre>
    </article>

    <h2>Наукова візуалізація: Mayavi</h2>
    <article>
        <h3>1. 3D-поверхня (mesh surface)</h3>
        <pre><code>
from mayavi import mlab
import numpy as np

x, y = np.mgrid[-3:3:100j, -3:3:100j]
z = np.sin(x**2 + y**2)

mlab.surf(x, y, z, colormap='Spectral')
mlab.title("3D-surface: sin(x² + y²)")
mlab.show()
        </code></pre>
        <h3>2. Об'ємна візуалізація (volume rendering)</h3>
        <pre><code>
from mayavi import mlab
import numpy as np

x, y, z = np.ogrid[-10:10:100j, -10:10:100j, -10:10:100j]
data = np.sin(x*y*z) / (x*y*z + 1e-9)

src = mlab.pipeline.scalar_field(data)
mlab.pipeline.volume(src)
mlab.title("Volumetric visualization")
mlab.show()
        </code></pre>
        <h3>3. Векторне поле (візуалізація потоків)</h3>
        <pre><code>
from mayavi import mlab
import numpy as np

x, y, z = np.mgrid[-2:2:20j, -2:2:20j, -2:2:20j]
u = -y
v = x
w = np.zeros_like(z)

mlab.quiver3d(x, y, z, u, v, w, scale_factor=0.5)
mlab.title("Vector field")
mlab.show()
        </code></pre>
        <h3>4. Contour3D (ізолінії в 3D)</h3>
        <pre><code>
from mayavi import mlab
import numpy as np

x, y, z = np.ogrid[-3:3:60j, -3:3:60j, -3:3:60j]
scalars = np.sin(x*y*z)

mlab.contour3d(scalars, contours=8, opacity=0.5)
mlab.title("Contour3D: sin(x*y*z)")
mlab.show()
        </code></pre>
        <h3>5. Parametric 3D-спіраль</h3>
        <pre><code>
from mayavi import mlab
import numpy as np

t = np.linspace(0, 4 * np.pi, 1000)
x = np.sin(t)
y = np.cos(t)
z = t

mlab.plot3d(x, y, z, t, tube_radius=0.05, colormap='Accent')
mlab.title("3D-spiral")
mlab.show()
        </code></pre>
    </article>

    <h2>Наукова візуалізація: SciPy Visualization</h2>
    <article>
        <h3>1. Візуалізація рішення диференціального рівняння (ODE)</h3>
        <pre><code>
import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

def dydt(t, y):
    return -2 * y + np.sin(t)

sol = solve_ivp(dydt, [0, 10], [1.0], t_eval=np.linspace(0, 10, 200))

plt.plot(sol.t, sol.y[0], label="dy/dt = -2y + sin(t)")
plt.xlabel("Час")
plt.ylabel("y(t)")
plt.title("Розв'язок ODE")
plt.grid()
plt.legend()
plt.show()
        </code></pre>
        <h3>2. 2D-фур'є-аналіз зображення + спектр</h3>
        <pre><code>
import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft2, fftshift
from scipy.misc import face

img = face(gray=True)[::4, ::4]

fft_image = fftshift(fft2(img))
magnitude = np.log(np.abs(fft_image) + 1)

plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.imshow(img, cmap='gray')
plt.title("Оригінальне зображення")

plt.subplot(1, 2, 2)
plt.imshow(magnitude, cmap='inferno')
plt.title("Спектр (FFT)")
plt.colorbar()
plt.show()
        </code></pre>
        <h3>3. Інтерполяція функції методом кубічних сплайнів</h3>
        <pre><code>
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import CubicSpline

x = np.linspace(0, 10, 10)
y = np.sin(x)

cs = CubicSpline(x, y)
x_fine = np.linspace(0, 10, 500)
y_fine = cs(x_fine)

plt.plot(x, y, 'o', label='Вузли')
plt.plot(x_fine, y_fine, label='Кубічний сплайн')
plt.legend()
plt.title("Інтерполяція функції")
plt.grid()
plt.show()
        </code></pre>
        <h3>4. 3D-візуалізація функції (SciPy + matplotlib)</h3>
        <pre><code>
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

x = y = np.linspace(-3, 3, 100)
X, Y = np.meshgrid(x, y)
Z = np.sin(np.sqrt(X**2 + Y**2))

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
surf = ax.plot_surface(X, Y, Z, cmap='viridis')
fig.colorbar(surf)
ax.set_title("3D-графік функції: sin(sqrt(x² + y²))")
plt.show()
        </code></pre>
        <h3>5. Карта рівнів потенціалу (рішення рівняння Лапласа)</h3>
        <pre><code>
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import laplace

N = 100
V = np.zeros((N, N))
V[25:75, 25] = 1
V[25:75, 75] = -1

for _ in range(500):
    V[1:-1, 1:-1] = 0.25 * (V[:-2, 1:-1] + V[2:, 1:-1] +
                             V[1:-1, :-2] + V[1:-1, 2:])
    V[25:75, 25] = 1
    V[25:75, 75] = -1

plt.imshow(V, cmap='coolwarm')
plt.colorbar(label="Потенціал")
plt.title("Карта потенціалу (Лаплас)")
plt.show()
        </code></pre>
    </article>

    <h2>Наукова візуалізація: Cartopy</h2>
    <article>
        <h3>1. Глобальна карта з різними проекціями</h3>
        <pre><code>
import matplotlib.pyplot as plt
import cartopy.crs as ccrs

projections = [ccrs.PlateCarree(), ccrs.Mollweide(), ccrs.Orthographic(0, 0)]

for i, proj in enumerate(projections):
    fig = plt.figure(figsize=(6, 4))
    ax = plt.axes(projection=proj)
    ax.set_global()
    ax.coastlines()
    ax.gridlines(draw_labels=True)
    ax.set_title(f"Проекція: {proj.__class__.__name__}", fontsize=12)
    plt.savefig(f"map_projection_{i}.png")
    plt.close()
        </code></pre>
        <h3>2. Відображення траєкторії супутника над Землею</h3>
        <pre><code>
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import numpy as np

lons = np.linspace(-180, 180, 400)
lats = 20 * np.sin(np.radians(lons))

fig = plt.figure(figsize=(10, 5))
ax = plt.axes(projection=ccrs.PlateCarree())
ax.set_global()
ax.coastlines()
ax.gridlines(draw_labels=True)
ax.plot(lons, lats, 'r', transform=ccrs.Geodetic(), label='Супутник')
ax.set_title("Траєкторія супутника")
ax.legend()
plt.savefig("satellite_path.png")
plt.close()
        </code></pre>
        <h3>3. Теплова карта температур на світовій мапі</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np
import cartopy.crs as ccrs

lons = np.linspace(-180, 180, 100)
lats = np.linspace(-90, 90, 50)
lon2d, lat2d = np.meshgrid(lons, lats)
temps = 30 * np.cos(np.radians(lat2d))  # умовна температура

fig = plt.figure(figsize=(12, 6))
ax = plt.axes(projection=ccrs.PlateCarree())
cf = ax.contourf(lons, lats, temps, 60, transform=ccrs.PlateCarree(), cmap='coolwarm')
ax.coastlines()
ax.set_title("Глобальне розподілення температури")
plt.colorbar(cf, ax=ax, orientation='horizontal')
plt.savefig("temperature_map.png")
plt.close()
        </code></pre>
        <h3>4. Потік вітру: векторне поле на карті</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np
import cartopy.crs as ccrs

lons = np.linspace(-180, 180, 20)
lats = np.linspace(-90, 90, 10)
lon2d, lat2d = np.meshgrid(lons, lats)

u = np.cos(np.radians(lat2d))  # умовна складова вітру
v = np.sin(np.radians(lon2d))

fig = plt.figure(figsize=(12, 6))
ax = plt.axes(projection=ccrs.PlateCarree())
ax.quiver(lons, lats, u, v, transform=ccrs.PlateCarree(), color='blue')
ax.coastlines()
ax.set_title("Векторне поле вітру")
plt.savefig("wind_field.png")
plt.close()
        </code></pre>
        <h3>5. Виділення окремої країни</h3>
        <pre><code>
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature

fig = plt.figure(figsize=(10, 6))
ax = plt.axes(projection=ccrs.PlateCarree())
ax.set_extent([22, 41, 43, 53], crs=ccrs.PlateCarree())  # межі України

ax.coastlines(resolution='10m')
ax.add_feature(cfeature.BORDERS, linestyle=':')
ax.add_feature(cfeature.LAND, edgecolor='black')
ax.add_feature(cfeature.OCEAN)
ax.gridlines(draw_labels=True)

ax.set_title("Карта України")
plt.savefig("ukraine_map.png")
plt.close()
        </code></pre>
    </article>

    <h2>Графіка для ігор: Pygame</h2>
    <article>
        <h3>1. 2D платформер з гравітацією, анімацією та колізією</h3>
        <pre><code>
import pygame
import os

pygame.init()

WIDTH, HEIGHT = 800, 600
win = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("2D Платформер")

clock = pygame.time.Clock()
GRAVITY = 0.5
FPS = 60

player = pygame.Rect(100, 500, 50, 50)
player_vel_y = 0
on_ground = False

platforms = [pygame.Rect(0, 580, 800, 20), pygame.Rect(300, 450, 200, 20), pygame.Rect(600, 350, 150, 20)]

def draw():
    win.fill((30, 30, 30))
    pygame.draw.rect(win, (0, 255, 0), player)
    for plat in platforms:
        pygame.draw.rect(win, (255, 255, 255), plat)
    pygame.display.update()

run = True
while run:
    clock.tick(FPS)
    keys = pygame.key.get_pressed()
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False

    if keys[pygame.K_LEFT]:
        player.x -= 5
    if keys[pygame.K_RIGHT]:
        player.x += 5

    if keys[pygame.K_SPACE] and on_ground:
        player_vel_y = -10
        on_ground = False

    player_vel_y += GRAVITY
    player.y += player_vel_y

    on_ground = False
    for plat in platforms:
        if player.colliderect(plat) and player_vel_y >= 0:
            player.y = plat.y - player.height
            player_vel_y = 0
            on_ground = True

    draw()

pygame.quit()
        </code></pre>
        <h3>2. Гравець і AI переслідувач</h3>
        <pre><code>
import pygame
import math

pygame.init()
win = pygame.display.set_mode((600, 400))
clock = pygame.time.Clock()

player = pygame.Rect(100, 100, 30, 30)
enemy = pygame.Rect(400, 300, 30, 30)
speed = 3

def move_enemy(enemy, player):
    dx, dy = player.x - enemy.x, player.y - enemy.y
    dist = math.hypot(dx, dy)
    if dist > 0:
        dx, dy = dx / dist, dy / dist
        enemy.x += dx * 2
        enemy.y += dy * 2

running = True
while running:
    win.fill((30, 30, 30))
    keys = pygame.key.get_pressed()
    for e in pygame.event.get():
        if e.type == pygame.QUIT:
            running = False

    if keys[pygame.K_LEFT]: player.x -= speed
    if keys[pygame.K_RIGHT]: player.x += speed
    if keys[pygame.K_UP]: player.y -= speed
    if keys[pygame.K_DOWN]: player.y += speed

    move_enemy(enemy, player)

    pygame.draw.rect(win, (0, 255, 0), player)
    pygame.draw.rect(win, (255, 0, 0), enemy)
    pygame.display.flip()
    clock.tick(60)
pygame.quit()
        </code></pre>
        <h3>3. Гра-музикальна реакція – Блок стрибає по нотах</h3>
        <pre><code>
import pygame
import random
import os

pygame.init()
pygame.mixer.init()
screen = pygame.display.set_mode((400, 400))
clock = pygame.time.Clock()

os.chdir(r"E:\NewFolder")

jump_sounds = [
    pygame.mixer.Sound("jump1.wav"),
    pygame.mixer.Sound("jump2.wav"),
    pygame.mixer.Sound("jump3.wav")
]

player = pygame.Rect(180, 300, 40, 40)
velocity = 0
gravity = 0.5
jump_power = -10
on_ground = True

def play_jump():
    sound = random.choice(jump_sounds)
    sound.play()

running = True
while running:
    screen.fill((20, 20, 20))
    for e in pygame.event.get():
        if e.type == pygame.QUIT:
            running = False
    keys = pygame.key.get_pressed()
    if keys[pygame.K_SPACE] and on_ground:
        velocity = jump_power
        on_ground = False
        play_jump()

    velocity += gravity
    player.y += int(velocity)

    if player.y >= 300:
        player.y = 300
        velocity = 0
        on_ground = True

    pygame.draw.rect(screen, (200, 200, 0), player)
    pygame.display.flip()
    clock.tick(60)

pygame.quit()
        </code></pre>
    </article>

    <h2>Графіка для ігор: Pyglet</h2>
    <article>
        <h3>1. Pyglet + OpenGL: 3D-сцена з керуванням камерою</h3>
        <pre><code>
import pyglet
from pyglet.window import key, mouse
from OpenGL.GL import *
from OpenGL.GLU import *
import math
import numpy as np

config = pyglet.gl.Config(double_buffer=True, depth_size=24)
window = pyglet.window.Window(width=800, height=600,
                              caption='FPS 3D Scene',
                              resizable=True,
                              config=config)
window.set_exclusive_mouse(True)

camera_pos = np.array([0.0, 1.8, 5.0])
yaw, pitch = 0.0, 0.0
mouse_sensitivity = 0.15
movement_speed = 5.0
keys_held = set()

scene_objects = []
object_colors = {}


def create_cube(x, y, z, size=1):
    half = size / 2
    vertices = [
        (x - half, y - half, z - half), (x + half, y - half, z - half),
        (x + half, y + half, z - half), (x - half, y + half, z - half),
        (x - half, y - half, z + half), (x + half, y - half, z + half),
        (x + half, y + half, z + half), (x - half, y + half, z + half),
    ]
    return vertices


def draw_cube(vertices, color=(0.7, 0.7, 0.7)):
    glBegin(GL_QUADS)
    glColor3f(*color)

    glVertex3f(*vertices[4])
    glVertex3f(*vertices[5])
    glVertex3f(*vertices[6])
    glVertex3f(*vertices[7])

    glVertex3f(*vertices[1])
    glVertex3f(*vertices[0])
    glVertex3f(*vertices[3])
    glVertex3f(*vertices[2])

    glVertex3f(*vertices[0])
    glVertex3f(*vertices[4])
    glVertex3f(*vertices[7])
    glVertex3f(*vertices[3])

    glVertex3f(*vertices[5])
    glVertex3f(*vertices[1])
    glVertex3f(*vertices[2])
    glVertex3f(*vertices[6])

    glVertex3f(*vertices[3])
    glVertex3f(*vertices[7])
    glVertex3f(*vertices[6])
    glVertex3f(*vertices[2])

    glVertex3f(*vertices[0])
    glVertex3f(*vertices[1])
    glVertex3f(*vertices[5])
    glVertex3f(*vertices[4])

    glEnd()


for i in range(-5, 6):
    for j in range(-5, 6):
        cube = create_cube(i, -0.5, j)
        scene_objects.append(cube)
        object_colors[id(cube)] = (0.7, 0.7, 0.7)

column_positions = [(2, 0, 2), (-2, 0, 2), (2, 0, -2), (-2, 0, -2)]
for x, y, z in column_positions:
    for height in range(3):
        cube = create_cube(x, y + height, z)
        scene_objects.append(cube)
        object_colors[id(cube)] = (0.2, 0.4, 1.0)


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(45, window.width / window.height, 0.1, 100.0)

    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()

    dir_x = math.cos(math.radians(pitch)) * math.sin(math.radians(yaw))
    dir_y = math.sin(math.radians(pitch))
    dir_z = -math.cos(math.radians(pitch)) * math.cos(math.radians(yaw))
    center = camera_pos + np.array([dir_x, dir_y, dir_z])

    gluLookAt(
        *camera_pos,
        *center,
        0.0, 1.0, 0.0
    )

    for obj in scene_objects:
        draw_cube(obj, object_colors.get(id(obj), (1.0, 1.0, 1.0)))


@window.event
def on_resize(width, height):
    glViewport(0, 0, width, height)
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(45, width / height, 0.1, 100.0)
    glMatrixMode(GL_MODELVIEW)
    return pyglet.event.EVENT_HANDLED


@window.event
def on_mouse_motion(x, y, dx, dy):
    global yaw, pitch
    yaw += dx * mouse_sensitivity
    pitch += dy * mouse_sensitivity
    pitch = max(-89.0, min(89.0, pitch))


@window.event
def on_key_press(symbol, modifiers):
    keys_held.add(symbol)
    if symbol == key.ESCAPE:
        pyglet.app.exit()


@window.event
def on_key_release(symbol, modifiers):
    if symbol in keys_held:
        keys_held.remove(symbol)


def check_collision(new_pos):
    for obj in scene_objects:
        cube_center = np.array([(obj[0][0] + obj[1][0]) / 2,
                                (obj[0][1] + obj[3][1]) / 2,
                                (obj[0][2] + obj[4][2]) / 2])
        cube_size = 1.0

        dist = np.linalg.norm(new_pos - cube_center)

        if dist < 1.2:
            return True
    return False


def update(dt):
    global camera_pos

    front = np.array([
        math.cos(math.radians(pitch)) * math.sin(math.radians(yaw)),
        0.0,
        -math.cos(math.radians(pitch)) * math.cos(math.radians(yaw))
    ])
    front /= np.linalg.norm(front)

    right = np.cross(front, np.array([0.0, 1.0, 0.0]))
    right /= np.linalg.norm(right)

    velocity = movement_speed * dt

    if key.W in keys_held:
        new_pos = camera_pos + front * velocity
        if not check_collision(new_pos):
            camera_pos = new_pos

    if key.S in keys_held:
        new_pos = camera_pos - front * velocity
        if not check_collision(new_pos):
            camera_pos = new_pos

    if key.A in keys_held:
        new_pos = camera_pos - right * velocity
        if not check_collision(new_pos):
            camera_pos = new_pos

    if key.D in keys_held:
        new_pos = camera_pos + right * velocity
        if not check_collision(new_pos):
            camera_pos = new_pos

    if key.SPACE in keys_held:
        camera_pos[1] += velocity
    if key.LSHIFT in keys_held:
        camera_pos[1] -= velocity


glEnable(GL_DEPTH_TEST)
glClearColor(0.1, 0.1, 0.1, 1.0)

pyglet.clock.schedule(update)
pyglet.app.run()
        </code></pre>
        <h3>2. 3D-поверхня (mesh surface)</h3>
        <pre><code>
from mayavi import mlab
        </code></pre>
        <h3>3. 3D-поверхня (mesh surface)</h3>
        <pre><code>
from mayavi import mlab
        </code></pre>
    </article>
</section>


<!-- Контакти -->

    <section id="contact" class="contact">
        <h2>Контакти</h2>
        <p>Автор курсової роботи: <strong>Кульман Денис</strong></p>
        <p>Email: <a href="mailto:your-email@example.com">your-email@example.com</a></p>
        <p>GitHub: <a href="https://github.com/yourprofile" target="_blank">github.com/yourprofile</a></p>
    </section>

    <footer>
        <p>&copy; 2024 Курсовий проєкт Дениса Кульмана</p>
    </footer>
</body>
</html>