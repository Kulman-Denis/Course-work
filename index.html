<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Графічні бібліотеки Python</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }

        header {
            background: #333;
            color: #fff;
            padding: 1rem 0;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            justify-content: center;
        }

        nav ul li {
            margin: 0 15px;
        }

        nav ul li a {
            color: #fff;
            text-decoration: none;
            font-weight: bold;
        }

        nav ul li a:hover {
            color: #f39c12;
        }

        section {
            padding: 2rem;
            margin: 0 auto;
            max-width: 1200px; 
        }

        section h2 {
            text-align: center;
            margin-bottom: 1rem;
            color: #333;
        }

        footer {
            text-align: center;
            padding: 1rem;
            background: #333;
            color: #fff;
        }

        .theory, .examples, .contact {
            background: #eaeaea;
            margin-top: 2rem;
        }
    </style>
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="#theory">Головна</a></li>
                <li><a href="#examples">Приклади</a></li>
                <li><a href="#contact">Контакти</a></li>
            </ul>
        </nav>
    </header>

    <!-- Теорія -->

    <section id="theory" class="theory">
        <h2>Графічні бібліотеки Python</h2>
        <p>Python має багато потужних бібліотек для графіки, поділених на кілька категорій:</p>
        <ul>
            <li><strong>2D Графіки:</strong> Matplotlib, Seaborn, Plotly, Bokeh, ggplot, Altair, Chartify, pygal, Pandas Visualization, Holoviews, mplfinance</li>
            <li><strong>3D Візуалізації:</strong> Plotly (3D), Mayavi, VisPy, VTK, matplotlib.pyplot (3D), PyVista</li>
            <li><strong>Інтерактивна графіка та дашборди:</strong> Dash, Panel, Streamlit, Shiny for Python</li>
            <li><strong>Комп'ютерний зір і обробка зображень:</strong> OpenCV, Pillow (PIL), scikit-image, Imageio, PyTorch Vision, TensorFlow Image</li>
            <li><strong>Графічні інтерфейси користувача (GUI):</strong> Tkinter, PyQt / PySide, Kivy, wxPython, PyGTK</li>
            <li><strong>Наукова візуалізація:</strong> Matplotlib, Mayavi, SciPy Visualization, Cartopy</li>
            <li><strong>Графіка для ігор:</strong> Pygame, Pyglet, Arcade, Cocos2d</li>
            <li><strong>Спеціалізовані бібліотеки:</strong> Manim, Basemap, Cartopy, Folium, Blender Python API</li>
            <li><strong>Анімація:</strong> Manim, Matplotlib.animation, Pillow (GIF-анімація)</li>
            <li><strong>Інші:</strong> Cairo, Aggdraw, SVGwrite, WeasyPrint</li>
        </ul>

        <h1>2D Графік</h1>
            <div class="tool">
                <h2>Matplotlib</h2>
                <p><strong>Призначення:</strong> Основна бібліотека для створення 2D-графіків у Python.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Гнучкість у створенні лінійних графіків, гістограм, діаграм розсіювання, діаграм з областями тощо.</li>
                    <li>Підтримує налаштування кольорів, шрифтів, маркерів, ліній.</li>
                    <li>Включає підмодуль pyplot, який спрощує синтаксис для створення графіків.</li>
                </ul>
                <p><strong>Переваги:</strong> Підходить для статичних графіків. Велика документація і активна спільнота.</p>
                <p><strong>Недоліки:</strong> Графіки менш інтерактивні, порівняно з іншими бібліотеками.</p>
            </div>
            
            <div class="tool">
                <h2>Seaborn</h2>
                <p><strong>Призначення:</strong> Бібліотека для статистичних графіків на основі Matplotlib.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Просте створення графіків, що показують розподіли даних, взаємозв’язки та категоріальні дані.</li>
                    <li>Інтеграція з pandas для роботи з DataFrame.</li>
                    <li>Додаткові графіки: теплові карти, парні графіки, boxplot тощо.</li>
                </ul>
                <p><strong>Переваги:</strong> Гарна естетика графіків за замовчуванням. Зручність у створенні складних статистичних візуалізацій.</p>
                <p><strong>Недоліки:</strong> Менше можливостей кастомізації порівняно з Matplotlib.</p>
            </div>
            
            <div class="tool">
                <h2>Plotly</h2>
                <p><strong>Призначення:</strong> Інтерактивна візуалізація графіків.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Підтримка 2D та 3D-графіків, діаграм, теплових карт, контурних графіків.</li>
                    <li>Можливість інтеграції у веб-додатки.</li>
                    <li>Інтерактивність: масштабування, наведення, виділення даних.</li>
                </ul>
                <p><strong>Переваги:</strong> Висока інтерактивність. Підходить для дашбордів.</p>
                <p><strong>Недоліки:</strong> Більш складна інтеграція з іншими інструментами.</p>
            </div>

            <div class="tool">
                <h2>Bokeh</h2>
                <p><strong>Призначення:</strong> Створення інтерактивних графіків для веб-додатків.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Генерує інтерактивні HTML-елементи.</li>
                    <li>Підтримує великі набори даних.</li>
                    <li>Графіки: лінії, бари, карти, теплові карти.</li>
                </ul>
                <p><strong>Переваги:</strong></p>
                <ul>
                    <li>Легко інтегрується у Flask або Django.</li>
                    <li>Підходить для роботи з великими наборами даних.</li>
                </ul>
                <p><strong>Недоліки:</strong> Менше готових шаблонів, ніж у Plotly.</p>
            </div>

            <div class="tool">
                <h2>ggplot (для Python)</h2>
                <p><strong>Призначення:</strong> Візуалізація у стилі ggplot2 з R.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Векторна графіка з фокусом на статистичні дані.</li>
                    <li>Простий синтаксис.</li>
                    <li>Підтримка граматики графіків.</li>
                </ul>
                <p><strong>Переваги:</strong> Чіткий синтаксис для створення статистичних графіків.</p>
                <p><strong>Недоліки:</strong> Обмежена функціональність порівняно з ggplot2 в R.</p>
            </div>

            <div class="tool">
                <h2>Altair</h2>
                <p><strong>Призначення:</strong> Декларативна бібліотека для інтерактивних графіків.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Простий синтаксис на основі граматики графіків.</li>
                    <li>Підтримка інтерактивності без складних налаштувань.</li>
                </ul>
                <p><strong>Переваги:</strong> Легке інтегрування з pandas, інтерактивні графіки за замовчуванням.</p>
                <p><strong>Недоліки:</strong> Менше підтримки великих наборів даних.</p>
            </div>

            <div class="tool">
                <h2>Chartify</h2>
                <p><strong>Призначення:</strong> Інструмент для швидкого створення графіків.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Інтуїтивно зрозумілий синтаксис.</li>
                    <li>Адаптований для роботи з pandas.</li>
                    <li>Орієнтований на бізнес-аналітиків.</li>
                </ul>
                <p><strong>Переваги:</strong> Легкість використання.</p>
                <p><strong>Недоліки:</strong> Менше можливостей кастомізації.</p>
            </div>

            <div class="tool">
                <h2>pygal</h2>
                <p><strong>Призначення:</strong> Генерація інтерактивної SVG-графіки.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Підтримка SVG для веб-додатків.</li>
                    <li>Вбудована інтерактивність.</li>
                </ul>
                <p><strong>Переваги:</strong> Легка інтеграція у веб, графіки масштабуються без втрати якості.</p>
                <p><strong>Недоліки:</strong> Не підтримує великі набори даних.</p>
            </div>

            <div class="tool">
                <h2>Pandas Visualization</h2>
                <p><strong>Призначення:</strong> Просте створення графіків з DataFrame.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Вбудовані функції для лінійних графіків, гістограм, розподілів.</li>
                    <li>Інтеграція з Matplotlib.</li>
                </ul>
                <p><strong>Переваги:</strong> Зручно використовувати з DataFrame, мінімальний код для базових графіків.</p>
                <p><strong>Недоліки:</strong> Не підтримує складні графіки.</p>
            </div>

            <div class="tool">
                <h2>Holoviews</h2>
                <p><strong>Призначення:</strong> Спрощення візуалізації великих наборів даних.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Підтримка інтерактивності.</li>
                    <li>Інтеграція з Matplotlib, Bokeh та Plotly.</li>
                </ul>
                <p><strong>Переваги:</strong> Простота інтеграції з різними бібліотеками.</p>
                <p><strong>Недоліки:</strong> Відносно нова бібліотека з меншою документацією.</p>
            </div>

            <div class="tool">
                <h2>mplfinance</h2>
                <p><strong>Призначення:</strong> Візуалізація фінансових даних.</p>
                <p><strong>Особливості:</strong></p>
                <ul>
                    <li>Графіки японських свічок, лінійні графіки, обсяги торгів.</li>
                    <li>Пряме використання з pandas DataFrame.</li>
                </ul>
                <p><strong>Переваги:</strong> Спеціалізована для фінансових графіків.</p>
                <p><strong>Недоліки:</strong> Обмежена функціональність поза фінансовою сферою.</p>
            </div>

        <h1>3D Візуалізації</h1>
    
    <div class="tool">
        <h2>Plotly (3D)</h2>
        <p><strong>Призначення:</strong> Інтерактивна 3D-візуалізація даних.</p>
        <p><strong>Особливості:</strong></p>
        <ul>
            <li>Підтримка графіків поверхонь, об’ємів, діаграм розсіювання, сіток та ізоліній.</li>
            <li>Візуалізація у веб-браузері з інтерактивними функціями (масштабування, обертання, зміна перспективи).</li>
            <li>Інтеграція з Jupyter Notebook.</li>
        </ul>
        <p><strong>Переваги:</strong> Легко створювати інтерактивні 3D-графіки. Можливість експорту у HTML.</p>
        <p><strong>Недоліки:</strong> Менш придатний для великих даних у реальному часі. Залежність від веб-браузера для перегляду графіків.</p>
    </div>

    <div class="tool">
        <h2>Mayavi</h2>
        <p><strong>Призначення:</strong> Візуалізація наукових та інженерних даних у 3D.</p>
        <p><strong>Особливості:</strong></p>
        <ul>
            <li>Підтримка великих наборів даних і складних геометричних структур.</li>
            <li>Створення інтерактивних об’єктів, таких як ізолінії, сітки, поверхні та об'єми.</li>
            <li>Інтеграція з науковими бібліотеками Python (NumPy, SciPy).</li>
        </ul>
        <p><strong>Переваги:</strong> Потужний інструмент для наукової 3D-візуалізації. Графічний інтерфейс для редагування графіків.</p>
        <p><strong>Недоліки:</strong> Складний для початківців через багатий функціонал.</p>
    </div>

    <div class="tool">
        <h2>VisPy</h2>
        <p><strong>Призначення:</strong> Швидка візуалізація великих наборів даних з використанням OpenGL.</p>
        <p><strong>Особливості:</strong></p>
        <ul>
            <li>Ефективний рендеринг завдяки GPU-акселерації.</li>
            <li>Підтримка складних 3D-об'єктів, таких як поверхні, вектори, ізолінії.</li>
            <li>Сумісність із інтерактивними середовищами, такими як Jupyter Notebook.</li>
        </ul>
        <p><strong>Переваги:</strong> Підходить для реального часу та великих даних. Підтримка інтерактивності.</p>
        <p><strong>Недоліки:</strong> Відносно низький рівень абстракції, що ускладнює використання для новачків.</p>
    </div>

    <div class="tool">
        <h2>VTK (Visualization Toolkit)</h2>
        <p><strong>Призначення:</strong> Візуалізація наукових, медичних та інженерних даних.</p>
        <p><strong>Особливості:</strong></p>
        <ul>
            <li>Робота з великою кількістю форматів даних (об'єми, вектори, 3D-сітки).</li>
            <li>Підтримка як 3D-візуалізації, так і анімації.</li>
            <li>Інтеграція з іншими мовами програмування, такими як C++ та Java.</li>
        </ul>
        <p><strong>Переваги:</strong> Надійний інструмент для професійної 3D-візуалізації. Потужна підтримка користувацьких модифікацій.</p>
        <p><strong>Недоліки:</strong> Високий поріг входу через складність API. Вимагає більше часу для налаштування та вивчення.</p>
    </div>

    <div class="tool">
        <h2>matplotlib.pyplot (3D)</h2>
        <p><strong>Призначення:</strong> Створення базових 3D-графіків.</p>
        <p><strong>Особливості:</strong></p>
        <ul>
            <li>Додатковий модуль mpl_toolkits.mplot3d для 3D-візуалізації.</li>
            <li>Підтримка 3D-графіків: поверхонь, ліній, розсіювання.</li>
            <li>Гнучке налаштування кольорів, осей, видів тощо.</li>
        </ul>
        <p><strong>Переваги:</strong> Простий у використанні для базової 3D-візуалізації. Інтеграція з 2D-графіками у Matplotlib.</p>
        <p><strong>Недоліки:</strong> Обмежена інтерактивність. Не підходить для складних або великих даних.</p>
    </div>

    <div class="tool">
        <h2>PyVista</h2>
        <p><strong>Призначення:</strong> Інструмент для створення інтерактивної 3D-візуалізації.</p>
        <p><strong>Особливості:</strong></p>
        <ul>
            <li>Працює поверх VTK, спрощуючи синтаксис.</li>
            <li>Підтримка інтерактивної роботи з 3D-об’єктами.</li>
            <li>Інструменти для створення сіток, ізоліній, поверхонь, об’єму.</li>
        </ul>
        <p><strong>Переваги:</strong> Простий синтаксис порівняно з VTK. Інтерактивність у реальному часі.</p>
        <p><strong>Недоліки:</strong> Залежність від VTK для основних функцій.</p>

        <h1>Інтерактивна графіка та дашборди</h1>

        <div class="tool">
            <h2>Dash</h2>
            <p><strong>Призначення:</strong> Dash є фреймворком для створення інтерактивних веб-додатків для аналізу даних і візуалізації.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Побудований на основі Flask, Plotly та React.</li>
                <li>Підтримка інтерактивної 2D та 3D графіки, створеної за допомогою бібліотеки Plotly.</li>
                <li>Розширена можливість інтерактивності через використання колбеків (callbacks).</li>
                <li>Створення повноцінних веб-додатків без необхідності використовувати JavaScript.</li>
            </ul>
            <p><strong>Переваги:</strong> Потужний інструмент для створення аналітичних панелей. Добре інтегрується з іншими бібліотеками Python. Можливість хостингу на різних платформах (локально або в хмарі).</p>
            <p><strong>Недоліки:</strong> Відносно низька продуктивність при роботі з великими наборами даних. Потребує базових знань про Flask та HTML.</p>
        </div>
    
        <div class="tool">
            <h2>Panel</h2>
            <p><strong>Призначення:</strong> Інструмент для створення панелей візуалізації та аналітики, зосереджений на наукових і бізнесових задачах.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримує кілька бібліотек візуалізації, включаючи Bokeh, Matplotlib, Plotly, і Holoviews.</li>
                <li>Можливість додавати інтерактивні елементи: слайдери, випадаючі меню, кнопки тощо.</li>
                <li>Інтеграція з Jupyter Notebook і можливість розгортання як автономного веб-додатка.</li>
            </ul>
            <p><strong>Переваги:</strong> Гнучкий інструмент із багатою інтеграцією бібліотек. Проста розробка дашбордів із мінімальним кодом. Легка інтеграція з Python-середовищем для аналізу даних.</p>
            <p><strong>Недоліки:</strong> Менш популярний, ніж Dash, тому менше документації та прикладів.</p>
        </div>
    
        <div class="tool">
            <h2>Streamlit</h2>
            <p><strong>Призначення:</strong> Простий фреймворк для створення веб-додатків для аналізу даних.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Не потребує глибоких знань веб-розробки.</li>
                <li>Функції дозволяють створювати інтерактивні елементи, такі як графіки, таблиці, форми, слайдери, з декількома рядками коду.</li>
                <li>Автоматичне перезавантаження додатка при зміні коду.</li>
            </ul>
            <p><strong>Переваги:</strong> Дуже простий у використанні, підходить для швидкого створення прототипів. Можливість легко додавати інтерактивні елементи. Чудово підходить для Data Science-проєктів.</p>
            <p><strong>Недоліки:</strong> Обмежена інтерактивність у порівнянні з Dash. Підходить більше для швидкого створення прототипів, ніж для великих комерційних додатків.</p>
        </div>
    
        <div class="tool">
            <h2>Shiny for Python</h2>
            <p><strong>Призначення:</strong> Нещодавно перенесений з R, Shiny дозволяє створювати інтерактивні веб-додатки для Python.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Фреймворк спочатку популярний у спільноті R, але тепер доступний і для Python.</li>
                <li>Простий спосіб створення веб-додатків за допомогою Python-коду.</li>
                <li>Підтримка інтерактивних компонентів, таких як графіки, таблиці та текстові віджети.</li>
                <li>Використовує HTTP-протокол для інтерактивності в реальному часі.</li>
            </ul>
            <p><strong>Переваги:</strong> Чудово підходить для інтерактивної візуалізації та демонстрації даних. Висока гнучкість у налаштуванні.</p>
            <p><strong>Недоліки:</strong> Менш розвинута екосистема для Python у порівнянні з Dash або Streamlit. Більша складність для початківців, особливо тих, хто не знайомий із Shiny у R.</p>
        </div>
    
        <h1>Комп'ютерний зір і обробка зображень</h1>

        <div class="tool">
            <h2>OpenCV (Open Source Computer Vision Library)</h2>
            <p><strong>Призначення:</strong> Бібліотека для комп’ютерного зору, обробки зображень і відео.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримує широкий спектр функцій: обробка зображень, виявлення об’єктів, розпізнавання облич, аналіз руху, 3D-реконструкція.</li>
                <li>Працює з різними форматами зображень (JPEG, PNG, BMP тощо).</li>
                <li>Містить модулі для роботи з відео (наприклад, аналіз відеопотоку).</li>
                <li>Підтримує інтеграцію з Python, C++ та іншими мовами.</li>
            </ul>
            <p><strong>Переваги:</strong> Висока продуктивність завдяки використанню C++ ядра. Розширена документація та велика спільнота користувачів. Підтримка обчислень на GPU через CUDA.</p>
            <p><strong>Недоліки:</strong> Може бути складною для початківців. Обмежена підтримка сучасних моделей машинного навчання.</p>
        </div>
        
        <div class="tool">
            <h2>Pillow (PIL – Python Imaging Library)</h2>
            <p><strong>Призначення:</strong> Легка у використанні бібліотека для роботи із зображеннями.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримка різноманітних форматів зображень, таких як JPEG, PNG, GIF, TIFF.</li>
                <li>Функції для редагування зображень: зміна розміру, поворот, обрізання, накладення тексту.</li>
                <li>Легко інтегрується з іншими Python-бібліотеками.</li>
            </ul>
            <p><strong>Переваги:</strong> Простий синтаксис, ідеально підходить для базових операцій. Легка вага та швидка обробка невеликих зображень.</p>
            <p><strong>Недоліки:</strong> Обмежені можливості в порівнянні з OpenCV. Відсутність функцій комп’ютерного зору.</p>
        </div>
        
        <div class="tool">
            <h2>scikit-image</h2>
            <p><strong>Призначення:</strong> Бібліотека для обробки зображень, створена як доповнення до екосистеми SciPy.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримка різноманітних алгоритмів: сегментація, фільтрація, морфологічні операції, вимірювання властивостей об’єктів.</li>
                <li>Легко інтегрується з NumPy для роботи з масивами.</li>
                <li>Містить інструменти для обробки багатовимірних зображень.</li>
            </ul>
            <p><strong>Переваги:</strong> Відмінно підходить для наукових обчислень. Добра документація для академічних задач.</p>
            <p><strong>Недоліки:</strong> Менш продуктивна для реального часу в порівнянні з OpenCV.</p>
        </div>
        
        <div class="tool">
            <h2>Imageio</h2>
            <p><strong>Призначення:</strong> Інструмент для читання та запису зображень і відео.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримка безлічі форматів: JPEG, PNG, GIF, MP4.</li>
                <li>Простота використання для обробки файлів зображень і відео.</li>
                <li>Використовується для анімацій або роботи з відеопотоками.</li>
            </ul>
            <p><strong>Переваги:</strong> Мінімалістичний інтерфейс для роботи з файлами. Легко інтегрується з іншими бібліотеками.</p>
            <p><strong>Недоліки:</strong> Основний акцент на файлових операціях, обмежена обробка зображень.</p>
        </div>
        
        <div class="tool">
            <h2>PyTorch Vision</h2>
            <p><strong>Призначення:</strong> Модуль для обробки зображень і комп’ютерного зору, інтегрований у PyTorch.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Містить готові нейронні мережі для задач розпізнавання, сегментації тощо.</li>
                <li>Набори даних для навчання моделей (ImageNet, COCO, CIFAR).</li>
                <li>Легке перетворення та аугментація даних через torchvision.transforms.</li>
            </ul>
            <p><strong>Переваги:</strong> Глибока інтеграція з PyTorch для навчання моделей. Підтримка GPU для обчислень.</p>
            <p><strong>Недоліки:</strong> Фокус на машинному навчанні, менш зручний для базової обробки зображень.</p>
        </div>
        
        <div class="tool">
            <h2>TensorFlow Image (tf.image)</h2>
            <p><strong>Призначення:</strong> Модуль TensorFlow для обробки зображень і підготовки їх до навчання моделей.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Набір інструментів для аугментації даних, масштабування, обрізки та нормалізації.</li>
                <li>Інтеграція з TensorFlow для створення нейронних мереж.</li>
                <li>Підтримка обчислень на GPU та TPU.</li>
            </ul>
            <p><strong>Переваги:</strong> Оптимізований для великих обчислень. Сумісність із TensorFlow Extended (TFX) для розгортання моделей.</p>
            <p><strong>Недоліки:</strong> Високий вхідний поріг для новачків. Складність у реалізації базових операцій без глибокого знання TensorFlow.</p>
        </div>

        <h1>Графічні інтерфейси користувача (GUI)</h1>

        <div class="tool">
            <h2>Tkinter</h2>
            <p><strong>Призначення:</strong> Стандартна бібліотека для створення GUI в Python, заснована на інструментарії Tcl/Tk.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Вбудована в Python, не потребує додаткової установки.</li>
                <li>Підтримує основні компоненти GUI: кнопки, текстові поля, меню, слайдери.</li>
                <li>Інструменти для налаштування геометрії вікон (наприклад, pack, grid, place).</li>
            </ul>
            <p><strong>Переваги:</strong> Простота використання, підходить для початківців. Легка інтеграція з Python-кодом. Добра документація і багато прикладів.</p>
            <p><strong>Недоліки:</strong> Обмежені можливості дизайну. Базовий вигляд інтерфейсу, який може виглядати застарілим.</p>
        </div>
        
        <div class="tool">
            <h2>PyQt / PySide</h2>
            <p><strong>Призначення:</strong> Потужні інструментарії для створення сучасних, кросплатформених GUI на основі Qt Framework.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримує створення складних додатків з використанням сучасного дизайну.</li>
                <li>Містить готові віджети для роботи з таблицями, графіками, мультимедіа.</li>
                <li>Підтримка інтеграції з OpenGL для графічного рендерингу.</li>
                <li>PyQt має комерційну ліцензію, тоді як PySide є офіційним відкритим інтерфейсом Qt.</li>
            </ul>
            <p><strong>Переваги:</strong> Висока гнучкість і продуктивність. Широкі можливості кастомізації GUI. Підтримка кросплатформеності (Windows, macOS, Linux).</p>
            <p><strong>Недоліки:</strong> Вищий поріг входу для новачків. PyQt може вимагати придбання ліцензії для комерційного використання.</p>
        </div>
        
        <div class="tool">
            <h2>Kivy</h2>
            <p><strong>Призначення:</strong> Фреймворк для створення сучасних, кросплатформених і сенсорних GUI-додатків, зокрема для мобільних платформ.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримує розробку на Android, iOS, Windows, macOS і Linux.</li>
                <li>Зосереджений на сенсорних інтерфейсах, жестах і анімаціях.</li>
                <li>Використовує власний мову розмітки (Kv Language) для налаштування інтерфейсу.</li>
            </ul>
            <p><strong>Переваги:</strong> Кросплатформеність (особливо для мобільних додатків). Легке створення інтерактивних елементів. Адаптованість до сенсорних екранів.</p>
            <p><strong>Недоліки:</strong> Потребує вивчення додаткового синтаксису (Kv Language). Продуктивність може бути нижчою для складних додатків.</p>
        </div>
        
        <div class="tool">
            <h2>wxPython</h2>
            <p><strong>Призначення:</strong> Python-обгортка для інструментарію wxWidgets, орієнтованого на створення кросплатформених GUI.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримує широкий спектр віджетів і компонентів.</li>
                <li>Надає можливості для створення додатків, що виглядають нативно для різних ОС.</li>
                <li>Має вбудовані інструменти для роботи з мультимедіа, друком, графікою.</li>
            </ul>
            <p><strong>Переваги:</strong> Нативний вигляд інтерфейсу для кожної платформи. Велика кількість готових компонентів.</p>
            <p><strong>Недоліки:</strong> Потребує більше коду для створення базових інтерфейсів. Менш популярний у порівнянні з PyQt або Tkinter, через що є менше ресурсів для навчання.</p>
        </div>
        
        <div class="tool">
            <h2>PyGTK (GObject Introspection)</h2>
            <p><strong>Призначення:</strong> Бібліотека для створення GUI на основі GTK+, широко використовується в середовищі GNOME.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Розробка сучасних графічних додатків для Linux (хоча також підтримує Windows і macOS).</li>
                <li>Інтеграція з GObject Introspection для роботи з іншими бібліотеками.</li>
                <li>Підтримка сучасних технологій, таких як Wayland.</li>
            </ul>
            <p><strong>Переваги:</strong> Добре підходить для Linux-додатків. Сучасний вигляд інтерфейсів.</p>
            <p><strong>Недоліки:</strong> Підходить більше для Linux, ніж для Windows чи macOS. Обмежена документація для Python у порівнянні з іншими бібліотеками.</p>
        </div>

        <h1>Наукова візуалізація</h1>

        <div class="tool">
            <h2>Matplotlib</h2>
            <p><strong>Призначення:</strong> Базова бібліотека для 2D і частково 3D візуалізації в Python, широко використовується в наукових і технічних дослідженнях.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримує створення різноманітних графіків: лінійних, гістограм, розсіяння, спектральних, 3D.</li>
                <li>Велика кількість параметрів для кастомізації (колір, шрифти, осі, мітки).</li>
                <li>Інтеграція з іншими бібліотеками, такими як NumPy, Pandas і SciPy.</li>
            </ul>
            <p><strong>Переваги:</strong> Гнучкість у налаштуваннях. Велика кількість прикладів і документації. Можливість збереження графіків у різних форматах (PNG, PDF, SVG).</p>
            <p><strong>Недоліки:</strong> Висока складність для початківців. Для інтерактивної графіки потрібні додаткові бібліотеки (наприклад, Plotly).</p>
        </div>
        
        <div class="tool">
            <h2>Mayavi</h2>
            <p><strong>Призначення:</strong> Бібліотека для візуалізації 3D-даних і об’єктів у наукових дослідженнях.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримка створення складних 3D-візуалізацій, таких як поверхні, ізолінії, векторні поля.</li>
                <li>Інтеграція з NumPy для обробки даних.</li>
                <li>Використовує движок VTK (Visualization Toolkit) для рендерингу графіки.</li>
            </ul>
            <p><strong>Переваги:</strong> Потужна візуалізація складних тривимірних структур. Можливість створення інтерактивних вікон. Підходить для наукових симуляцій і великих обсягів даних.</p>
            <p><strong>Недоліки:</strong> Висока складність для освоєння. Не завжди підходить для інтерактивного графічного інтерфейсу.</p>
        </div>
        
        <div class="tool">
            <h2>SciPy Visualization</h2>
            <p><strong>Призначення:</strong> Модулі для базової візуалізації, що входять до складу SciPy, орієнтовані на наукові розрахунки та побудову графіків.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Інтеграція з Matplotlib для візуалізації результатів чисельних методів.</li>
                <li>Базова підтримка 2D-графіків і спеціалізованих діаграм.</li>
                <li>Підтримує побудову функцій, графіків оптимізації та інтеграції.</li>
            </ul>
            <p><strong>Переваги:</strong> Простота інтеграції з науковими обчисленнями. Сумісність із іншими модулями SciPy.</p>
            <p><strong>Недоліки:</strong> Обмежена функціональність для складних графіків. Для 3D-візуалізації потрібні додаткові бібліотеки.</p>
        </div>
        
        <div class="tool">
            <h2>Cartopy</h2>
            <p><strong>Призначення:</strong> Бібліотека для геопросторової візуалізації даних.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Створення географічних карт із нанесенням даних.</li>
                <li>Інтеграція з іншими бібліотеками, такими як Matplotlib.</li>
                <li>Підтримка різних картографічних проєкцій (наприклад, азимутальна, меркаторська).</li>
            </ul>
            <p><strong>Переваги:</strong> Висока якість географічних візуалізацій. Можливість використання супутникових даних та API для геокодування.</p>
            <p><strong>Недоліки:</strong> Вимагає значних обчислювальних ресурсів. Вузька спеціалізація, не підходить для загальної наукової візуалізації.</p>
        </div>

        <h1>Графіка для ігор</h1>

        <div class="tool">
            <h2>Pygame</h2>
            <p><strong>Призначення:</strong> Бібліотека для створення 2D-ігор і простих мультимедіа-додатків.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Побудована на основі SDL (Simple DirectMedia Layer), забезпечує підтримку графіки, звуку та введення.</li>
                <li>Проста для вивчення, підходить новачкам у розробці ігор.</li>
                <li>Підтримує анімацію спрайтів, обробку подій, музичні ефекти та об’єкти.</li>
                <li>Може працювати на різних платформах (Windows, macOS, Linux).</li>
            </ul>
            <p><strong>Переваги:</strong> Легка інтеграція із зовнішніми файлами (зображення, звуки, шрифти). Велика спільнота користувачів і багато навчальних матеріалів. Ідеально підходить для навчальних проєктів та прототипування.</p>
            <p><strong>Недоліки:</strong> Обмежена підтримка 3D-графіки. Не оптимізована для великих ігрових проєктів.</p>
        </div>
        
        <div class="tool">
            <h2>Pyglet</h2>
            <p><strong>Призначення:</strong> Бібліотека для розробки 2D- і 3D-ігор із глибоким контролем графічного рендерингу.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримка OpenGL для високоякісної графіки.</li>
                <li>Легка обробка мультимедіа (звуки, відео, текстури).</li>
                <li>Можливість створення повноекранних додатків і віконних програм.</li>
                <li>Інтеграція з 3D-графікою без додаткових бібліотек.</li>
            </ul>
            <p><strong>Переваги:</strong> Легка у використанні для проєктів середньої складності. Широкі можливості для роботи з графікою через OpenGL. Підходить для створення інтерактивних програм, не лише ігор.</p>
            <p><strong>Недоліки:</strong> Потребує базового розуміння OpenGL для складних ефектів. Менша популярність, ніж у Pygame, тому обмежена кількість прикладів.</p>
        </div>
        
        <div class="tool">
            <h2>Arcade</h2>
            <p><strong>Призначення:</strong> Сучасна бібліотека для створення 2D-ігор із простим інтерфейсом і високою продуктивністю.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Побудована на основі OpenGL 3.3, забезпечує швидку рендеринг-графіку.</li>
                <li>Простий у використанні API для роботи зі спрайтами, фізикою та текстурами.</li>
                <li>Підтримує системи зіткнень, інтеграцію з текстом, анімацією та аудіо.</li>
                <li>Орієнтована на простоту використання, особливо для початківців.</li>
            </ul>
            <p><strong>Переваги:</strong> Дуже легкий у вивченні, підходить для розробників-початківців. Висока продуктивність завдяки OpenGL. Чітка структура коду для великих ігрових проєктів.</p>
            <p><strong>Недоліки:</strong> Фокус лише на 2D-графіці. Порівняно нова бібліотека, менша спільнота користувачів.</p>
        </div>
        
        <div class="tool">
            <h2>Cocos2d</h2>
            <p><strong>Призначення:</strong> Рамковий інструмент для створення 2D-ігор з великою кількістю функцій і підтримкою анімації.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримка спрайтів, сцен, шарів, анімацій і системи зіткнень.</li>
                <li>Модульна архітектура, яка дозволяє легко розширювати функціонал.</li>
                <li>Включає інструменти для роботи зі звуком, фізикою та текстом.</li>
                <li>Підтримує кросплатформний розвиток (Windows, macOS, iOS, Android).</li>
            </ul>
            <p><strong>Переваги:</strong> Можливість створення складних ігор із багатим функціоналом. Хороша інтеграція з іншими бібліотеками Python. Велика кількість готових модулів для фізики та анімації.</p>
            <p><strong>Недоліки:</strong> Потребує більше часу для вивчення через велику кількість функцій. Може бути надмірним для простих ігор.</p>
        </div>

        <h1>Спеціалізовані бібліотеки</h1>

        <div class="tool">
            <h2>Manim</h2>
            <p><strong>Призначення:</strong> Потужна бібліотека для створення математичних анімацій і наукових презентацій.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Створення анімованих пояснень математичних понять, геометрії та графіків.</li>
                <li>Підтримка Latex для форматування математичних рівнянь.</li>
                <li>Використання сцени, об'єктів, ефектів і анімацій для побудови відео.</li>
                <li>Можливість роботи з геометричними формами, векторними графіками та 3D-об’єктами.</li>
            </ul>
            <p><strong>Переваги:</strong> Ідеально підходить для створення освітнього контенту. Висока якість графіки та відео. Велика спільнота та багато готових шаблонів.</p>
            <p><strong>Недоліки:</strong> Потребує розуміння концепцій програмування. Вимагає час на освоєння для складних проєктів.</p>
        </div>
        
        <div class="tool">
            <h2>Basemap</h2>
            <p><strong>Призначення:</strong> Спеціалізована бібліотека для створення картографічних візуалізацій.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Інтеграція з Matplotlib для нанесення карт на графіки.</li>
                <li>Підтримка різних картографічних проєкцій (наприклад, Mercator, Lambert).</li>
                <li>Можливість додавання об’єктів на карту, таких як річки, дороги, міста.</li>
                <li>Робота з географічними даними (широта, довгота).</li>
            </ul>
            <p><strong>Переваги:</strong> Легка у використанні для створення базових карт. Інтегрується з існуючими екосистемами Python.</p>
            <p><strong>Недоліки:</strong> Обмежений функціонал у порівнянні з сучаснішими бібліотеками. Припинено підтримку; рекомендовано використовувати Cartopy.</p>
        </div>
        
        <div class="tool">
            <h2>Cartopy</h2>
            <p><strong>Призначення:</strong> Сучасна бібліотека для створення картографічних візуалізацій із підтримкою наукових даних.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Розширена підтримка картографічних проєкцій і геопросторових даних.</li>
                <li>Підтримка роботи з супутниковими зображеннями та географічними даними.</li>
                <li>Можливість створення спеціалізованих карт, таких як кліматичні, океанографічні та екологічні.</li>
            </ul>
            <p><strong>Переваги:</strong> Сучасна та активно підтримується. Інтеграція з Matplotlib для побудови складних графіків. Підтримка інтерактивності та великих наборів даних.</p>
            <p><strong>Недоліки:</strong> Відносно складна для освоєння. Вимагає установки додаткових залежностей.</p>
        </div>
        
        <div class="tool">
            <h2>Folium</h2>
            <p><strong>Призначення:</strong> Бібліотека для створення інтерактивних карт на основі Leaflet.js.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Інтеграція з Jupyter Notebook для візуалізації карт у браузері.</li>
                <li>Підтримка інтерактивних функцій: додавання маркерів, спливаючих вікон, шарів.</li>
                <li>Робота з геопросторовими файлами (GeoJSON, Shapefiles).</li>
                <li>Можливість накладення теплових карт і хлороплетних карт.</li>
            </ul>
            <p><strong>Переваги:</strong> Простий API для створення інтерактивних карт. Легка інтеграція з pandas для роботи з геоданими. Висока продуктивність навіть на великих картах.</p>
            <p><strong>Недоліки:</strong> Обмежена у функціоналі 3D-візуалізації. Потребує вебінтерфейсу для перегляду карт.</p>
        </div>
        
        <div class="tool">
            <h2>Blender Python API</h2>
            <p><strong>Призначення:</strong> Програмний інтерфейс для автоматизації та налаштування функцій у Blender — професійному інструменті для 3D-моделювання.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Дозволяє створювати, редагувати та анімувати 3D-об’єкти через Python-скрипти.</li>
                <li>Доступ до всіх функцій Blender, включаючи текстурування, рендеринг і симуляції.</li>
                <li>Можливість автоматизації рутинних завдань у 3D-дизайні.</li>
                <li>Підтримка імпорту/експорту у різні формати файлів (OBJ, FBX, STL).</li>
            </ul>
            <p><strong>Переваги:</strong> Потужний інструмент для роботи з 3D-графікою. Підтримка створення високоякісних моделей та анімацій. Велика спільнота користувачів і документація.</p>
            <p><strong>Недоліки:</strong> Потребує знань як Python, так і основ роботи в Blender. Високий поріг входу для складних сценаріїв.</p>
        </div>

        <h1>Анімація</h1>

        <div class="tool">
            <h2>Manim</h2>
            <p><strong>Призначення:</strong> Manim — це спеціалізована бібліотека для створення математичних анімацій та освітніх відео.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримка анімації геометричних фігур, функцій і графіків.</li>
                <li>Інтеграція з Latex для відображення математичних формул у відео.</li>
                <li>Побудова складних сцен із багатьма ефектами: обертання, масштабування, поступове з'явлення елементів.</li>
                <li>Можливість роботи з 3D-об'єктами та камерними рухами.</li>
            </ul>
            <p><strong>Переваги:</strong> Підходить для створення освітніх відео високої якості. Велика кількість готових прикладів і шаблонів. Можливість створення кастомних анімацій з точним контролем.</p>
            <p><strong>Недоліки:</strong> Високий поріг входу для новачків. Для рендерингу потрібні потужні ресурси.</p>
        </div>
        
        <div class="tool">
            <h2>Matplotlib.animation</h2>
            <p><strong>Призначення:</strong> Модуль для створення простих анімацій на основі графіків.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Створення 2D-анімацій шляхом поступового оновлення графіка.</li>
                <li>Підтримка збереження анімацій у форматах GIF або відео (MP4).</li>
                <li>Просте управління кадрами через функцію оновлення.</li>
                <li>Сумісність з іншими інструментами Matplotlib.</li>
            </ul>
            <p><strong>Переваги:</strong> Легка інтеграція в наукові звіти. Простий API для створення анімацій із графіками.</p>
            <p><strong>Недоліки:</strong> Обмежений функціонал для складних анімацій. Придатний лише для графічних представлень.</p>
        </div>
        
        <div class="tool">
            <h2>Pillow (GIF-анімація)</h2>
            <p><strong>Призначення:</strong> Бібліотека для роботи із зображеннями, включаючи створення та редагування GIF-анімацій.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Злиття серії зображень у GIF із можливістю налаштування затримки між кадрами.</li>
                <li>Підтримка створення простих анімацій з нерухомими об'єктами.</li>
                <li>Інтеграція з іншими бібліотеками для підготовки зображень.</li>
            </ul>
            <p><strong>Переваги:</strong> Легка у використанні. Можливість роботи з різними форматами зображень.</p>
            <p><strong>Недоліки:</strong> Обмежені можливості для складних анімацій.</p>
        </div>

        <h1>Інші</h1>

        <div class="tool">
            <h2>Cairo</h2>
            <p><strong>Призначення:</strong> 2D-графічна бібліотека для створення високоякісної векторної графіки.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Підтримка векторної графіки та високоякісного рендерингу.</li>
                <li>Інтеграція з різними мовами програмування, включаючи Python (через бібліотеку Pycairo).</li>
                <li>Підтримка створення кривих Безьє, тексту, градієнтів та інших графічних елементів.</li>
            </ul>
            <p><strong>Переваги:</strong> Надзвичайно точне відображення векторних зображень. Можливість створення файлів для друку (PDF, PS). Широкі можливості роботи з шрифтами.</p>
            <p><strong>Недоліки:</strong> Високий поріг входу для новачків. Не інтерактивна (статична графіка).</p>
        </div>
        
        <div class="tool">
            <h2>Aggdraw</h2>
            <p><strong>Призначення:</strong> Розширення для бібліотеки Pillow, що дозволяє створювати складну графіку.</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Розширені можливості для малювання, включаючи криві, контури, заповнення та текст.</li>
                <li>Використання антиаліасингу для згладжених зображень.</li>
                <li>Призначений для роботи з растровою графікою.</li>
            </ul>
            <p><strong>Переваги:</strong> Висока продуктивність завдяки AGG. Простий у використанні для роботи з Pillow.</p>
            <p><strong>Недоліки:</strong> Обмежена документація. Застаріла підтримка у порівнянні з сучасними бібліотеками.</p>
        </div>
        
        <div class="tool">
            <h2>SVGwrite</h2>
            <p><strong>Призначення:</strong> Бібліотека для створення SVG-файлів (Scalable Vector Graphics).</p>
            <p><strong>Особливості:</strong></p>
            <ul>
                <li>Генерація SVG-документів у форматі XML.</li>
                <li>Створення геометричних фігур, тексту, градієнтів та інших елементів.</li>
                <li>Підтримка стилів CSS.</li>
            </ul>
            <p><strong>Переваги:</strong> Простий API для створення SVG-файлів. Сумісність із веб-технологіями. Можливість створення адаптивної графіки.</p>
            <p><strong>Недоліки:</strong> Підходить лише для роботи з векторними зображеннями.</p>
        </div>
    </section>


<!-- Приклад -->

<section id="examples" class="examples">
    <h2>Приклади задач</h2>
    <article>
        <h2>Приклади 2D Графіки: Matplotlib</h2>
        <h3>1. Побудова лінійного графіка</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(-10, 10, 100)
y = 2 * x + 3

plt.plot(x, y, label="y = 2x + 3", color="blue", linestyle="--")

plt.title("Лінійний графік")
plt.xlabel("x")
plt.ylabel("y")
plt.axhline(0, color="black", linewidth=0.5)  # Лінія осі x
plt.axvline(0, color="black", linewidth=0.5)  # Лінія осі y
plt.grid(True)
plt.legend()

plt.show()
        </code></pre>
        <h3>2. Побудова гістограми</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

data = np.random.normal(0, 1, 1000)  # Нормальний розподіл

plt.hist(data, bins=30, color="purple", edgecolor="black", alpha=0.7)

plt.title("Гістограма розподілу")
plt.xlabel("Значення")
plt.ylabel("Частота")
plt.grid(True)

plt.show()
        </code></pre>
        <h3>3. Кругова діаграма</h3>
        <pre><code>
import matplotlib.pyplot as plt

labels = ["Company A", "Company B", "Company C", "Company D"]
sizes = [30, 45, 15, 10]  # Відсотки ринку
colors = ["gold", "lightblue", "lightgreen", "pink"]

plt.pie(sizes, labels=labels, colors=colors, autopct="%1.1f%%", startangle=90)
plt.title("Поділ ринку між компаніями")

plt.show()
        </code></pre>
        <h3>4. Точкова діаграма (Scatter Plot)</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

x = np.random.rand(100)
y = np.random.rand(100)
sizes = np.random.randint(10, 200, size=100)  # Розмір точок
colors = np.random.rand(100)  # Кольори точок

plt.scatter(x, y, s=sizes, c=colors, alpha=0.5, cmap="viridis")
plt.colorbar(label="Інтенсивність кольору")

plt.title("Точкова діаграма")
plt.xlabel("x")
plt.ylabel("y")
plt.grid(True)

plt.show()
        </code></pre>
        <h3>5. Побудова кількох графіків в одному вікні</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)

plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.plot(x, y1, label="sin(x)", color="blue")
plt.title("Синус")
plt.grid(True)
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(x, y2, label="cos(x)", color="green")
plt.title("Косинус")
plt.grid(True)
plt.legend()

plt.tight_layout()
plt.show()
        </code></pre>
        <h3>6. Графік теплової карти (Heatmap)</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

matrix = np.random.rand(10, 10)

plt.imshow(matrix, cmap="hot", interpolation="nearest")
plt.colorbar(label="Інтенсивність")

plt.title("Теплова карта")
plt.show()
        </code></pre>
    </article>

    <h2>Приклади 2D Графіки: Seaborn</h2>
    <article>
        <h3>1. Гістограма (Histogram)</h3>
        <pre><code>
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

data = np.random.normal(0, 1, 1000)

sns.histplot(data, kde=True, color="blue", bins=30)

plt.title("Гістограма розподілу")
plt.xlabel("Значення")
plt.ylabel("Частота")

plt.show()
        </code></pre>
        <h3>2. Графік розсіювання (Scatter Plot)</h3>
        <pre><code>
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

data = pd.DataFrame({
    "x": np.random.rand(100),
    "y": np.random.rand(100),
    "size": np.random.randint(10, 200, 100)
})

sns.scatterplot(data=data, x="x", y="y", size="size", sizes=(10, 200), hue="y", palette="viridis")

plt.title("Точковий графік")
plt.xlabel("x")
plt.ylabel("y")

plt.show()
        </code></pre>
        <h3>3. Парні графіки (Pairplot)</h3>
        <pre><code>
import seaborn as sns
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

data = pd.DataFrame({
    "feature_1": np.random.rand(100),
    "feature_2": np.random.rand(100),
    "feature_3": np.random.rand(100),
    "class": np.random.choice(["A", "B"], size=100)
})

sns.pairplot(data, hue="class", palette="coolwarm")

plt.show()
        </code></pre>
        <h3>4. Ящик з вусами (Boxplot)</h3>
        <pre><code>
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

data = pd.DataFrame({
    "group": np.random.choice(["Group A", "Group B", "Group C"], size=100),
    "value": np.random.normal(0, 1, 100)
})

sns.boxplot(data=data, x="group", y="value", hue="group", palette="Set2", legend=False)

plt.title("Boxplot для груп")
plt.xlabel("Група")
plt.ylabel("Значення")

plt.show()
        </code></pre>
        <h3>5. Теплова карта (Heatmap)</h3>
        <pre><code>
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

data = np.random.rand(10, 10)

sns.heatmap(data, annot=True, cmap="coolwarm", cbar_kws={"label": "Інтенсивність"})

plt.title("Теплова карта")
plt.xlabel("X")
plt.ylabel("Y")

plt.show()
        </code></pre>
        <h3>6. Лінійна регресія (Regression Plot)</h3>
        <pre><code>
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

x = np.linspace(0, 10, 100)
y = 2 * x + np.random.normal(0, 2, 100)
data = pd.DataFrame({"x": x, "y": y})

sns.regplot(data=data, x="x", y="y", color="green")

plt.title("Лінійна регресія")
plt.xlabel("x")
plt.ylabel("y")

plt.show()
        </code></pre>
        <h3>7. Категоріальні дані (Bar Plot)</h3>
        <pre><code>
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd

data = pd.DataFrame({
    "group": ["A", "B", "C", "D"],
    "value": [10, 20, 15, 30]
})

data["hue"] = data["group"]

sns.barplot(data=data, x="group", y="value", hue="hue", dodge=False, palette="Blues")

plt.title("Стовпчиковий графік")
plt.xlabel("Група")
plt.ylabel("Значення")
plt.legend([], [], frameon=False)  # Вимикаємо легенду

plt.show()
        </code></pre>
        </article>

            <h2>Приклади 2D Графіки: Plotly</h2>
        <article>
        <h3>1. Лінійний графік</h3>
        <pre><code>
import plotly.graph_objects as go
import numpy as np

x = np.linspace(-10, 10, 100)
y = x ** 2

fig = go.Figure(data=go.Scatter(x=x, y=y, mode='lines', name='y = x^2'))
fig.update_layout(title="Лінійний графік", xaxis_title="x", yaxis_title="y")

fig.show()
        </code></pre>
        <h3>2. Графік розсіювання (Scatter Plot)</h3>
        <pre><code>
import plotly.express as px
import pandas as pd
import numpy as np

data = pd.DataFrame({
    "x": np.random.rand(100),
    "y": np.random.rand(100),
    "size": np.random.randint(10, 50, 100),
    "color": np.random.choice(["A", "B", "C"], size=100)
})

fig = px.scatter(
    data,
    x="x",
    y="y",
    size="size",
    color="color",
    title="Графік розсіювання"
)

fig.show()
        </code></pre>
        <h3>3. Стовпчиковий графік (Bar Chart)</h3>
        <pre><code>
import plotly.express as px
import pandas as pd

data = pd.DataFrame({
    "group": ["A", "B", "C", "D"],
    "value": [10, 20, 15, 30]
})

fig = px.bar(data, x="group", y="value", title="Стовпчиковий графік", text="value")
fig.update_traces(textposition='outside')

fig.show()
        </code></pre>
        <h3>4. Теплова карта (Heatmap)</h3>
        <pre><code>
import plotly.graph_objects as go
import numpy as np

data = np.random.rand(10, 10)

fig = go.Figure(data=go.Heatmap(
    z=data,
    colorscale='Viridis'
))
fig.update_layout(title="Теплова карта", xaxis_title="X", yaxis_title="Y")

fig.show()
        </code></pre>
        <h3>5. Boxplot (Ящик з вусами)</h3>
        <pre><code>
import plotly.express as px
import pandas as pd
import numpy as np

data = pd.DataFrame({
    "group": np.random.choice(["Group A", "Group B", "Group C"], size=100),
    "value": np.random.normal(0, 1, 100)
})

fig = px.box(data, x="group", y="value", title="Boxplot для груп")
fig.update_traces(boxmean='sd')  # Додати середнє та стандартне відхилення

fig.show()
        </code></pre>
        <h3>6. Лінійна регресія</h3>
        <pre><code>
import plotly.express as px
import pandas as pd
import numpy as np

x = np.linspace(0, 10, 100)
y = 2 * x + np.random.normal(0, 2, 100)
data = pd.DataFrame({"x": x, "y": y})

fig = px.scatter(data, x="x", y="y", trendline="ols", title="Лінійна регресія")
fig.update_traces(marker=dict(size=6))

fig.show()
        </code></pre>
        <h3>7. Кільцевий графік (Pie / Donut Chart)</h3>
        <pre><code>
import plotly.express as px
import pandas as pd

data = pd.DataFrame({
    "category": ["A", "B", "C", "D"],
    "value": [10, 20, 15, 30]
})

fig = px.pie(data, names="category", values="value", title="Кільцевий графік", hole=0.4)

fig.show()
        </code></pre>
        <h3>8. Підграфіки (Subplots)</h3>
        <pre><code>
from plotly.subplots import make_subplots
import plotly.graph_objects as go
import numpy as np

x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)

fig = make_subplots(rows=1, cols=2, subplot_titles=("Синус", "Косинус"))

fig.add_trace(go.Scatter(x=x, y=y1, mode="lines", name="sin(x)"), row=1, col=1)
fig.add_trace(go.Scatter(x=x, y=y2, mode="lines", name="cos(x)"), row=1, col=2)

fig.update_layout(title="Підграфіки")
fig.show()
        </code></pre>
    </article>
        
    <h2>Приклади 2D Графіки: Bokeh</h2>
    <article>
        <h3>1. Лінійний графік</h3>
        <pre><code>
from bokeh.plotting import figure, show
import numpy as np

x = np.linspace(-10, 10, 100)
y = x ** 2

p = figure(title="Лінійний графік", x_axis_label="x", y_axis_label="y")
p.line(x, y, legend_label="y = x^2", line_width=2)

show(p)
        </code></pre>
        <h3>2. Графік розсіювання (Scatter Plot)</h3>
        <pre><code>
from bokeh.plotting import figure, show
from bokeh.models import HoverTool
import numpy as np

x = np.random.rand(100)
y = np.random.rand(100)
sizes = np.random.randint(5, 20, size=100)

p = figure(title="Графік розсіювання", x_axis_label="x", y_axis_label="y", tools="pan,box_zoom,reset")
p.scatter(x, y, size=sizes, color="navy", alpha=0.6)

hover = HoverTool()
hover.tooltips = [("x", "@x"), ("y", "@y")]
p.add_tools(hover)

show(p)
        </code></pre>
        <h3>3. Стовпчиковий графік (Bar Chart)</h3>
        <pre><code>
from bokeh.plotting import figure, show
from bokeh.io import output_notebook

groups = ["A", "B", "C", "D"]
values = [10, 20, 15, 30]

p = figure(x_range=groups, title="Стовпчиковий графік", x_axis_label="Групи", y_axis_label="Значення")
p.vbar(x=groups, top=values, width=0.5, color="skyblue")

show(p)
        </code></pre>
        <h3>4. Теплова карта (Heatmap)</h3>
        <pre><code>
from bokeh.plotting import figure, show
from bokeh.models import LinearColorMapper, ColorBar
import numpy as np

data = np.random.rand(10, 10)

p = figure(title="Теплова карта", x_axis_label="X", y_axis_label="Y", x_range=(0, 10), y_range=(0, 10))
mapper = LinearColorMapper(palette="Viridis256", low=data.min(), high=data.max())
p.image(image=[data], x=0, y=0, dw=10, dh=10, color_mapper=mapper)

color_bar = ColorBar(color_mapper=mapper, label_standoff=12, location=(0, 0))
p.add_layout(color_bar, 'right')

show(p)
        </code></pre>
        <h3>5. Boxplot (Ящик з вусами)</h3>
        <pre><code>
from bokeh.plotting import figure, show
from bokeh.models import ColumnDataSource
from bokeh.io import output_file
import pandas as pd
import numpy as np

data = pd.DataFrame({
    "group": np.random.choice(["Group A", "Group B", "Group C"], size=100),
    "value": np.random.normal(0, 1, 100)
})

q1 = data.groupby("group")["value"].quantile(0.25)
q2 = data.groupby("group")["value"].quantile(0.5)
q3 = data.groupby("group")["value"].quantile(0.75)
iqr = q3 - q1
upper = q3 + 1.5 * iqr
lower = q1 - 1.5 * iqr

groups = ["Group A", "Group B", "Group C"]
source = ColumnDataSource(data=dict(groups=groups, q1=q1, q2=q2, q3=q3, upper=upper, lower=lower))

p = figure(title="Boxplot (Ящик з вусами)", x_range=groups, y_axis_label="Value")

p.vbar(x="groups", top="q3", bottom="q1", width=0.7, source=source, fill_color="lightblue", line_color="black")
p.segment("groups", "upper", "groups", "q3", source=source, line_color="black")
p.segment("groups", "lower", "groups", "q1", source=source, line_color="black")

p.vbar(x="groups", top="q2", bottom="q2", width=0.7, source=source, line_color="black")

output_file("boxplot.html")
show(p)
        </code></pre>
        <h3>6. Лінійна регресія</h3>
        <pre><code>
from bokeh.plotting import figure, show
import numpy as np

x = np.linspace(0, 10, 100)
y = 2 * x + np.random.normal(0, 2, 100)

m, b = np.polyfit(x, y, 1)
regression_line = m * x + b

p = figure(title="Лінійна регресія", x_axis_label="x", y_axis_label="y")
p.scatter(x, y, color="blue", alpha=0.6, legend_label="Дані")
p.line(x, regression_line, color="red", line_width=2, legend_label="Лінія регресії")

show(p)
        </code></pre>
        <h3>7. Кільцевий графік (Donut Chart)</h3>
        <pre><code>
from bokeh.plotting import figure, show
from bokeh.transform import cumsum
from bokeh.palettes import Category20c
import pandas as pd
import numpy as np

data = pd.Series([10, 20, 15, 30], index=["A", "B", "C", "D"])

data = data.reset_index(name='value').rename(columns={'index': 'category'})
data['angle'] = data['value'] / data['value'].sum() * 2 * np.pi
data['color'] = Category20c[len(data)]

p = figure(title="Кільцевий графік", height=350, toolbar_location=None, tools="hover", tooltips="@category: @value")
p.wedge(x=0, y=1, radius=0.4, start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
        line_color="white", fill_color='color', legend_field='category', source=data)

show(p)
        </code></pre>
    </article>
    
    <h2>Приклади 2D Графіки: ggplot</h2>
    <article>
        <h3>1. Лінійний графік (Line Plot)</h3>
        <pre><code>
from plotnine import ggplot, aes, geom_line, ggtitle
import pandas as pd

x = range(-10, 11)
y = [i ** 2 for i in x]
data = pd.DataFrame({"x": x, "y": y})

plot = (
    ggplot(data, aes(x="x", y="y")) +
    geom_line(color="blue", size=1.5) +
    ggtitle("Лінійний графік: y = x^2")
)

plot.show()
        </code></pre>
        <h3>2. Графік розсіювання (Scatter Plot)</h3>
        <pre><code>
from plotnine import ggplot, aes, geom_point, ggtitle
import pandas as pd

data = pd.DataFrame({
    "x": [1, 2, 3, 4, 5],
    "y": [2, 4, 6, 8, 10]
})

plot = (
    ggplot(data, aes(x="x", y="y")) +
    geom_point(color="green", size=3) +
    ggtitle("Графік розсіювання")
)

plot.show()
        </code></pre>
        <h3>3. Стовпчиковий графік (Bar Plot)</h3>
        <pre><code>
from plotnine import ggplot, aes, geom_bar, ggtitle
import pandas as pd

data = pd.DataFrame({
    "category": ["A", "B", "C", "D", "E"],
    "values": [10, 20, 15, 25, 30]
})

plot = (
    ggplot(data, aes(x="category", y="values")) +
    geom_bar(stat="identity", fill="blue", color="black") +
    ggtitle("Стовпчиковий графік")
)

plot.show()
        </code></pre>
        <h3>4. Гістограма</h3>
        <pre><code>
from plotnine import ggplot, aes, geom_histogram, ggtitle
import pandas as pd
import numpy as np

data = pd.DataFrame({"values": np.random.normal(0, 1, 1000)})

plot = (
    ggplot(data, aes(x="values")) +
    geom_histogram(binwidth=0.2, fill="orange", color="black") +
    ggtitle("Гістограма")
)

plot.show()
        </code></pre>
        <h3>5. Boxplot (Ящик з вусами)</h3>
        <pre><code>
from plotnine import ggplot, aes, geom_boxplot, ggtitle
import pandas as pd

data = pd.DataFrame({
    "category": ["A", "A", "B", "B", "C", "C"],
    "values": [5, 7, 8, 6, 9, 11]
})

plot = (
    ggplot(data, aes(x="category", y="values")) +
    geom_boxplot(fill="cyan", color="black") +
    ggtitle("Boxplot (Ящик з вусами)")
)

plot.show()
        </code></pre>
        <h3>6. Лінійна регресія</h3>
        <pre><code>
from plotnine import ggplot, aes, geom_point, geom_smooth, ggtitle
import pandas as pd

data = pd.DataFrame({
    "x": range(1, 11),
    "y": [2.3, 2.9, 3.6, 4.5, 5.1, 6.2, 6.8, 7.4, 8.5, 9.2]
})

plot = (
    ggplot(data, aes(x="x", y="y")) +
    geom_point(color="blue", size=3) +
    geom_smooth(method="lm", color="red", se=False) +
    ggtitle("Лінійна регресія")
)

plot.show()
        </code></pre>
        <h3>7. Теплова карта (Heatmap)</h3>
        <pre><code>
from plotnine import ggplot, aes, geom_tile, ggtitle
import pandas as pd

data = pd.DataFrame({
    "x": ["A", "A", "B", "B", "C", "C"],
    "y": ["X", "Y", "X", "Y", "X", "Y"],
    "value": [1, 2, 3, 4, 5, 6]
})

plot = (
    ggplot(data, aes(x="x", y="y", fill="value")) +
    geom_tile() +
    ggtitle("Теплова карта (Heatmap)")
)

plot.show()
        </code></pre>
        <h3>8. Фасетний графік (Facet Grid)</h3>
        <pre><code>
from plotnine import ggplot, aes, geom_point, facet_wrap, ggtitle
import pandas as pd

data = pd.DataFrame({
    "x": [1, 2, 3, 4, 1, 2, 3, 4],
    "y": [2, 4, 6, 8, 1, 3, 5, 7],
    "group": ["A", "A", "A", "A", "B", "B", "B", "B"]
})

plot = (
    ggplot(data, aes(x="x", y="y")) +
    geom_point(color="green", size=3) +
    facet_wrap("~group") +
    ggtitle("Фасетний графік (Facet Grid)")
)

plot.show()
        </code></pre>
    </article>
    
    <h2>Приклади 2D Графіки: Altair</h2>
    <article>
        <h3>1. Лінійний графік</h3>
        <pre><code>
import altair as alt
import pandas as pd

data = pd.DataFrame({
    "x": range(10),
    "y": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
})

chart = alt.Chart(data).mark_line().encode(
    x="x",
    y="y"
).properties(
    title="Лінійний графік"
)

chart.save("chart.html")
        </code></pre>
        <h3>2. Графік розсіювання (Scatter Plot)</h3>
        <pre><code>
import altair as alt
import pandas as pd

data = pd.DataFrame({
    "x": range(10),
    "y": [2, 3, 5, 7, 11, 13, 17, 19, 23, 29],
    "category": ["A", "B"] * 5
})

chart = alt.Chart(data).mark_circle(size=100).encode(
    x="x",
    y="y",
    color="category",
    tooltip=["x", "y", "category"]
).properties(
    title="Графік розсіювання"
)

chart.save("chart.html")
        </code></pre>
        <h3>3. Стовпчиковий графік (Bar Plot)</h3>
        <pre><code>
import altair as alt
import pandas as pd

data = pd.DataFrame({
    "category": ["A", "B", "C", "D"],
    "values": [10, 20, 15, 25]
})

chart = alt.Chart(data).mark_bar().encode(
    x="category",
    y="values",
    color="category"
).properties(
    title="Стовпчиковий графік"
)

chart.save("chart.html")
        </code></pre>
        <h3>4. Гістограма</h3>
        <pre><code>
import altair as alt
import pandas as pd
import numpy as np

data = pd.DataFrame({
    "values": np.random.normal(0, 1, 1000)
})

chart = alt.Chart(data).mark_bar().encode(
    alt.X("values:Q", bin=alt.Bin(maxbins=30)),
    y="count()"
).properties(
    title="Гістограма"
)

chart.save("chart.html")
        </code></pre>
        <h3>5. Boxplot (Ящик з вусами)</h3>
        <pre><code>
import altair as alt
import pandas as pd

data = pd.DataFrame({
    "category": ["A", "A", "B", "B", "C", "C"],
    "values": [5, 7, 8, 6, 9, 11]
})

chart = alt.Chart(data).mark_boxplot().encode(
    x="category",
    y="values"
).properties(
    title="Boxplot (Ящик з вусами)"
)

chart.save("chart.html")
        </code></pre>
        <h3>6. Лінійна регресія</h3>
        <pre><code>
import altair as alt
import pandas as pd

data = pd.DataFrame({
    "x": range(10),
    "y": [2.3, 2.9, 3.6, 4.5, 5.1, 6.2, 6.8, 7.4, 8.5, 9.2]
})

base = alt.Chart(data).mark_point().encode(
    x="x",
    y="y"
)

line = base.transform_regression("x", "y").mark_line(color="red")

chart = (base + line).properties(
    title="Лінійна регресія"
)

chart.save("chart.html")
        </code></pre>
        <h3>7. Теплова карта (Heatmap)</h3>
        <pre><code>
import altair as alt
import pandas as pd

data = pd.DataFrame({
    "x": ["A", "A", "B", "B", "C", "C"],
    "y": ["X", "Y", "X", "Y", "X", "Y"],
    "value": [1, 2, 3, 4, 5, 6]
})

chart = alt.Chart(data).mark_rect().encode(
    x="x",
    y="y",
    color="value:Q"
).properties(
    title="Теплова карта"
)

chart.save("chart.html")
        </code></pre>
        <h3>8. Фасетний графік (Facet Grid)</h3>
        <pre><code>
import altair as alt
import pandas as pd

data = pd.DataFrame({
    "x": range(10),
    "y": [2.3, 2.9, 3.6, 4.5, 5.1, 6.2, 6.8, 7.4, 8.5, 9.2],
    "category": ["A", "B", "A", "B", "A", "B", "A", "B", "A", "B"]
})

chart = alt.Chart(data).mark_point().encode(
    x="x",
    y="y",
    color="category",
    column="category"
).properties(
    title="Фасетний графік"
)

chart.save("chart.html")
        </code></pre>
    </article>
    
    <h2>Приклади 2D Графіки: Chartify</h2>
    <article>
        <h3>1. Лінійний графік (Line Plot)</h3>
        <pre><code>
import chartify
import pandas as pd

data = pd.DataFrame({
    "date": pd.date_range(start="2023-01-01", periods=10, freq="D"),
    "value": [10, 15, 20, 25, 22, 24, 27, 30, 35, 40]
})

ch = chartify.Chart(x_axis_type='datetime', blank_labels=True)
ch.plot.line(
    data_frame=data,
    x_column="date",
    y_column="value"
)

ch.set_title("Лінійний графік")
ch.axes.set_xaxis_label("Дата")
ch.axes.set_yaxis_label("Значення")

ch.show()
        </code></pre>
        <h3>2. Графік розсіювання (Scatter Plot)</h3>
        <pre><code>
import chartify
import pandas as pd

data = pd.DataFrame({
    "x_value": range(10),
    "y_value": [2, 5, 7, 6, 9, 3, 8, 4, 5, 10]
})

ch = chartify.Chart(blank_labels=True)
ch.plot.scatter(
    data_frame=data,
    x_column="x_value",
    y_column="y_value"
)

ch.set_title("Графік розсіювання")
ch.axes.set_xaxis_label("X-значення")
ch.axes.set_yaxis_label("Y-значення")

ch.show()
        </code></pre>
        <h3>3. Стовпчиковий графік (Bar Plot)</h3>
        <pre><code>
import chartify
import pandas as pd

data = pd.DataFrame({
    "category": ["A", "B", "C", "D"],
    "value": [15, 25, 35, 20]
})

ch = chartify.Chart(x_axis_type='categorical', y_axis_type='linear')
ch.plot.bar(
    data_frame=data,
    categorical_columns=["category"],
    numeric_column="value"
)

ch.set_title("Стовпчиковий графік")
ch.axes.set_xaxis_label("Категорія")
ch.axes.set_yaxis_label("Значення")

ch.show()
        </code></pre>
        <h3>4. Гістограма (Histogram)</h3>
        <pre><code>
import chartify
import pandas as pd
import numpy as np

data = pd.DataFrame({
    "values": np.random.normal(loc=0, scale=1, size=500)
})

bin_counts, bin_edges = np.histogram(data["values"], bins=30)
bins_df = pd.DataFrame({
    "bin_left": bin_edges[:-1],
    "bin_right": bin_edges[1:],
    "count": bin_counts
})

bins_df["bin_label"] = bins_df["bin_left"].round(2).astype(str) + "-" + bins_df["bin_right"].round(2).astype(str)

ch = chartify.Chart(x_axis_type='categorical', y_axis_type='linear')

ch.plot.bar(
    data_frame=bins_df,
    categorical_columns="bin_label",
    numeric_column="count"
)

ch.set_title("Гістограма")
ch.axes.set_xaxis_label("Значення")
ch.axes.set_yaxis_label("Частота")

ch.axes.set_xaxis_tick_orientation('vertical')  # Вертикальні мітки

ch.show()
        </code></pre>
        <h3>5. Теплова карта (Heatmap)</h3>
        <pre><code>
import chartify
import pandas as pd
import numpy as np

data = pd.DataFrame({
    "x_category": ["A", "A", "B", "B", "C", "C"],
    "y_category": ["X", "Y", "X", "Y", "X", "Y"],
    "value": [10, 20, 30, 40, 50, 60]
})

ch = chartify.Chart(x_axis_type='categorical', y_axis_type='categorical')
ch.plot.heatmap(
    data_frame=data,
    x_column="x_category",
    y_column="y_category",
    color_column="value"
)

ch.set_title("Теплова карта")
ch.axes.set_xaxis_label("X Категорія")
ch.axes.set_yaxis_label("Y Категорія")

ch.show()
        </code></pre>
    </article>

    <h2>Приклади 2D Графіки: Pygal</h2>
    <article>
        <h3>1. Лінійний графік (Line Chart)</h3>
        <pre><code>
import pygal

line_chart = pygal.Line(title="Лінійний графік")
line_chart.x_labels = ['Січень', 'Лютий', 'Березень', 'Квітень', 'Травень']
line_chart.add('Продукт A', [10, 20, 15, 30, 25])
line_chart.add('Продукт B', [15, 10, 20, 25, 30])
line_chart.render_to_file('line_chart.svg')
        </code></pre>
        <h3>2. Стовпчиковий графік (Bar Chart)</h3>
        <pre><code>
import pygal

bar_chart = pygal.Bar(title="Стовпчиковий графік")
bar_chart.x_labels = ['Січень', 'Лютий', 'Березень', 'Квітень', 'Травень']
bar_chart.add('Продажі', [5, 15, 10, 25, 20])
bar_chart.render_to_file('bar_chart.svg')
        </code></pre>
        <h3>3. Гістограма (Histogram)</h3>
        <pre><code>
import pygal

hist_chart = pygal.Histogram(
    title="Гістограма оцінок студентів",
    x_title="Інтервали балів",
    y_title="Кількість студентів",
    show_legend=True,
    style=pygal.style.Style(colors=('#ff9999',))
)

hist_chart.add('Оцінки', [
    (3, 0, 5),
    (5, 5, 10),
    (7, 10, 15),
    (4, 15, 20)
])

hist_chart.render_to_file('histogram.svg')
        </code></pre>
        <h3>4. Точковий графік (Scatter Plot)</h3>
        <pre><code>
import pygal

scatter_chart = pygal.XY(title="Точковий графік")
scatter_chart.add('Точки', [(1, 1), (2, 4), (3, 9), (4, 16)])
scatter_chart.render_to_file('scatter_chart.svg')
        </code></pre>
    </article>

    <h2>Приклади 2D Графіки: Pandas Visualization</h2>
    <article>
        <h3>1. Лінійний графік (Line Chart)</h3>
        <pre><code>
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

data = {
    "Місяць": ['Січень', 'Лютий', 'Березень', 'Квітень', 'Травень'],
    "Продажі A": [10, 20, 15, 30, 25],
    "Продажі B": [15, 10, 20, 25, 30],
}
df = pd.DataFrame(data)

df.plot(x="Місяць", y=["Продажі A", "Продажі B"], kind="line", title="Лінійний графік")
plt.ylabel("Продажі")
plt.grid(True)
plt.show()
        </code></pre>
        <h3>2. Стовпчиковий графік (Bar Chart)</h3>
        <pre><code>
df.plot(x="Місяць", y=["Продажі A", "Продажі B"], kind="bar", title="Стовпчиковий графік")
plt.ylabel("Продажі")
plt.grid(axis='y')
plt.show()
        </code></pre>
        <h3>3. Кругова діаграма (Pie Chart)</h3>
        <pre><code>
df_sum = df[["Продажі A", "Продажі B"]].sum()
df_sum.plot(kind="pie", autopct="%.1f%%", title="Розподіл продажів A та B")
plt.ylabel("")  # Прибираємо підпис осі
plt.show()
        </code></pre>
        <h3>4. Точковий графік (Scatter Plot)</h3>
        <pre><code>
df.plot(x="Продажі A", y="Продажі B", kind="scatter", title="Точковий графік")
plt.xlabel("Продажі A")
plt.ylabel("Продажі B")
plt.grid(True)
plt.show()
        </code></pre>
        <h3>5. Гістограма (Histogram)</h3>
        <pre><code>
random_data = pd.Series(np.random.normal(0, 1, 1000))  
random_data.plot(kind="hist", bins=30, title="Гістограма")
plt.xlabel("Значення")
plt.grid(True)
plt.show()
        </code></pre>
    </article>

    <h2>Приклади 2D Графіки: Holoviews</h2>
    <article>
        <h3>1. Лінійний графік (Line Chart)</h3>
        <pre><code>
import holoviews as hv
import numpy as np
import pandas as pd
from bokeh.resources import CDN
from bokeh.embed import file_html
from holoviews import renderer
import plotly.graph_objects as go

hv.extension('bokeh')

x = np.linspace(0, 10, 100)
y = np.sin(x)
line_plot = hv.Curve((x, y), "x", "y").opts(
    title="Лінійний графік", xlabel="Час", ylabel="Амплітуда", color="blue")
        </code></pre>
        <h3>2. Стовпчиковий графік (Bar Chart)</h3>
        <pre><code>
bar_data = pd.DataFrame({
    "Категорія": ["A", "B", "C", "D"],
    "Значення": [10, 20, 15, 25]
})
bar_plot = hv.Bars(bar_data, kdims=["Категорія"], vdims=["Значення"]).opts(
    title="Стовпчиковий графік", color="orange", xlabel="Категорії", ylabel="Значення")
        </code></pre>
        <h3>3. Точковий графік (Scatter Plot)</h3>
        <pre><code>
x_scatter = np.random.randn(100)
y_scatter = np.random.randn(100)
scatter_plot = hv.Scatter((x_scatter, y_scatter), "x", "y").opts(
    title="Точковий графік", size=8, color="green", xlabel="X", ylabel="Y")
        </code></pre>
        <h3>4. Кругова діаграма (Pie Chart)</h3>
        <pre><code>
pie_labels = ["A", "B", "C"]
pie_values = [30, 20, 50]

pie_fig = go.Figure(data=[go.Pie(labels=pie_labels, values=pie_values)])
pie_fig.update_layout(title_text="Кругова діаграма")
        </code></pre>
        <h3>5. Гістограма (Histogram)</h3>
        <pre><code>
hist_data = np.random.normal(size=1000)
hist, edges = np.histogram(hist_data, bins=30)
hist_plot = hv.Histogram((edges, hist)).opts(
    title="Гістограма", xlabel="Значення", ylabel="Частота", color="purple")

# Об'єднання всіх Holoviews графіків
layout = (line_plot + bar_plot + scatter_plot + hist_plot).cols(2)
bokeh_layout = renderer('bokeh').get_plot(layout).state
html_bokeh = file_html(bokeh_layout, CDN, "Holoviews графіки")

html_plotly = pie_fig.to_html(full_html=False, include_plotlyjs='cdn')

final_html = html_bokeh.replace('</body>', f'{html_plotly}</body>')

with open("output.html", "w", encoding='utf-8') as f:
    f.write(final_html)
        </code></pre>
    </article>

    <h2>Приклади 2D Графіки: mplfinance</h2>
    <article>
        <h3>1. Свічковий графік (Candlestick)</h3>
        <pre><code>
import mplfinance as mpf
import pandas as pd
import numpy as np

np.random.seed(42)
dates = pd.date_range("2023-01-01", periods=50)
data = {
    "Open": np.random.uniform(100, 200, size=50),
    "High": np.random.uniform(200, 300, size=50),
    "Low": np.random.uniform(50, 100, size=50),
    "Close": np.random.uniform(100, 200, size=50),
    "Volume": np.random.randint(1000, 5000, size=50),
}
df = pd.DataFrame(data, index=dates)

mpf.plot(df, type="candle", title="Свічковий графік", style="yahoo", volume=True)
        </code></pre>
        <h3>2. OHLC графік (Open-High-Low-Close)</h3>
        <pre><code>
mpf.plot(df, type="ohlc", title="OHLC графік", style="default")
        </code></pre>
        <h3>3. Лінійний графік</h3>
        <pre><code>
mpf.plot(df, type="line", title="Лінійний графік цін", style="charles", ylabel="Ціна")
        </code></pre>
        <h3>4. Свічковий графік з EMA та SMA</h3>
        <pre><code>
add_ema = mpf.make_addplot(df["Close"].rolling(window=5).mean(), color="blue", label="EMA (5)")
add_sma = mpf.make_addplot(df["Close"].rolling(window=10).mean(), color="orange", label="SMA (10)")
mpf.plot(df, type="candle", title="Свічковий графік з EMA та SMA", style="yahoo", addplot=[add_ema, add_sma], volume=True)
        </code></pre>
        <h3>5. Спрощений графік об'ємів</h3>
        <pre><code>
mpf.plot(df, type="line", title="Об'єми торгів", style="classic", ylabel="Об'єми", volume=True)
        </code></pre>
    </article>

    <h2>Приклади 3D Візуалізації: Plotly (3D)</h2>
    <article>
        <h3>1. 3D Точка (Scatter 3D)</h3>
        <pre><code>
import plotly.graph_objects as go
import numpy as np

x = np.random.uniform(-10, 10, 100)
y = np.random.uniform(-10, 10, 100)
z = np.random.uniform(-10, 10, 100)

scatter_3d = go.Figure(
    data=[go.Scatter3d(x=x, y=y, z=z, mode='markers', marker=dict(size=5, color=z, colorscale='Viridis'))]
)
scatter_3d.update_layout(title="3D Точки", scene=dict(xaxis_title="X", yaxis_title="Y", zaxis_title="Z"))
scatter_3d.show()
        </code></pre>
        <h3>2. 3D Поверхня (Surface)</h3>
        <pre><code>
x = np.linspace(-10, 10, 50)
y = np.linspace(-10, 10, 50)
x, y = np.meshgrid(x, y)
z = np.sin(np.sqrt(x ** 2 + y ** 2))

surface_3d = go.Figure(
    data=[go.Surface(z=z, x=x, y=y, colorscale='Viridis')]
)
surface_3d.update_layout(title="3D Поверхня", scene=dict(xaxis_title="X", yaxis_title="Y", zaxis_title="Z"))
surface_3d.show()
        </code></pre>
        <h3>3. 3D Лінія (Line 3D)</h3>
        <pre><code>
t = np.linspace(0, 4 * np.pi, 100)
x = np.sin(t)
y = np.cos(t)
z = t

line_3d = go.Figure(
    data=[go.Scatter3d(x=x, y=y, z=z, mode='lines', line=dict(width=3, color='blue'))]
)
line_3d.update_layout(title="3D Лінія", scene=dict(xaxis_title="X", yaxis_title="Y", zaxis_title="Z"))
line_3d.show()
        </code></pre>
        <h3>4. 3D Стрічка (Ribbon 3D)</h3>
        <pre><code>
x = np.linspace(0, 1, 50)
y = np.linspace(0, 1, 50)
z = np.linspace(0, 1, 50)
z_offset = np.outer(np.sin(x * np.pi), np.cos(y * np.pi))

ribbon_3d = go.Figure(
    data=[go.Surface(z=z_offset, x=x, y=y, colorscale='Cividis')]
)
ribbon_3d.update_layout(title="3D Стрічка", scene=dict(xaxis_title="X", yaxis_title="Y", zaxis_title="Z"))
ribbon_3d.show()
        </code></pre>
        <h3>5. 3D Гістограма (Bar 3D)</h3>
        <pre><code>
x = ['1', '2', '3', '4']
y = ['1', '2', '3', '4']
z_values = np.array([[1, 3, 5, 7], [2, 4, 6, 8], [1, 5, 2, 7], [3, 8, 4, 6]])

# Створення 3D-графіка
fig = go.Figure()

for i, x_val in enumerate(x):
    for j, y_val in enumerate(y):
        fig.add_trace(
            go.Scatter3d(
                x=[x_val], y=[y_val], z=[0],
                mode='lines',
                line=dict(width=0.5, color='blue'),
                showlegend=False
            )
        )
        fig.add_trace(
            go.Scatter3d(
                x=[x_val, x_val], y=[y_val, y_val], z=[0, z_values[i][j]],
                mode='lines',
                line=dict(width=2, color='blue'),
                showlegend=False
            )
        )

# Налаштування графіка
fig.update_layout(
    title="3D Гістограма",
    scene=dict(
        xaxis_title="X",
        yaxis_title="Y",
        zaxis_title="Z"
    )
)

# Відображення графіка
fig.show()
        </code></pre>
    </article>

    <h2>Приклади 3D Візуалізації: Mayavi</h2>
    <article>
        <h3>1. 3D Точки (Scatter 3D)</h3>
        <pre><code>
from mayavi import mlab
import numpy as np

mlab.figure(size=(800, 600), bgcolor=(1, 1, 1))

n = 200
x = np.random.uniform(-5, 5, n)
y = np.random.uniform(-5, 5, n)
z = np.random.uniform(-5, 5, n)
s = np.random.uniform(1, 10, n)
scatter = mlab.points3d(x, y, z, s, scale_factor=0.3, colormap="coolwarm")

mlab.show()
        </code></pre>
        <h3>2. 3D Поверхня (Surface)</h3>
        <pre><code>
X, Y = np.mgrid[-3:3:100j, -3:3:100j]
Z = np.sin(X ** 2 + Y ** 2)
surface = mlab.surf(X, Y, Z, colormap='coolwarm')
mlab.colorbar(surface, title="Значення Z", orientation='vertical')
mlab.show()
        </code></pre>
        <h3>3. 3D Лінія (Line 3D)</h3>
        <pre><code>
t = np.linspace(0, 4 * np.pi, 100)
x = np.sin(t)
y = np.cos(t)
z = t / np.pi
line = mlab.plot3d(x, y, z, t, tube_radius=0.05, colormap="plasma")
mlab.show()
        </code></pre>
        <h3>4. 3D Стрічка (Ribbon 3D)</h3>
        <pre><code>
x = np.linspace(-5, 5, 50)
y = np.sin(x)
z = np.zeros_like(x)
ribbon = mlab.mesh(np.array([x, x]), np.array([y, y + 1]), np.array([z, z + 1]), colormap="viridis")
mlab.show()
        </code></pre>
        <h3>5. 3D Гістограма (Bar 3D)</h3>
        <pre><code>
x, y = np.mgrid[-4:4:10j, -4:4:10j]
z = np.random.rand(*x.shape) * 5
bars = mlab.barchart(x.flatten(), y.flatten(), z.flatten(), color=(0, 0.5, 1))
mlab.show()
        </code></pre>
    </article>

    <h2>Приклади 3D Візуалізації: VisPy</h2>
    <article>
        <h3>1. 3D Точки (Scatter 3D)</h3>
        <pre><code>
import numpy as np
from vispy import app, scene

canvas = scene.SceneCanvas(keys='interactive', size=(800, 600), show=True)
view = canvas.central_widget.add_view()
view.camera = 'turntable'

n = 100
scatter_data = np.random.normal(size=(n, 3), scale=10)
scatter = scene.visuals.Markers(pos=scatter_data, edge_color='blue', face_color='red', size=5, parent=view.scene)

if __name__ == '__main__':
    app.run()
        </code></pre>
        <h3>2. 3D Поверхня (Surface)</h3>
        <pre><code>
x = np.linspace(-10, 10, 50)
y = np.linspace(-10, 10, 50)
x, y = np.meshgrid(x, y)
z = np.sin(0.5 * x) * np.cos(0.5 * y)
surface = scene.visuals.SurfacePlot(x=x, y=y, z=z, shading='smooth', color=(0.3, 0.5, 0.8, 1), parent=view.scene)
        </code></pre>
        <h3>3. 3D Лінія (Line 3D)</h3>
        <pre><code>
n = 100
t = np.linspace(0, 6 * np.pi, n)
x = np.cos(t) * t
y = np.sin(t) * t
z = t

line_data = np.column_stack((x, y, z))

line = scene.visuals.Line(pos=line_data, color='lime', width=2, parent=view.scene)

        </code></pre>
        <h3>4. 3D Стрічка (Ribbon 3D)</h3>
        <pre><code>
t = np.linspace(0, 4*np.pi, 100)
x_ribbon = np.sin(t) * 10
y_ribbon = np.cos(t) * 10
z_ribbon = t
ribbon_data = np.c_[x_ribbon, y_ribbon, z_ribbon]
ribbon = scene.visuals.Tube(points=ribbon_data, radius=0.5, color='green', parent=view.scene)

        </code></pre>
        <h3>5. 3D Гістограма (Bar 3D)</h3>
        <pre><code>
import numpy as np
from vispy import app, scene
from vispy.visuals.transforms import STTransform

canvas = scene.SceneCanvas(keys='interactive', size=(800, 600), show=True)
view = canvas.central_widget.add_view()
view.camera = 'turntable'

x_bins = 6
y_bins = 6
heights = np.random.randint(1, 10, size=(x_bins, y_bins))

for i in range(x_bins):
    for j in range(y_bins):
        height = heights[i, j]

        cube = scene.visuals.Cube(size=(0.9, 0.9, height),
                                  color=(0.4, 0.7, 1, 1), edge_color='black', parent=view.scene)

        cube.transform = STTransform(translate=(i, j, height / 2))

if __name__ == '__main__':
    app.run()
        </code></pre>
    </article>

    <h2>Приклади 3D Візуалізації: VTK</h2>
    <article>
        <h3>1. 3D Точки (Scatter 3D)</h3>
        <pre><code>
import vtk
import random

renderer = vtk.vtkRenderer()
render_window = vtk.vtkRenderWindow()
render_window.AddRenderer(renderer)

interactor = vtk.vtkRenderWindowInteractor()
interactor.SetRenderWindow(render_window)

for _ in range(100):
    x, y, z = random.uniform(-10, 10), random.uniform(-10, 10), random.uniform(-10, 10)

    sphere = vtk.vtkSphereSource()
    sphere.SetCenter(x, y, z)
    sphere.SetRadius(0.3)
    sphere.SetThetaResolution(16)
    sphere.SetPhiResolution(16)

    mapper = vtk.vtkPolyDataMapper()
    mapper.SetInputConnection(sphere.GetOutputPort())

    actor = vtk.vtkActor()
    actor.SetMapper(mapper)

    actor.GetProperty().SetColor(random.random(), random.random(), random.random())

    renderer.AddActor(actor)

renderer.SetBackground(0.1, 0.1, 0.2)
render_window.Render()
interactor.Start()
        </code></pre>
        <h3>2. 3D Поверхня (Surface)</h3>
        <pre><code>
import vtk
import numpy as np

grid_size = 50
points = vtk.vtkPoints()
for i in range(grid_size):
    for j in range(grid_size):
        z = np.sin(i / 5.0) * np.cos(j / 5.0) * 5
        points.InsertNextPoint(i, j, z)

polys = vtk.vtkCellArray()
for i in range(grid_size - 1):
    for j in range(grid_size - 1):
        id1 = i * grid_size + j
        id2 = id1 + 1
        id3 = id1 + grid_size + 1
        id4 = id1 + grid_size

        quad = vtk.vtkQuad()
        quad.GetPointIds().SetId(0, id1)
        quad.GetPointIds().SetId(1, id2)
        quad.GetPointIds().SetId(2, id3)
        quad.GetPointIds().SetId(3, id4)

        polys.InsertNextCell(quad)

polydata = vtk.vtkPolyData()
polydata.SetPoints(points)
polydata.SetPolys(polys)

mapper = vtk.vtkPolyDataMapper()
mapper.SetInputData(polydata)

actor = vtk.vtkActor()
actor.SetMapper(mapper)

renderer = vtk.vtkRenderer()
renderer.AddActor(actor)
renderer.SetBackground(0.1, 0.2, 0.3)

render_window = vtk.vtkRenderWindow()
render_window.AddRenderer(renderer)

interactor = vtk.vtkRenderWindowInteractor()
interactor.SetRenderWindow(render_window)

render_window.Render()
interactor.Start()
        </code></pre>
        <h3>3. 3D Лінія (Line 3D)</h3>
        <pre><code>
import vtk

points = vtk.vtkPoints()
points.InsertNextPoint(0, 0, 0)
points.InsertNextPoint(10, 10, 10)

line = vtk.vtkLine()
line.GetPointIds().SetId(0, 0)
line.GetPointIds().SetId(1, 1)

cells = vtk.vtkCellArray()
cells.InsertNextCell(line)

polydata = vtk.vtkPolyData()
polydata.SetPoints(points)
polydata.SetLines(cells)

mapper = vtk.vtkPolyDataMapper()
mapper.SetInputData(polydata)

actor = vtk.vtkActor()
actor.SetMapper(mapper)
actor.GetProperty().SetLineWidth(4)

renderer = vtk.vtkRenderer()
renderer.AddActor(actor)
renderer.SetBackground(0.2, 0.2, 0.2)

render_window = vtk.vtkRenderWindow()
render_window.AddRenderer(renderer)

interactor = vtk.vtkRenderWindowInteractor()
interactor.SetRenderWindow(render_window)

render_window.Render()
interactor.Start()
        </code></pre>
        <h3>4. 3D Стрічка (Ribbon 3D)</h3>
        <pre><code>
import vtk
import math

points = vtk.vtkPoints()
for i in range(100):
    x = i * 0.2
    y = math.sin(i * 0.1) * 5
    z = math.cos(i * 0.1) * 5
    points.InsertNextPoint(x, y, z)

polyline = vtk.vtkPolyLine()
polyline.GetPointIds().SetNumberOfIds(100)
for i in range(100):
    polyline.GetPointIds().SetId(i, i)

cells = vtk.vtkCellArray()
cells.InsertNextCell(polyline)

polydata = vtk.vtkPolyData()
polydata.SetPoints(points)
polydata.SetLines(cells)

ribbon_filter = vtk.vtkRibbonFilter()
ribbon_filter.SetInputData(polydata)
ribbon_filter.SetWidth(1.0)
ribbon_filter.Update()

mapper = vtk.vtkPolyDataMapper()
mapper.SetInputConnection(ribbon_filter.GetOutputPort())

actor = vtk.vtkActor()
actor.SetMapper(mapper)

renderer = vtk.vtkRenderer()
renderer.AddActor(actor)
renderer.SetBackground(0.2, 0.3, 0.4)

render_window = vtk.vtkRenderWindow()
render_window.AddRenderer(renderer)

interactor = vtk.vtkRenderWindowInteractor()
interactor.SetRenderWindow(render_window)

render_window.Render()
interactor.Start()
        </code></pre>
        <h3>5. 3D Гістограма (Bar 3D)</h3>
        <pre><code>
import vtk
import random

renderer = vtk.vtkRenderer()

for i in range(5):
    for j in range(5):
        height = random.uniform(1, 10)

        cube = vtk.vtkCubeSource()
        cube.SetXLength(0.9)
        cube.SetYLength(0.9)
        cube.SetZLength(height)
        cube.SetCenter(i, j, height / 2)

        mapper = vtk.vtkPolyDataMapper()
        mapper.SetInputConnection(cube.GetOutputPort())

        actor = vtk.vtkActor()
        actor.SetMapper(mapper)

        r = random.random()
        g = random.random()
        b = random.random()
        actor.GetProperty().SetColor(r, g, b)

        renderer.AddActor(actor)

renderer.SetBackground(0.2, 0.2, 0.3)

render_window = vtk.vtkRenderWindow()
render_window.AddRenderer(renderer)

interactor = vtk.vtkRenderWindowInteractor()
interactor.SetRenderWindow(render_window)

render_window.Render()
interactor.Start()
        </code></pre>
    </article>

    <h2>Приклади 3D Візуалізації: Matplotlib (3D)</h2>
    <article>
        <h3>1. 3D Точка (Scatter 3D)</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(figsize=(15, 10))

ax1 = fig.add_subplot(231, projection='3d')
x = np.random.rand(50)
y = np.random.rand(50)
z = np.random.rand(50)
ax1.scatter(x, y, z, c='r', marker='o')
ax1.set_title('3D Точка (Scatter)')
        </code></pre>
        <h3>2. 3D Поверхня (Surface)</h3>
        <pre><code>
ax2 = fig.add_subplot(232, projection='3d')
X = np.linspace(-5, 5, 50)
Y = np.linspace(-5, 5, 50)
X, Y = np.meshgrid(X, Y)
Z = np.sin(np.sqrt(X**2 + Y**2))
ax2.plot_surface(X, Y, Z, cmap='viridis')
ax2.set_title('3D Поверхня (Surface)')
        </code></pre>
        <h3>3. 3D Лінія (Line 3D)</h3>
        <pre><code>
ax3 = fig.add_subplot(233, projection='3d')
z_line = np.linspace(0, 15, 100)
x_line = np.sin(z_line)
y_line = np.cos(z_line)
ax3.plot3D(x_line, y_line, z_line, color='g')
ax3.set_title('3D Лінія (Line)')
        </code></pre>
        <h3>4. 3D Стрічка (Ribbon 3D)</h3>
        <pre><code>
ax4 = fig.add_subplot(234, projection='3d')
z_ribbon = np.linspace(0, 10, 100)
x_ribbon1 = np.sin(z_ribbon)
y_ribbon1 = np.ones_like(z_ribbon)
x_ribbon2 = np.sin(z_ribbon)
y_ribbon2 = np.ones_like(z_ribbon) * 2
for i in range(len(z_ribbon)-1):
    xs = [x_ribbon1[i], x_ribbon2[i]]
    ys = [y_ribbon1[i], y_ribbon2[i]]
    zs = [z_ribbon[i], z_ribbon[i]]
    ax4.plot(xs, ys, zs, color='orange')
ax4.set_title('3D Стрічка (Ribbon)')
        </code></pre>
        <h3>5. 3D Гістограма (Bar 3D)</h3>
        <pre><code>
ax5 = fig.add_subplot(235, projection='3d')
_x = np.arange(4)
_y = np.arange(3)
_xx, _yy = np.meshgrid(_x, _y)
x_bar, y_bar = _xx.ravel(), _yy.ravel()
z_bar = np.zeros_like(x_bar)
dx = dy = 0.5
dz = np.random.randint(1, 10, size=len(z_bar))
ax5.bar3d(x_bar, y_bar, z_bar, dx, dy, dz, shade=True, color='purple')
ax5.set_title('3D Гістограма (Bar)')

plt.tight_layout()
plt.savefig("3D_visualizations.png")
plt.show()
        </code></pre>
    </article>

    <h2>Приклади 3D Візуалізації: PyVista</h2>
    <article>
        <h3>1. 3D Точка (Scatter 3D)</h3>
        <pre><code>
import pyvista as pv
import numpy as np

plotter = pv.Plotter()

points = np.random.rand(50, 3) * 10
point_cloud = pv.PolyData(points)
plotter.add_mesh(point_cloud, color="red", point_size=10, render_points_as_spheres=True, label="3D Scatter")
        </code></pre>
        <h3>2. 3D Поверхня (Surface)</h3>
        <pre><code>
x = np.linspace(-5, 5, 50)
y = np.linspace(-5, 5, 50)
x, y = np.meshgrid(x, y)
z = np.sin(np.sqrt(x**2 + y**2))
surface = pv.StructuredGrid(x, y, z)
plotter.add_mesh(surface, cmap="viridis", label="3D Surface")
        </code></pre>
        <h3>3. 3D Лінія (Line 3D)</h3>
        <pre><code>
line_points = np.array([[i, np.sin(i), np.cos(i)] for i in np.linspace(0, 10, 100)])
line = pv.Spline(line_points, 100)
plotter.add_mesh(line, color="blue", line_width=3, label="3D Line")
        </code></pre>
        <h3>4. 3D Стрічка (Ribbon 3D)</h3>
        <pre><code>
ribbon_points = np.array([[i, np.sin(i), 0] for i in np.linspace(0, 10, 100)])
spline = pv.Spline(ribbon_points, 100)
ribbon = spline.ribbon(normal=(0, 0, 1), width=1.0)
plotter.add_mesh(ribbon, color="magenta", label="3D Ribbon")
        </code></pre>
        <h3>5. 3D Гістограма (Bar 3D)</h3>
        <pre><code>
x = np.arange(5)
y = np.arange(5)
z = np.zeros((5, 5))
dx = dy = 0.5
dz = np.random.randint(1, 10, size=(5, 5))

for i in range(5):
    for j in range(5):
        center = (x[i], y[j], dz[i, j] / 2)
        cube = pv.Cube(center=center, x_length=dx, y_length=dy, z_length=dz[i, j])
        plotter.add_mesh(cube, color="cyan", label="3D Histogram" if (i == 0 and j == 0) else None)

plotter.add_legend()
plotter.show()
        </code></pre>
    </article>

    <h2>Приклади Інтерактивної Графіки та Дашбордів: Dash</h2>
    <article>
        <h3>1. Лінійний графік з вибором країни</h3>
        <pre><code>
import dash
from dash import dcc, html, Input, Output
import plotly.express as px

app = dash.Dash(__name__)

df = px.data.gapminder()
countries = df['country'].unique()

app.layout = html.Div([
    html.H2("GDP на душу населення за роками"),
    dcc.Dropdown(
        id='country-selector',
        options=[{'label': c, 'value': c} for c in countries],
        value='Ukraine',
        clearable=False
    ),
    dcc.Graph(id='gdp-line')
])

@app.callback(
    Output('gdp-line', 'figure'),
    Input('country-selector', 'value')
)
def update_graph(selected_country):
    filtered = df[df['country'] == selected_country]
    fig = px.line(filtered, x="year", y="gdpPercap", markers=True, title=f"GDP на душу населення: {selected_country}")
    fig.update_traces(text=filtered['gdpPercap'], textposition="top center")
    fig.update_layout(hovermode="x unified")
    return fig

if __name__ == '__main__':
    app.run(debug=True)
        </code></pre>
        <h3>2. Стовпчиковий графік населення по континентах</h3>
        <pre><code>
import dash
from dash import html, dcc
import plotly.express as px

app = dash.Dash(__name__)

df = px.data.gapminder().query("year == 2007")

fig = px.bar(df, x="continent", y="pop", color="continent", title="Населення по континентах у 2007")

app.layout = html.Div([
    html.H2("Стовпчиковий графік"),
    dcc.Graph(figure=fig)
])

if __name__ == '__main__':
    app.run(debug=True)
        </code></pre>
        <h3>3. Кругова діаграма (Pie Chart)</h3>
        <pre><code>
import dash
from dash import html, dcc
import plotly.express as px

df = px.data.tips()
fig = px.pie(df, names='day', values='total_bill', title='Розподіл прибутку за днями')

app = dash.Dash(__name__)
app.layout = html.Div([
    html.H2("Кругова діаграма (Pie)"),
    dcc.Graph(figure=fig)
])

if __name__ == '__main__':
    app.run(debug=True)
        </code></pre>
        <h3>4. Кореляційна діаграма (Scatter Plot)</h3>
        <pre><code>
import dash
from dash import html, dcc
import plotly.express as px

df = px.data.iris()
fig = px.scatter(df, x="sepal_width", y="sepal_length", color="species",
                 size="petal_length", title="Кореляція розмірів у квітів")

app = dash.Dash(__name__)
app.layout = html.Div([
    html.H2("Кореляційна діаграма (Iris Dataset)"),
    dcc.Graph(figure=fig)
])

if __name__ == '__main__':
    app.run(debug=True)
        </code></pre>
        <h3>5. Інтерактивна гістограма з вибором стовпців</h3>
        <pre><code>
import dash
from dash import dcc, html, Input, Output
import plotly.express as px

df = px.data.tips()

app = dash.Dash(__name__)

app.layout = html.Div([
    html.H2("Гістограма з вибором стовпця"),
    dcc.Dropdown(
        id='column-selector',
        options=[{'label': col, 'value': col} for col in ['total_bill', 'tip']],
        value='total_bill',
        clearable=False
    ),
    dcc.Graph(id='histogram')
])

@app.callback(
    Output('histogram', 'figure'),
    Input('column-selector', 'value')
)
def update_hist(column):
    fig = px.histogram(df, x=column, nbins=20, title=f"Гістограма: {column}")
    return fig

if __name__ == '__main__':
    app.run(debug=True)
        </code></pre>
    </article>

    <h2>Приклади Інтерактивної Графіки та Дашбордів: Panel</h2>
    <article>
        <h3>1. Інтерактивний слайдер для синусоїди</h3>
        <pre><code>
import numpy as np
import panel as pn
import matplotlib.pyplot as plt

pn.extension()

def plot(freq=1.0):
    x = np.linspace(0, 10, 500)
    y = np.sin(x * freq)
    plt.figure()
    plt.plot(x, y)
    plt.title(f"Синусоїда з частотою {freq}")
    return pn.pane.Matplotlib(plt.gcf(), tight=True)

slider = pn.widgets.FloatSlider(name='Частота', start=0.1, end=5, step=0.1, value=1)
interactive_plot = pn.bind(plot, freq=slider)

pn.Column(slider, interactive_plot).show()
        </code></pre>
        <h3>2. Дропдаун + гістограма (Seaborn)</h3>
        <pre><code>
import seaborn as sns
import panel as pn
import matplotlib.pyplot as plt

pn.extension()
df = sns.load_dataset("penguins")

def plot(column):
    plt.figure()
    sns.histplot(df[column].dropna(), kde=True)
    plt.title(f"Гістограма '{column}'")
    return pn.pane.Matplotlib(plt.gcf(), tight=True)

dropdown = pn.widgets.Select(name='Ознака', options=list(df.columns))
hist = pn.bind(plot, column=dropdown)

pn.Column(dropdown, hist).servable().show()
        </code></pre>
        <h3>3. Вкладки з різними графіками</h3>
        <pre><code>
import panel as pn
import holoviews as hv
import numpy as np

pn.extension()
hv.extension('bokeh')

x = np.linspace(0, 10, 100)
sin_plot = hv.Curve((x, np.sin(x)), 'x', 'y').opts(title='Синус')
cos_plot = hv.Curve((x, np.cos(x)), 'x', 'y').opts(title='Косинус')

tabs = pn.Tabs(
    ('Синус', sin_plot),
    ('Косинус', cos_plot)
)

tabs.servable().show()
        </code></pre>
        <h3>4. Інтерактивний DataFrame</h3>
        <pre><code>
import panel as pn
import pandas as pd
import numpy as np

pn.extension()
df = pd.DataFrame(np.random.randn(10, 3), columns=['A', 'B', 'C'])
data_table = pn.widgets.DataFrame(df, name="Таблиця", width=400, height=300)

pn.Column("# Інтерактивна таблиця", data_table).servable().show()
        </code></pre>
        <h3>5. Графік з вибором Plotly</h3>
        <pre><code>
import panel as pn
import plotly.express as px

pn.extension()

df = px.data.iris()

def create_plot(column):
    fig = px.histogram(df, x=column, title=f"Plotly: Гістограма '{column}'")
    return pn.pane.Plotly(fig)

dropdown = pn.widgets.Select(name='Ознака', options=list(df.columns))
plot = pn.bind(create_plot, column=dropdown)

pn.Column("# Plotly інтерактивна гістограма", dropdown, plot).show()
       </code></pre>
    </article>

    <h2>Приклади Інтерактивної Графіки та Дашбордів: Streamlit</h2>
    <article>
        <h3>1. ВВП на душу населення у вибраній країні</h3>
        <pre><code>
import streamlit as st
import pandas as pd
import plotly.express as px

st.title("GDP per Capita у вибраній країні")

df_all = px.data.gapminder()

countries = sorted(df_all["country"].unique())
selected_country = st.selectbox("Оберіть країну:", countries, index=countries.index("Germany"))

df = df_all[df_all["country"] == selected_country]

years = df["year"].unique()
min_year, max_year = st.slider(
    "Виберіть діапазон років:",
    int(years.min()),
    int(years.max()),
    (int(years.min()), int(years.max())),
    step=5
)

filtered_df = df[(df["year"] >= min_year) & (df["year"] <= max_year)]

fig = px.line(
    filtered_df,
    x="year",
    y="gdpPercap",
    title=f"GDP per Capita у {selected_country}",
    markers=True,
    labels={"gdpPercap": "GDP per Capita", "year": "Рік"},
)

fig.update_traces(line=dict(color="royalblue", width=3), marker=dict(size=8, color="red"))

st.plotly_chart(fig, use_container_width=True)
        </code></pre>
        <h3>2. Слайдер для побудови графіка y = A * sin(x)</h3>
        <pre><code>
import streamlit as st
import numpy as np
import matplotlib.pyplot as plt

st.title("Графік y = A * sin(x)")

A = st.slider("Амплітуда (A)", 0.0, 10.0, 1.0)
x = np.linspace(0, 10, 100)
y = A * np.sin(x)

fig, ax = plt.subplots()
ax.plot(x, y)
ax.set_title("y = A * sin(x)")

st.pyplot(fig)
        </code></pre>
        <h3>3. Інтерактивна гістограма з вибором стовпця</h3>
        <pre><code>
import streamlit as st
import seaborn as sns
import matplotlib.pyplot as plt

st.title("Інтерактивна гістограма")

df = sns.load_dataset("iris")
column = st.selectbox("Оберіть стовпець", df.select_dtypes(include='number').columns)

fig, ax = plt.subplots()
sns.histplot(df[column], bins=20, kde=True, ax=ax)
st.pyplot(fig)
        </code></pre>
        <h3>4. Віджет для введення тексту + виведення</h3>
        <pre><code>
import streamlit as st

st.title("Привіт, користувач!")

name = st.text_input("Введи своє ім’я")
if name:
    st.success(f"Привіт, {name}!")
        </code></pre>
        <h3>5. Dash-like інтерактивний дашборд</h3>
        <pre><code>
import streamlit as st
import pandas as pd
import plotly.express as px

st.set_page_config(layout="wide")

df = px.data.gapminder().query("year == 2007")

col1, col2 = st.columns(2)

with col1:
    country = st.selectbox("Оберіть країну", df["country"].unique())
    country_data = df[df["country"] == country]
    st.write(f"Інфо про {country}")
    st.write(country_data)

with col2:
    fig = px.scatter(df, x="gdpPercap", y="lifeExp", size="pop", color="continent", hover_name="country",
                     log_x=True, size_max=60)
    st.plotly_chart(fig, use_container_width=True)
        </code></pre>
    </article>

    <h2>Приклади Інтерактивної Графіки та Дашбордів: Shiny for Python</h2>
    <article>
        <h3>1. Інтерактивна лінійна діаграма з matplotlib</h3>
        <pre><code>
from shiny import App, render, ui, reactive
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

df = pd.DataFrame({
    "Рік": np.arange(2000, 2021),
    "Значення": [round(i ** 1.3 + 50 + np.random.randint(-10, 10), 2) for i in range(21)]
})

app_ui = ui.page_fluid(
    ui.h2("Інтерактивна лінійна діаграма"),
    ui.input_slider("min_year", "Початковий рік", min=df["Рік"].min(), max=df["Рік"].max(), value=df["Рік"].min(),
                    step=1),
    ui.input_select("color", "Оберіть колір лінії", choices=["blue", "green", "red", "orange", "purple"],
                    selected="blue"),
    ui.output_plot("line_plot"),
    ui.output_text_verbatim("avg_output")
)

def server(input, output, session):
    @reactive.calc
    def filtered_df():
        return df[df["Рік"] >= input.min_year()]

    @output
    @render.plot
    def line_plot():
        data = filtered_df()
        plt.plot(data["Рік"], data["Значення"], color=input.color(), marker='o')
        plt.axhline(data["Значення"].mean(), color='gray', linestyle='--', label='Середнє')
        plt.title("Значення по роках")
        plt.xlabel("Рік")
        plt.ylabel("Значення")
        plt.legend()

    @output
    @render.text
    def avg_output():
        data = filtered_df()
        return f"Середнє значення: {round(data['Значення'].mean(), 2)}"


app = App(app_ui, server)
        </code></pre>
        <h3>2. Інтерактивний слайдер з відображенням синуса</h3>
        <pre><code>
from shiny import App, ui, render, reactive
import numpy as np
import matplotlib.pyplot as plt

app_ui = ui.page_fluid(
    ui.input_slider("frequency", "Частота", 1, 10, 2),
    ui.output_plot("sine_plot")
)

def server(input, output, session):
    @output
    @render.plot
    def sine_plot():
        x = np.linspace(0, 2 * np.pi, 400)
        y = np.sin(input.frequency() * x)
        plt.plot(x, y)
        plt.title(f"sin({input.frequency()}x)")

app = App(app_ui, server)
        </code></pre>
        <h3>3. Вибір колонки для гістограми з pandas + plotly</h3>
        <pre><code>
from shiny import App, ui, render
import pandas as pd
import plotly.express as px

df = px.data.iris()

app_ui = ui.page_fluid(
    ui.input_select("column", "Оберіть колонку:", choices=list(df.select_dtypes(include="number").columns)),
    ui.output_plot("hist_plot")
)

def server(input, output, session):
    @output
    @render.plot
    def hist_plot():
        fig = px.histogram(df, x=input.column())
        fig.update_layout(title=f"Гістограма по {input.column()}")
        fig.show()

app = App(app_ui, server)
        </code></pre>
        <h3>4. Динамічне оновлення діаграми з вибором країни</h3>
        <pre><code>
from shiny import App, ui, render
import plotly.express as px
import pandas as pd

df = px.data.gapminder()

app_ui = ui.page_fluid(
    ui.input_select("country", "Оберіть країну:", choices=sorted(df["country"].unique())),
    ui.output_plot("gdp_plot")
)

def server(input, output, session):
    @output
    @render.plot
    def gdp_plot():
        country_df = df[df["country"] == input.country()]
        fig = px.line(country_df, x="year", y="gdpPercap", title=f"GDP per Capita: {input.country()}")
        fig.show()

app = App(app_ui, server)
        </code></pre>
        <h3>5. Таблиця з фільтрацією по року</h3>
        <pre><code>
from shiny import App, ui, render
import pandas as pd
import plotly.express as px

df = px.data.gapminder()

app_ui = ui.page_fluid(
    ui.input_numeric("year", "Оберіть рік", 2007, min=1952, max=2007),
    ui.output_table("filtered_table")
)

def server(input, output, session):
    @output
    @render.table
    def filtered_table():
        return df[df["year"] == input.year()]

app = App(app_ui, server)
        </code></pre>
    </article>

    <h2>Комп'ютерний зір і обробка зображень: OpenCV</h2>
    <article>
        <h3>1. Завантаження та показ зображення</h3>
        <pre><code>
import cv2
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

img = cv2.imread(path)

if img is None:
    print("Помилка: файл не знайдено або шлях неправильний!")
else:
    cv2.imshow('Зображення', img)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
        </code></pre>
        <h3>2. Перетворення в чорно-біле</h3>
        <pre><code>
import cv2
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

img = cv2.imread(path)

if img is None:
    print("Error: File not found or incorrect path!")
else:
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    cv2.imshow('Original', img)
    cv2.imshow('Gray', gray)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
        </code></pre>
        <h3>3. Перетворення в чорно-біле</h3>
        <pre><code>
import cv2
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

img = cv2.imread(path)

if img is None:
    print("Error: File not found or incorrect path!")
else:
    blurred = cv2.GaussianBlur(img, (15, 15), 0)
    cv2.imshow('Original', img)
    cv2.imshow('Blurred', blurred)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
        </code></pre>
        <h3>4. Детекція країв (Canny Edge Detection)</h3>
        <pre><code>
import cv2
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

img = cv2.imread(path)

if img is None:
    print("Error: File not found or incorrect path!")
else:
    edges = cv2.Canny(img, 100, 200)
    cv2.imshow('Original', img)
    cv2.imshow('Edges', edges)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
        </code></pre>
        <h3>5. Малювання прямокутника на зображенні</h3>
        <pre><code>
import cv2
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

img = cv2.imread(path)

if img is None:
    print("Error: File not found or incorrect path!")
else:
    start_point = (5, 5)
    end_point = (217, 220)
    color = (0, 25, 0)
    thickness = 3
    img_rect = cv2.rectangle(img.copy(), start_point, end_point, color, thickness)

    cv2.imshow('Original', img)
    cv2.imshow('Rectangle', img_rect)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
        </code></pre>
    </article>

    <h2>Комп'ютерний зір і обробка зображень: Pillow (PIL)</h2>
    <article>
        <h3>1. Завантаження та відображення зображення</h3>
        <pre><code>
from PIL import Image
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

try:
    img = Image.open(path)
    img.show()
except FileNotFoundError:
    print("Error: File not found or incorrect path!")
        </code></pre>
        <h3>2. Перетворення в чорно-білий режим (Grayscale)</h3>
        <pre><code>
from PIL import Image
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

try:
    img = Image.open(path)
    gray = img.convert('L')
    gray.show()
except FileNotFoundError:
    print("Error: File not found or incorrect path!")
        </code></pre>
        <h3>3. Обрізання частини зображення (Crop)</h3>
        <pre><code>
from PIL import Image
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

try:
    img = Image.open(path)
    cropped = img.crop((100, 100, 400, 400))
    cropped.show()
except FileNotFoundError:
    print("Error: File not found or incorrect path!")
        </code></pre>
        <h3>4. Зміна розміру зображення (Resize)</h3>
        <pre><code>
from PIL import Image
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

try:
    img = Image.open(path)
    resized = img.resize((300, 300))
    resized.show()
except FileNotFoundError:
    print("Error: File not found or incorrect path!")
        </code></pre>
        <h3>5. Поворот зображення (Rotate)</h3>
        <pre><code>
from PIL import Image
import os

filename = "image.jpg"
folder = r"E:\NewFolder"
path = os.path.join(folder, filename)

try:
    img = Image.open(path)
    rotated = img.rotate(90)
    rotated.show()
except FileNotFoundError:
    print("Error: File not found or incorrect path!")
        </code></pre>
    </article>

    <h2>Комп'ютерний зір і обробка зображень: scikit-image</h2>
    <article>
        <h3>1. Завантаження і показ зображення</h3>
        <pre><code>
from skimage.io import imread, imshow
import matplotlib.pyplot as plt
import os

path = os.path.join(r"E:\NewFolder", "image.jpg")
image = imread(path)

plt.imshow(image)
plt.title("Зображення")
plt.axis('off')
plt.show()
        </code></pre>
        <h3>2. Перетворення в чорно-біле</h3>
        <pre><code>
from skimage.color import rgb2gray
from skimage.io import imread
import matplotlib.pyplot as plt
import os

path = os.path.join(r"E:\NewFolder", "image.jpg")
image = imread(path)
gray = rgb2gray(image)

plt.imshow(gray, cmap='gray')
plt.title("Grayscale")
plt.axis('off')
plt.show()
        </code></pre>
        <h3>3. Обрізка зображення</h3>
        <pre><code>
from skimage.io import imread
import matplotlib.pyplot as plt
import os

path = os.path.join(r"E:\NewFolder", "image.jpg")
image = imread(path)
cropped = image[100:400, 100:400]  # [y1:y2, x1:x2]

plt.imshow(cropped)
plt.title("Обрізане зображення")
plt.axis('off')
plt.show()
        </code></pre>
        <h3>4. Зміна розміру зображення</h3>
        <pre><code>
from skimage.transform import resize
from skimage.io import imread
import matplotlib.pyplot as plt
import os

path = os.path.join(r"E:\NewFolder", "image.jpg")
image = imread(path)
resized = resize(image, (300, 300))  # (height, width)

plt.imshow(resized)
plt.title("Змінене зображення")
plt.axis('off')
plt.show()
        </code></pre>
        <h3>5. Фільтрація (розмиття) зображення</h3>
        <pre><code>
from skimage.io import imread
from skimage.filters import gaussian
import matplotlib.pyplot as plt
import os

path = os.path.join(r"E:\NewFolder", "image.jpg")
image = imread(path)
blurred = gaussian(image, sigma=2, channel_axis=-1)

plt.imshow(blurred)
plt.title("Розмите зображення")
plt.axis('off')
plt.show()
        </code></pre>
    </article>

    <h2>Комп'ютерний зір і обробка зображень: Imageio</h2>
    <article>
        <h3>1. Завантаження і показ зображення</h3>
        <pre><code>
import imageio.v3 as iio
import matplotlib.pyplot as plt

path = r"E:\NewFolder\image.jpg"

img = iio.imread(path)

plt.imshow(img)
plt.title("Зображення")
plt.axis("off")
plt.show()
        </code></pre>
        <h3>2. Збереження нового зображення</h3>
        <pre><code>
import imageio.v3 as iio
import matplotlib.pyplot as plt
import os

folder = r"E:\NewFolder"
img1_path = os.path.join(folder, "image.jpg")
img2_path = os.path.join(folder, "new image.jpg")

img1 = iio.imread(img1_path)
img2 = iio.imread(img2_path)

fig, axs = plt.subplots(1, 2, figsize=(10, 5))

axs[0].imshow(img1)
axs[0].set_title("Перше зображення")
axs[0].axis("off")

axs[1].imshow(img2)
axs[1].set_title("Друге зображення")
axs[1].axis("off")

plt.tight_layout()
plt.show()
        </code></pre>
        <h3>3. Читання кадрів з GIF</h3>
        <pre><code>
import imageio.v3 as iio
import matplotlib.pyplot as plt

gif_path = r"E:\NewFolder\GIF.gif"

frames = list(iio.imiter(gif_path))

plt.imshow(frames[0])
plt.title("Перший кадр GIF")
plt.axis("off")
plt.show()

print("Кількість кадрів:", len(frames)) 
        </code></pre>
        <h3>4. Запис відео з кількох зображень</h3>
        <pre><code>
import imageio.v3 as iio
import os
from PIL import Image

folder = r"E:\NewFolder"

filenames = ["image.jpg", "new image.jpg", "image.jpg", "new image.jpg"]

target_size = (240, 240)

images = []
for name in filenames:
    path = os.path.join(folder, name)
    img = Image.open(path).resize(target_size)
    images.append(img)

output_path = os.path.join(folder, "output_video.mp4")
iio.imwrite(output_path, images, fps=1)

print(f"Відео збережено: {output_path}")

os.startfile(output_path)
        </code></pre>
        <h3>5. Читання відео покадрово</h3>
        <pre><code>
import imageio.v3 as iio
import matplotlib.pyplot as plt
import time

video_path = r"E:\NewFolder\output_video.mp4"

frames = list(iio.imiter(video_path))

print("Кількість кадрів:", len(frames))

for i, frame in enumerate(frames):
    plt.imshow(frame)
    plt.title(f"Кадр {i + 1}")
    plt.axis("off")
    plt.pause(1)
    plt.clf()

plt.close()
        </code></pre>
    </article>

    <h2>Комп'ютерний зір і обробка зображень: PyTorch Vision</h2>
    <article>
        <h3>1. Завантаження зображення та перетворення в тензор</h3>
        <pre><code>
from torchvision import transforms, models
from PIL import Image
import torch
import matplotlib.pyplot as plt

image_path = r"E:\NewFolder\image.jpg"
image = Image.open(image_path)

transform = transforms.ToTensor()
tensor_image = transform(image)

print("Розмір тензора:", tensor_image.shape)

plt.imshow(tensor_image.permute(1, 2, 0))
plt.title("Tensor Image")
plt.axis("off")
plt.show()
        </code></pre>
        <h3>2. Попередня обробка зображення з кількома перетвореннями</h3>
        <pre><code>
from torchvision import transforms
from PIL import Image
import torch
import matplotlib.pyplot as plt

image_path = r"E:\NewFolder\image.jpg"
image = Image.open(image_path)

preprocess = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize(
        mean=[0.485, 0.456, 0.406],
        std=[0.229, 0.224, 0.225]
    )
])

input_tensor = preprocess(image)
input_batch = input_tensor.unsqueeze(0)

print("Форма обробленого тензора:", input_batch.shape)

unnormalize = transforms.Normalize(
    mean=[-0.485 / 0.229, -0.456 / 0.224, -0.406 / 0.225],
    std=[1 / 0.229, 1 / 0.224, 1 / 0.225]
)
img_for_show = unnormalize(input_tensor).permute(1, 2, 0).clamp(0, 1)

plt.imshow(img_for_show)
plt.title("Оброблене зображення")
plt.axis("off")
plt.show() 
        </code></pre>
        <h3>3. Класифікація зображення за допомогою ResNet-18</h3>
        <pre><code>
from torchvision import transforms, models
from PIL import Image
import torch
import json
import matplotlib.pyplot as plt

image_path = r"E:\NewFolder\image.jpg"
image = Image.open(image_path)

preprocess = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406],
                         std=[0.229, 0.224, 0.225])
])
input_tensor = preprocess(image).unsqueeze(0)

model = models.resnet18(weights="IMAGENET1K_V1")
model.eval()

with torch.no_grad():
    output = model(input_tensor)
    probabilities = torch.nn.functional.softmax(output[0], dim=0)

class_idx_path = "https://raw.githubusercontent.com/pytorch/hub/master/imagenet_classes.txt"
import requests
labels = requests.get(class_idx_path).text.strip().split("\n")

top5_prob, top5_catid = torch.topk(probabilities, 5)
print("🔍 Top-5 передбачень:")
for i in range(5):
    print(f"{labels[top5_catid[i]]}: {top5_prob[i].item():.4f}")

plt.imshow(image)
plt.title("Image for Classification")
plt.axis("off")
plt.show()
        </code></pre>
        <h3>4. Застосування фільтра Sobel до тензора</h3>
        <pre><code>
from torchvision import transforms
from torchvision.transforms import functional as TF
from PIL import Image
import torch
import matplotlib.pyplot as plt
import torchvision.transforms.functional as F
import torchvision.transforms.v2 as T2

image_path = r"E:\NewFolder\image.jpg"
image = Image.open(image_path)

tensor = transforms.ToTensor()(image)

gray_tensor = TF.rgb_to_grayscale(tensor)

plt.imshow(gray_tensor[0], cmap='gray')
plt.title("Grayscale Image")
plt.axis("off")
plt.show()
        </code></pre>
        <h3>5. Аугментація зображення — випадковий поворот, горизонтальне дзеркалення</h3>
        <pre><code>
from torchvision import transforms
from PIL import Image
import matplotlib.pyplot as plt

image_path = r"E:\NewFolder\image.jpg"
image = Image.open(image_path)

augment = transforms.Compose([
    transforms.RandomHorizontalFlip(p=1.0),
    transforms.RandomRotation(degrees=30),
])

augmented = augment(image)

fig, axs = plt.subplots(1, 2, figsize=(10, 5))
axs[0].imshow(image)
axs[0].set_title("Оригінал")
axs[0].axis("off")
axs[1].imshow(augmented)
axs[1].set_title("Аугментоване зображення")
axs[1].axis("off")
plt.tight_layout()
plt.show()
        </code></pre>
    </article>

    <h2>Комп'ютерний зір і обробка зображень: TensorFlow Image</h2>
    <article>
        <h3>1. Завантаження та відображення зображення</h3>
        <pre><code>
import tensorflow as tf
import matplotlib.pyplot as plt

image_path = r"E:\NewFolder\image.jpg"
image = tf.io.read_file(image_path)
image = tf.image.decode_jpeg(image, channels=3)

plt.imshow(image.numpy())
plt.title("Завантажене зображення")
plt.axis("off")
plt.show()
        </code></pre>
        <h3>2. Масштабування та нормалізація зображення</h3>
        <pre><code>
import tensorflow as tf
import matplotlib.pyplot as plt

image_path = r"E:\NewFolder\image.jpg"
image = tf.io.read_file(image_path)
image = tf.image.decode_jpeg(image, channels=3)

image = tf.image.resize(image, [324, 324])
image = tf.cast(image, tf.float32) / 255.0

plt.imshow(image.numpy())
plt.title("Масштабоване і нормалізоване зображення")
plt.axis("off")
plt.show()
        </code></pre>
        <h3>3. Аугментація зображення</h3>
        <pre><code>
import tensorflow as tf
import matplotlib.pyplot as plt

image_path = r"E:\NewFolder\image.jpg"
image = tf.io.read_file(image_path)
image = tf.image.decode_jpeg(image, channels=3)

aug_image = tf.image.random_flip_left_right(image)
aug_image = tf.image.random_brightness(aug_image, max_delta=0.1)

plt.imshow(aug_image.numpy())
plt.title("Аугментоване зображення")
plt.axis("off")
plt.show()
        </code></pre>
        <h3>4. Підготовка зображення для моделі MobileNetV2</h3>
        <pre><code>
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.applications.mobilenet_v2 import preprocess_input

image_path = r"E:\NewFolder\image.jpg"
image = tf.io.read_file(image_path)
image = tf.image.decode_jpeg(image, channels=3)

image = tf.image.resize(image, [224, 224])
image = tf.cast(image, tf.float32)

input_tensor = preprocess_input(image)

input_tensor = tf.expand_dims(input_tensor, axis=0)

print("Форма тензора:", input_tensor.shape)
        </code></pre>
        <h3>5. Класифікація зображення з MobileNetV2</h3>
        <pre><code>
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.applications.mobilenet_v2 import preprocess_input, decode_predictions

image_path = r"E:\NewFolder\image.jpg"
image = tf.io.read_file(image_path)
image = tf.image.decode_jpeg(image, channels=3)
image = tf.image.resize(image, [224, 224])
image = tf.cast(image, tf.float32)

input_tensor = preprocess_input(image)
input_tensor = tf.expand_dims(input_tensor, axis=0)

model = MobileNetV2(weights="imagenet")

preds = model.predict(input_tensor)

decoded = decode_predictions(preds, top=3)[0]
for i, (id, label, score) in enumerate(decoded):
    print(f"{i+1}. {label}: {score:.2%}")
        </code></pre>
    </article>

    <h2>Графічні інтерфейси користувача (GUI): Tkinter</h2>
    <article>
        <h3>1. Просте вікно з кнопкою</h3>
        <pre><code>
import tkinter as tk

def say_hello():
    label.config(text="Привіт, Користувач!")

root = tk.Tk()
root.title("Просте вікно")

label = tk.Label(root, text="Натисни кнопку")
label.pack(pady=10)

btn = tk.Button(root, text="Привіт", command=say_hello)
btn.pack()

root.mainloop()
        </code></pre>
        <h3>2. Текстове поле та введення користувача</h3>
        <pre><code>
import tkinter as tk

def show_text():
    text = entry.get()
    label.config(text=f"Ви ввели: {text}")

root = tk.Tk()
root.title("Введення тексту")

entry = tk.Entry(root)
entry.pack(pady=5)

btn = tk.Button(root, text="Показати", command=show_text)
btn.pack()

label = tk.Label(root, text="")
label.pack()

root.mainloop() 
        </code></pre>
        <h3>3. Обробка подій миші</h3>
        <pre><code>
import tkinter as tk

def on_click(event):
    label.config(text=f"Координати кліку: {event.x}, {event.y}")

root = tk.Tk()
root.title("Обробка кліку")

canvas = tk.Canvas(root, width=300, height=200, bg="lightgray")
canvas.pack()
canvas.bind("<Button-1>", on_click)

label = tk.Label(root, text="")
label.pack()

root.mainloop() 
        </code></pre>
        <h3>4. Створення меню</h3>
        <pre><code>
import tkinter as tk

def show_about():
    label.config(text="Це просте GUI-застосування")

root = tk.Tk()
root.title("Меню")

menubar = tk.Menu(root)
root.config(menu=menubar)

file_menu = tk.Menu(menubar, tearoff=0)
file_menu.add_command(label="Вихід", command=root.quit)
menubar.add_cascade(label="Файл", menu=file_menu)

help_menu = tk.Menu(menubar, tearoff=0)
help_menu.add_command(label="Про програму", command=show_about)
menubar.add_cascade(label="Допомога", menu=help_menu)

label = tk.Label(root, text="Головне вікно")
label.pack(pady=20)

root.mainloop() 
        </code></pre>
        <h3>5. Слайдер для вибору значення</h3>
        <pre><code>
import tkinter as tk

def update_label(value):
    label.config(text=f"Обране значення: {value}")

root = tk.Tk()
root.title("Слайдер")

slider = tk.Scale(root, from_=0, to=100, orient="horizontal", command=update_label)
slider.pack()

label = tk.Label(root, text="Обране значення: 0")
label.pack()

root.mainloop() 
        </code></pre>
    </article>

    <h2>Графічні інтерфейси користувача (GUI): PyQt / PySide</h2>
    <article>
        <h3>1. Просте вікно з кнопкою</h3>
        <pre><code>
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QLabel, QVBoxLayout
import sys

def on_click():
    label.setText("Привіт, Користувач!")

app = QApplication(sys.argv)
window = QWidget()
window.setWindowTitle("Простий інтерфейс")

label = QLabel("Натисни кнопку")
button = QPushButton("Натисни")
button.clicked.connect(on_click)

layout = QVBoxLayout()
layout.addWidget(label)
layout.addWidget(button)
window.setLayout(layout)

window.show()
sys.exit(app.exec_())
        </code></pre>
        <h3>2. Ввід тексту (QLineEdit)</h3>
        <pre><code>
from PyQt5.QtWidgets import QApplication, QWidget, QLineEdit, QLabel, QPushButton, QVBoxLayout
import sys

def on_click():
    user_text = input_field.text()
    label.setText(f"Ви ввели: {user_text}")

app = QApplication(sys.argv)
window = QWidget()
window.setWindowTitle("Ввід тексту")

input_field = QLineEdit()
label = QLabel("")
button = QPushButton("Показати текст")
button.clicked.connect(on_click)

layout = QVBoxLayout()
layout.addWidget(input_field)
layout.addWidget(button)
layout.addWidget(label)
window.setLayout(layout)

window.show()
sys.exit(app.exec_())
        </code></pre>
        <h3>3. Завантаження зображення</h3>
        <pre><code>
from PyQt5.QtWidgets import QApplication, QLabel, QWidget, QVBoxLayout
from PyQt5.QtGui import QPixmap
import sys

app = QApplication(sys.argv)
window = QWidget()
window.setWindowTitle("Зображення")

label = QLabel()
pixmap = QPixmap(r"E:\NewFolder\image.jpg")
label.setPixmap(pixmap)

layout = QVBoxLayout()
layout.addWidget(label)
window.setLayout(layout)

window.show()
sys.exit(app.exec_())
        </code></pre>
        <h3>4. Повідомлення (Message Box)</h3>
        <pre><code>
from PyQt5.QtWidgets import QApplication, QMessageBox, QWidget, QPushButton, QVBoxLayout
import sys

def show_message():
    QMessageBox.information(window, "Привіт", "Це повідомлення для користувача")

app = QApplication(sys.argv)
window = QWidget()
window.setWindowTitle("Повідомлення")

button = QPushButton("Показати повідомлення")
button.clicked.connect(show_message)

layout = QVBoxLayout()
layout.addWidget(button)
window.setLayout(layout)

window.show()
sys.exit(app.exec_())
        </code></pre>
        <h3>5. Слайдер (QSlider)</h3>
        <pre><code>
from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QSlider, QVBoxLayout
from PyQt5.QtCore import Qt
import sys

def update_value(value):
    label.setText(f"Значення: {value}")

app = QApplication(sys.argv)
window = QWidget()
window.setWindowTitle("Слайдер")

slider = QSlider(Qt.Horizontal)
slider.setMinimum(0)
slider.setMaximum(100)
slider.valueChanged.connect(update_value)

label = QLabel("Значення: 0")

layout = QVBoxLayout()
layout.addWidget(slider)
layout.addWidget(label)
window.setLayout(layout)

window.show()
sys.exit(app.exec_())
        </code></pre>
    </article>

    <h2>Графічні інтерфейси користувача (GUI): Kivy</h2>
    <article>
        <h3>1. Кнопка + Лейбл + лічильник</h3>
        <pre><code>
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label

class MyApp(App):
    def build(self):
        self.counter = 0
        layout = BoxLayout(orientation='vertical')
        self.label = Label(text="Натискань: 0")
        btn = Button(text="Додати")

        btn.bind(on_press=self.on_press)
        layout.add_widget(self.label)
        layout.add_widget(btn)
        return layout

    def on_press(self, instance):
        self.counter += 1
        self.label.text = f"Натискань: {self.counter}"

MyApp().run()
        </code></pre>
        <h3>2. Перемикачі (Radio Button / ToggleButton)</h3>
        <pre><code>
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.togglebutton import ToggleButton
from kivy.uix.label import Label

class MyApp(App):
    def build(self):
        layout = BoxLayout(orientation='vertical')
        self.label = Label(text="Оберіть колір:")
        layout.add_widget(self.label)

        for color in ['Red', 'Green', 'Blue']:
            btn = ToggleButton(text=color, group='color')
            btn.bind(on_press=self.on_toggle)
            layout.add_widget(btn)

        return layout

    def on_toggle(self, instance):
        self.label.text = f"Обрано: {instance.text}"

MyApp().run()
        </code></pre>
        <h3>3. Чекбокси</h3>
        <pre><code>
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.checkbox import CheckBox
from kivy.uix.label import Label

class MyApp(App):
    def build(self):
        layout = BoxLayout(orientation='horizontal', spacing=10)
        self.label = Label(text="Вибрано: Ні")

        self.checkbox = CheckBox()
        self.checkbox.bind(active=self.on_checkbox_active)

        layout.add_widget(self.checkbox)
        layout.add_widget(self.label)
        return layout

    def on_checkbox_active(self, checkbox, value):
        self.label.text = "Вибрано: Так" if value else "Вибрано: Ні"

MyApp().run()
        </code></pre>
        <h3>4. Слайдер (Slider)</h3>
        <pre><code>
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.slider import Slider
from kivy.uix.label import Label

class MyApp(App):
    def build(self):
        layout = BoxLayout(orientation='vertical')
        self.label = Label(text="Значення: 0")
        slider = Slider(min=0, max=100, value=0)
        slider.bind(value=self.on_value_change)

        layout.add_widget(self.label)
        layout.add_widget(slider)
        return layout

    def on_value_change(self, instance, value):
        self.label.text = f"Значення: {int(value)}"

MyApp().run()
        </code></pre>
        <h3>5. Вивід спливаючого повідомлення (Popup)</h3>
        <pre><code>
from kivy.app import App
from kivy.uix.popup import Popup
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.boxlayout import BoxLayout

class MyApp(App):
    def build(self):
        layout = BoxLayout()
        btn = Button(text="Показати повідомлення")
        btn.bind(on_press=self.show_popup)
        layout.add_widget(btn)
        return layout

    def show_popup(self, instance):
        popup = Popup(title="Важливо!",
                      content=Label(text="Це спливаюче вікно"),
                      size_hint=(None, None), size=(300, 200))
        popup.open()

MyApp().run()
        </code></pre>
    </article>

    <h2>Графічні інтерфейси користувача (GUI): wxPython</h2>
    <article>
        <h3>1. Вікно з кількома кнопками</h3>
        <pre><code>
import wx

class CounterApp(wx.Frame):
    def __init__(self):
        super().__init__(None, title="Лічильник", size=(300, 200))
        panel = wx.Panel(self)

        self.count = 0

        self.label = wx.StaticText(panel, label="Значення: 0", pos=(30, 30))
        inc_btn = wx.Button(panel, label="Збільшити", pos=(30, 60))
        dec_btn = wx.Button(panel, label="Зменшити", pos=(150, 60))

        inc_btn.Bind(wx.EVT_BUTTON, self.increment)
        dec_btn.Bind(wx.EVT_BUTTON, self.decrement)

    def increment(self, event):
        self.count += 1
        self.label.SetLabel(f"Значення: {self.count}")

    def decrement(self, event):
        self.count -= 1
        self.label.SetLabel(f"Значення: {self.count}")

app = wx.App(False)
frame = CounterApp()
frame.Show()
app.MainLoop()
        </code></pre>
        <h3>2. Програма з вкладками (Notebook)</h3>
        <pre><code>
import wx

class TabApp(wx.Frame):
    def __init__(self):
        super().__init__(None, title="Вкладки", size=(400, 300))
        notebook = wx.Notebook(self)

        panel1 = wx.Panel(notebook)
        wx.StaticText(panel1, label="Вміст першої вкладки", pos=(20, 20))

        panel2 = wx.Panel(notebook)
        wx.StaticText(panel2, label="Вміст другої вкладки", pos=(20, 20))

        notebook.AddPage(panel1, "Вкладка 1")
        notebook.AddPage(panel2, "Вкладка 2")

app = wx.App(False)
frame = TabApp()
frame.Show()
app.MainLoop()
        </code></pre>
        <h3>3. Завантаження зображення та його показ</h3>
        <pre><code>
import wx

class ImageViewer(wx.Frame):
    def __init__(self):
        super().__init__(None, title="Перегляд зображення", size=(500, 400))
        panel = wx.Panel(self)
        self.bitmap = wx.StaticBitmap(panel)

        btn = wx.Button(panel, label="Вибрати зображення", pos=(20, 20))
        btn.Bind(wx.EVT_BUTTON, self.on_open)

        self.sizer = wx.BoxSizer(wx.VERTICAL)
        self.sizer.Add(btn, 0, wx.ALL, 5)
        self.sizer.Add(self.bitmap, 1, wx.EXPAND | wx.ALL, 5)
        panel.SetSizer(self.sizer)

    def on_open(self, event):
        with wx.FileDialog(self, "Вибрати зображення", wildcard="*.jpg;*.png;*.bmp",
                           style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST) as dialog:
            if dialog.ShowModal() == wx.ID_CANCEL:
                return
            path = dialog.GetPath()
            img = wx.Image(path, wx.BITMAP_TYPE_ANY).Scale(400, 300)
            self.bitmap.SetBitmap(wx.Bitmap(img))
            self.Layout()

app = wx.App(False)
frame = ImageViewer()
frame.Show()
app.MainLoop()
        </code></pre>
        <h3>4. Ввід, обробка тексту і збереження у файл</h3>
        <pre><code>
import wx

class TextEditor(wx.Frame):
    def __init__(self):
        super().__init__(None, title="Текстовий редактор", size=(500, 400))
        panel = wx.Panel(self)

        self.text_ctrl = wx.TextCtrl(panel, style=wx.TE_MULTILINE)
        save_btn = wx.Button(panel, label="Зберегти текст")

        save_btn.Bind(wx.EVT_BUTTON, self.on_save)

        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.text_ctrl, 1, wx.EXPAND | wx.ALL, 5)
        sizer.Add(save_btn, 0, wx.ALIGN_CENTER | wx.ALL, 5)

        panel.SetSizer(sizer)

    def on_save(self, event):
        with wx.FileDialog(self, "Зберегти файл", wildcard="Текст (*.txt)|*.txt",
                           style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as dialog:
            if dialog.ShowModal() == wx.ID_CANCEL:
                return
            path = dialog.GetPath()
            with open(path, 'w', encoding='utf-8') as file:
                file.write(self.text_ctrl.GetValue())

app = wx.App(False)
frame = TextEditor()
frame.Show()
app.MainLoop()
        </code></pre>
        <h3>5. Програма з Progress Bar</h3>
        <pre><code>
import wx
import time
import threading

class ProgressBarFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title="Прогрес", size=(400, 150))
        panel = wx.Panel(self)

        self.gauge = wx.Gauge(panel, range=100, size=(300, 25), pos=(50, 30))
        self.button = wx.Button(panel, label="Старт", pos=(150, 70))
        self.button.Bind(wx.EVT_BUTTON, self.on_start)

    def on_start(self, event):
        self.button.Disable()
        threading.Thread(target=self.run_progress).start()

    def run_progress(self):
        for i in range(101):
            wx.CallAfter(self.gauge.SetValue, i)
            time.sleep(0.05)
        wx.CallAfter(self.button.Enable)

app = wx.App(False)
frame = ProgressBarFrame()
frame.Show()
app.MainLoop()
        </code></pre>
    </article>

    <h2>Графічні інтерфейси користувача (GUI): PyGTK</h2>
    <article>
        <h3>1. Зображення + кнопка для його заміни</h3>
        <pre><code>
import gi
gi.require_version("Gtk", "3.0")
from gi.repository import Gtk

class ImageApp(Gtk.Window):
    def __init__(self):
        super().__init__(title="Зображення у GTK")
        self.set_default_size(400, 300)

        self.box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.add(self.box)

        self.image_path_1 = r"E:\NewFolder\image.jpg"
        self.image_path_2 = r"E:\NewFolder\new image.jpg"

        self.image = Gtk.Image.new_from_file(self.image_path_1)
        self.box.pack_start(self.image, True, True, 0)

        self.button = Gtk.Button(label="Змінити зображення")
        self.button.connect("clicked", self.change_image)
        self.box.pack_start(self.button, False, False, 0)

    def change_image(self, widget):
        self.image.set_from_file(self.image_path_2)

win = ImageApp()
win.connect("destroy", Gtk.main_quit)
win.show_all()
Gtk.main()
        </code></pre>
        <h3>2. Таблиця зі списком (TreeView)</h3>
        <pre><code>
import gi
gi.require_version("Gtk", "3.0")
from gi.repository import Gtk

class TreeViewExample(Gtk.Window):
    def __init__(self):
        super().__init__(title="Список студентів")
        self.set_default_size(300, 200)

        self.store = Gtk.ListStore(str, int)
        self.store.append(["Денис", 21])
        self.store.append(["Олена", 19])
        self.store.append(["Ігор", 22])

        self.view = Gtk.TreeView(model=self.store)

        for i, column_title in enumerate(["Ім'я", "Вік"]):
            renderer = Gtk.CellRendererText()
            column = Gtk.TreeViewColumn(column_title, renderer, text=i)
            self.view.append_column(column)

        scroll = Gtk.ScrolledWindow()
        scroll.add(self.view)
        self.add(scroll)

win = TreeViewExample()
win.connect("destroy", Gtk.main_quit)
win.show_all()
Gtk.main()
        </code></pre>
        <h3>3. Вибір файлу та відображення імені</h3>
        <pre><code>
import gi
gi.require_version("Gtk", "3.0")
from gi.repository import Gtk

class FileChooserExample(Gtk.Window):
    def __init__(self):
        super().__init__(title="Вибір файлу")

        self.set_default_size(400, 100)
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.add(box)

        self.label = Gtk.Label(label="Файл ще не вибрано")
        box.pack_start(self.label, True, True, 0)

        button = Gtk.Button(label="Вибрати файл")
        button.connect("clicked", self.open_dialog)
        box.pack_start(button, False, False, 0)

    def open_dialog(self, widget):
        dialog = Gtk.FileChooserDialog(
            title="Оберіть файл",
            parent=self,
            action=Gtk.FileChooserAction.OPEN,
        )
        dialog.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
                           Gtk.STOCK_OPEN, Gtk.ResponseType.OK)

        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            filename = dialog.get_filename()
            self.label.set_text(f"Обраний файл: {filename}")

        dialog.destroy()

win = FileChooserExample()
win.connect("destroy", Gtk.main_quit)
win.show_all()
Gtk.main()
        </code></pre>
        <h3>4. Перемикачі (ToggleButton) + логіка</h3>
        <pre><code>
import gi
gi.require_version("Gtk", "3.0")
from gi.repository import Gtk

class ToggleButtonExample(Gtk.Window):
    def __init__(self):
        super().__init__(title="Перемикачі")
        self.set_default_size(300, 150)

        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.add(box)

        self.toggle1 = Gtk.ToggleButton(label="Опція 1")
        self.toggle1.connect("toggled", self.on_toggled)
        box.pack_start(self.toggle1, True, True, 0)

        self.toggle2 = Gtk.ToggleButton(label="Опція 2")
        self.toggle2.connect("toggled", self.on_toggled)
        box.pack_start(self.toggle2, True, True, 0)

        self.label = Gtk.Label(label="Статус: ---")
        box.pack_start(self.label, True, True, 0)

    def on_toggled(self, button):
        states = []
        if self.toggle1.get_active():
            states.append("Опція 1")
        if self.toggle2.get_active():
            states.append("Опція 2")
        self.label.set_text(f"Статус: {', '.join(states) or '---'}")

win = ToggleButtonExample()
win.connect("destroy", Gtk.main_quit)
win.show_all()
Gtk.main()
        </code></pre>
        <h3>5. Вікно з прогрес-баром (імітація процесу)</h3>
        <pre><code>
import gi
import time
gi.require_version("Gtk", "3.0")
from gi.repository import Gtk, GLib

class ProgressBarExample(Gtk.Window):
    def __init__(self):
        super().__init__(title="Прогрес бар")
        self.set_default_size(300, 100)

        self.progressbar = Gtk.ProgressBar()
        self.add(self.progressbar)

        GLib.timeout_add(100, self.on_timeout)

    def on_timeout(self):
        new_val = self.progressbar.get_fraction() + 0.01
        if new_val > 1.0:
            new_val = 0.0
        self.progressbar.set_fraction(new_val)
        self.progressbar.set_text(f"{int(new_val * 100)}%")
        return True  # щоб не зупиняти таймер

win = ProgressBarExample()
win.connect("destroy", Gtk.main_quit)
win.show_all()
Gtk.main()
        </code></pre>
    </article>

    <h2>Наукова візуалізація: Matplotlib</h2>
    <article>
        <h3>1. Кілька функцій на одному графіку</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(0, 2*np.pi, 200)
y1 = np.sin(x)
y2 = np.cos(x)
y3 = np.sin(2*x)

plt.figure(figsize=(10, 5))
plt.plot(x, y1, label='sin(x)', linewidth=2)
plt.plot(x, y2, label='cos(x)', linewidth=2)
plt.plot(x, y3, label='sin(2x)', linestyle='--', linewidth=2)
plt.title('Графіки тригонометричних функцій')
plt.xlabel('x')
plt.ylabel('Значення')
plt.legend()
plt.grid(True)
plt.show()
        </code></pre>
        <h3>2. Гістограма з нормальним розподілом</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

data = np.random.normal(loc=0, scale=1, size=1000)

plt.figure(figsize=(8, 5))
plt.hist(data, bins=30, density=True, color='skyblue', edgecolor='black')
plt.title('Гістограма нормального розподілу')
plt.xlabel('Значення')
plt.ylabel('Щільність ймовірності')
plt.grid(True)
plt.show()
        </code></pre>
        <h3>3. Теплова карта (heatmap)</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

data = np.random.rand(10, 10)

plt.figure(figsize=(6, 5))
plt.imshow(data, cmap='viridis', interpolation='nearest')
plt.colorbar(label="Інтенсивність")
plt.title('Теплова карта')
plt.show()
        </code></pre>
        <h3>4. 3D-поверхня</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(figsize=(10, 6))
ax = fig.add_subplot(111, projection='3d')

X = np.linspace(-5, 5, 50)
Y = np.linspace(-5, 5, 50)
X, Y = np.meshgrid(X, Y)
Z = np.sin(np.sqrt(X**2 + Y**2))

surf = ax.plot_surface(X, Y, Z, cmap='plasma')
fig.colorbar(surf, ax=ax, shrink=0.5, aspect=10)
ax.set_title('3D поверхня: sin(√(x² + y²))')
plt.show()
        </code></pre>
        <h3>5. Векторне поле (Quiver plot)</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(-2, 2, 20)
y = np.linspace(-2, 2, 20)
X, Y = np.meshgrid(x, y)
U = -Y
V = X

plt.figure(figsize=(6, 6))
plt.quiver(X, Y, U, V)
plt.title('Векторне поле: обертання')
plt.xlabel('X')
plt.ylabel('Y')
plt.grid(True)
plt.axis('equal')
plt.show()
        </code></pre>
    </article>

    <h2>Наукова візуалізація: Mayavi</h2>
    <article>
        <h3>1. 3D-поверхня (mesh surface)</h3>
        <pre><code>
from mayavi import mlab
import numpy as np

x, y = np.mgrid[-3:3:100j, -3:3:100j]
z = np.sin(x**2 + y**2)

mlab.surf(x, y, z, colormap='Spectral')
mlab.title("3D-surface: sin(x² + y²)")
mlab.show()
        </code></pre>
        <h3>2. Об'ємна візуалізація (volume rendering)</h3>
        <pre><code>
from mayavi import mlab
import numpy as np

x, y, z = np.ogrid[-10:10:100j, -10:10:100j, -10:10:100j]
data = np.sin(x*y*z) / (x*y*z + 1e-9)

src = mlab.pipeline.scalar_field(data)
mlab.pipeline.volume(src)
mlab.title("Volumetric visualization")
mlab.show()
        </code></pre>
        <h3>3. Векторне поле (візуалізація потоків)</h3>
        <pre><code>
from mayavi import mlab
import numpy as np

x, y, z = np.mgrid[-2:2:20j, -2:2:20j, -2:2:20j]
u = -y
v = x
w = np.zeros_like(z)

mlab.quiver3d(x, y, z, u, v, w, scale_factor=0.5)
mlab.title("Vector field")
mlab.show()
        </code></pre>
        <h3>4. Contour3D (ізолінії в 3D)</h3>
        <pre><code>
from mayavi import mlab
import numpy as np

x, y, z = np.ogrid[-3:3:60j, -3:3:60j, -3:3:60j]
scalars = np.sin(x*y*z)

mlab.contour3d(scalars, contours=8, opacity=0.5)
mlab.title("Contour3D: sin(x*y*z)")
mlab.show()
        </code></pre>
        <h3>5. Parametric 3D-спіраль</h3>
        <pre><code>
from mayavi import mlab
import numpy as np

t = np.linspace(0, 4 * np.pi, 1000)
x = np.sin(t)
y = np.cos(t)
z = t

mlab.plot3d(x, y, z, t, tube_radius=0.05, colormap='Accent')
mlab.title("3D-spiral")
mlab.show()
        </code></pre>
    </article>

    <h2>Наукова візуалізація: SciPy Visualization</h2>
    <article>
        <h3>1. Візуалізація рішення диференціального рівняння (ODE)</h3>
        <pre><code>
import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

def dydt(t, y):
    return -2 * y + np.sin(t)

sol = solve_ivp(dydt, [0, 10], [1.0], t_eval=np.linspace(0, 10, 200))

plt.plot(sol.t, sol.y[0], label="dy/dt = -2y + sin(t)")
plt.xlabel("Час")
plt.ylabel("y(t)")
plt.title("Розв'язок ODE")
plt.grid()
plt.legend()
plt.show()
        </code></pre>
        <h3>2. 2D-фур'є-аналіз зображення + спектр</h3>
        <pre><code>
import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft2, fftshift
from scipy.misc import face

img = face(gray=True)[::4, ::4]

fft_image = fftshift(fft2(img))
magnitude = np.log(np.abs(fft_image) + 1)

plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.imshow(img, cmap='gray')
plt.title("Оригінальне зображення")

plt.subplot(1, 2, 2)
plt.imshow(magnitude, cmap='inferno')
plt.title("Спектр (FFT)")
plt.colorbar()
plt.show()
        </code></pre>
        <h3>3. Інтерполяція функції методом кубічних сплайнів</h3>
        <pre><code>
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import CubicSpline

x = np.linspace(0, 10, 10)
y = np.sin(x)

cs = CubicSpline(x, y)
x_fine = np.linspace(0, 10, 500)
y_fine = cs(x_fine)

plt.plot(x, y, 'o', label='Вузли')
plt.plot(x_fine, y_fine, label='Кубічний сплайн')
plt.legend()
plt.title("Інтерполяція функції")
plt.grid()
plt.show()
        </code></pre>
        <h3>4. 3D-візуалізація функції (SciPy + matplotlib)</h3>
        <pre><code>
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

x = y = np.linspace(-3, 3, 100)
X, Y = np.meshgrid(x, y)
Z = np.sin(np.sqrt(X**2 + Y**2))

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
surf = ax.plot_surface(X, Y, Z, cmap='viridis')
fig.colorbar(surf)
ax.set_title("3D-графік функції: sin(sqrt(x² + y²))")
plt.show()
        </code></pre>
        <h3>5. Карта рівнів потенціалу (рішення рівняння Лапласа)</h3>
        <pre><code>
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import laplace

N = 100
V = np.zeros((N, N))
V[25:75, 25] = 1
V[25:75, 75] = -1

for _ in range(500):
    V[1:-1, 1:-1] = 0.25 * (V[:-2, 1:-1] + V[2:, 1:-1] +
                             V[1:-1, :-2] + V[1:-1, 2:])
    V[25:75, 25] = 1
    V[25:75, 75] = -1

plt.imshow(V, cmap='coolwarm')
plt.colorbar(label="Потенціал")
plt.title("Карта потенціалу (Лаплас)")
plt.show()
        </code></pre>
    </article>

    <h2>Наукова візуалізація: Cartopy</h2>
    <article>
        <h3>1. Глобальна карта з різними проекціями</h3>
        <pre><code>
import matplotlib.pyplot as plt
import cartopy.crs as ccrs

projections = [ccrs.PlateCarree(), ccrs.Mollweide(), ccrs.Orthographic(0, 0)]

for i, proj in enumerate(projections):
    fig = plt.figure(figsize=(6, 4))
    ax = plt.axes(projection=proj)
    ax.set_global()
    ax.coastlines()
    ax.gridlines(draw_labels=True)
    ax.set_title(f"Проекція: {proj.__class__.__name__}", fontsize=12)
    plt.savefig(f"map_projection_{i}.png")
    plt.close()
        </code></pre>
        <h3>2. Відображення траєкторії супутника над Землею</h3>
        <pre><code>
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import numpy as np

lons = np.linspace(-180, 180, 400)
lats = 20 * np.sin(np.radians(lons))

fig = plt.figure(figsize=(10, 5))
ax = plt.axes(projection=ccrs.PlateCarree())
ax.set_global()
ax.coastlines()
ax.gridlines(draw_labels=True)
ax.plot(lons, lats, 'r', transform=ccrs.Geodetic(), label='Супутник')
ax.set_title("Траєкторія супутника")
ax.legend()
plt.savefig("satellite_path.png")
plt.close()
        </code></pre>
        <h3>3. Теплова карта температур на світовій мапі</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np
import cartopy.crs as ccrs

lons = np.linspace(-180, 180, 100)
lats = np.linspace(-90, 90, 50)
lon2d, lat2d = np.meshgrid(lons, lats)
temps = 30 * np.cos(np.radians(lat2d))  # умовна температура

fig = plt.figure(figsize=(12, 6))
ax = plt.axes(projection=ccrs.PlateCarree())
cf = ax.contourf(lons, lats, temps, 60, transform=ccrs.PlateCarree(), cmap='coolwarm')
ax.coastlines()
ax.set_title("Глобальне розподілення температури")
plt.colorbar(cf, ax=ax, orientation='horizontal')
plt.savefig("temperature_map.png")
plt.close()
        </code></pre>
        <h3>4. Потік вітру: векторне поле на карті</h3>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np
import cartopy.crs as ccrs

lons = np.linspace(-180, 180, 20)
lats = np.linspace(-90, 90, 10)
lon2d, lat2d = np.meshgrid(lons, lats)

u = np.cos(np.radians(lat2d))  # умовна складова вітру
v = np.sin(np.radians(lon2d))

fig = plt.figure(figsize=(12, 6))
ax = plt.axes(projection=ccrs.PlateCarree())
ax.quiver(lons, lats, u, v, transform=ccrs.PlateCarree(), color='blue')
ax.coastlines()
ax.set_title("Векторне поле вітру")
plt.savefig("wind_field.png")
plt.close()
        </code></pre>
        <h3>5. Виділення окремої країни</h3>
        <pre><code>
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature

fig = plt.figure(figsize=(10, 6))
ax = plt.axes(projection=ccrs.PlateCarree())
ax.set_extent([22, 41, 43, 53], crs=ccrs.PlateCarree())  # межі України

ax.coastlines(resolution='10m')
ax.add_feature(cfeature.BORDERS, linestyle=':')
ax.add_feature(cfeature.LAND, edgecolor='black')
ax.add_feature(cfeature.OCEAN)
ax.gridlines(draw_labels=True)

ax.set_title("Карта України")
plt.savefig("ukraine_map.png")
plt.close()
        </code></pre>
    </article>

    <h2>Графіка для ігор: Pygame</h2>
    <article>
        <h3>1. 2D платформер з гравітацією, анімацією та колізією</h3>
        <pre><code>
import pygame
import os

pygame.init()

WIDTH, HEIGHT = 800, 600
win = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("2D Платформер")

clock = pygame.time.Clock()
GRAVITY = 0.5
FPS = 60

player = pygame.Rect(100, 500, 50, 50)
player_vel_y = 0
on_ground = False

platforms = [pygame.Rect(0, 580, 800, 20), pygame.Rect(300, 450, 200, 20), pygame.Rect(600, 350, 150, 20)]

def draw():
    win.fill((30, 30, 30))
    pygame.draw.rect(win, (0, 255, 0), player)
    for plat in platforms:
        pygame.draw.rect(win, (255, 255, 255), plat)
    pygame.display.update()

run = True
while run:
    clock.tick(FPS)
    keys = pygame.key.get_pressed()
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False

    if keys[pygame.K_LEFT]:
        player.x -= 5
    if keys[pygame.K_RIGHT]:
        player.x += 5

    if keys[pygame.K_SPACE] and on_ground:
        player_vel_y = -10
        on_ground = False

    player_vel_y += GRAVITY
    player.y += player_vel_y

    on_ground = False
    for plat in platforms:
        if player.colliderect(plat) and player_vel_y >= 0:
            player.y = plat.y - player.height
            player_vel_y = 0
            on_ground = True

    draw()

pygame.quit()
        </code></pre>
        <h3>2. Гравець і AI переслідувач</h3>
        <pre><code>
import pygame
import math

pygame.init()
win = pygame.display.set_mode((600, 400))
clock = pygame.time.Clock()

player = pygame.Rect(100, 100, 30, 30)
enemy = pygame.Rect(400, 300, 30, 30)
speed = 3

def move_enemy(enemy, player):
    dx, dy = player.x - enemy.x, player.y - enemy.y
    dist = math.hypot(dx, dy)
    if dist > 0:
        dx, dy = dx / dist, dy / dist
        enemy.x += dx * 2
        enemy.y += dy * 2

running = True
while running:
    win.fill((30, 30, 30))
    keys = pygame.key.get_pressed()
    for e in pygame.event.get():
        if e.type == pygame.QUIT:
            running = False

    if keys[pygame.K_LEFT]: player.x -= speed
    if keys[pygame.K_RIGHT]: player.x += speed
    if keys[pygame.K_UP]: player.y -= speed
    if keys[pygame.K_DOWN]: player.y += speed

    move_enemy(enemy, player)

    pygame.draw.rect(win, (0, 255, 0), player)
    pygame.draw.rect(win, (255, 0, 0), enemy)
    pygame.display.flip()
    clock.tick(60)
pygame.quit()
        </code></pre>
        <h3>3. Гра-музикальна реакція – Блок стрибає по нотах</h3>
        <pre><code>
import pygame
import random
import os

pygame.init()
pygame.mixer.init()
screen = pygame.display.set_mode((400, 400))
clock = pygame.time.Clock()

os.chdir(r"E:\NewFolder")

jump_sounds = [
    pygame.mixer.Sound("jump1.wav"),
    pygame.mixer.Sound("jump2.wav"),
    pygame.mixer.Sound("jump3.wav")
]

player = pygame.Rect(180, 300, 40, 40)
velocity = 0
gravity = 0.5
jump_power = -10
on_ground = True

def play_jump():
    sound = random.choice(jump_sounds)
    sound.play()

running = True
while running:
    screen.fill((20, 20, 20))
    for e in pygame.event.get():
        if e.type == pygame.QUIT:
            running = False
    keys = pygame.key.get_pressed()
    if keys[pygame.K_SPACE] and on_ground:
        velocity = jump_power
        on_ground = False
        play_jump()

    velocity += gravity
    player.y += int(velocity)

    if player.y >= 300:
        player.y = 300
        velocity = 0
        on_ground = True

    pygame.draw.rect(screen, (200, 200, 0), player)
    pygame.display.flip()
    clock.tick(60)

pygame.quit()
        </code></pre>
    </article>

    <h2>Графіка для ігор: Pyglet</h2>
    <article>
        <h3>1. Pyglet + OpenGL: 3D-сцена з керуванням камерою</h3>
        <pre><code>
import pyglet
from pyglet.window import key, mouse
from OpenGL.GL import *
from OpenGL.GLU import *
import math
import numpy as np

config = pyglet.gl.Config(double_buffer=True, depth_size=24)
window = pyglet.window.Window(width=800, height=600,
                              caption='FPS 3D Scene',
                              resizable=True,
                              config=config)
window.set_exclusive_mouse(True)

camera_pos = np.array([0.0, 1.8, 5.0])
yaw, pitch = 0.0, 0.0
mouse_sensitivity = 0.15
movement_speed = 5.0
keys_held = set()

scene_objects = []
object_colors = {}


def create_cube(x, y, z, size=1):
    half = size / 2
    vertices = [
        (x - half, y - half, z - half), (x + half, y - half, z - half),
        (x + half, y + half, z - half), (x - half, y + half, z - half),
        (x - half, y - half, z + half), (x + half, y - half, z + half),
        (x + half, y + half, z + half), (x - half, y + half, z + half),
    ]
    return vertices


def draw_cube(vertices, color=(0.7, 0.7, 0.7)):
    glBegin(GL_QUADS)
    glColor3f(*color)

    glVertex3f(*vertices[4])
    glVertex3f(*vertices[5])
    glVertex3f(*vertices[6])
    glVertex3f(*vertices[7])

    glVertex3f(*vertices[1])
    glVertex3f(*vertices[0])
    glVertex3f(*vertices[3])
    glVertex3f(*vertices[2])

    glVertex3f(*vertices[0])
    glVertex3f(*vertices[4])
    glVertex3f(*vertices[7])
    glVertex3f(*vertices[3])

    glVertex3f(*vertices[5])
    glVertex3f(*vertices[1])
    glVertex3f(*vertices[2])
    glVertex3f(*vertices[6])

    glVertex3f(*vertices[3])
    glVertex3f(*vertices[7])
    glVertex3f(*vertices[6])
    glVertex3f(*vertices[2])

    glVertex3f(*vertices[0])
    glVertex3f(*vertices[1])
    glVertex3f(*vertices[5])
    glVertex3f(*vertices[4])

    glEnd()


for i in range(-5, 6):
    for j in range(-5, 6):
        cube = create_cube(i, -0.5, j)
        scene_objects.append(cube)
        object_colors[id(cube)] = (0.7, 0.7, 0.7)

column_positions = [(2, 0, 2), (-2, 0, 2), (2, 0, -2), (-2, 0, -2)]
for x, y, z in column_positions:
    for height in range(3):
        cube = create_cube(x, y + height, z)
        scene_objects.append(cube)
        object_colors[id(cube)] = (0.2, 0.4, 1.0)


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(45, window.width / window.height, 0.1, 100.0)

    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()

    dir_x = math.cos(math.radians(pitch)) * math.sin(math.radians(yaw))
    dir_y = math.sin(math.radians(pitch))
    dir_z = -math.cos(math.radians(pitch)) * math.cos(math.radians(yaw))
    center = camera_pos + np.array([dir_x, dir_y, dir_z])

    gluLookAt(
        *camera_pos,
        *center,
        0.0, 1.0, 0.0
    )

    for obj in scene_objects:
        draw_cube(obj, object_colors.get(id(obj), (1.0, 1.0, 1.0)))


@window.event
def on_resize(width, height):
    glViewport(0, 0, width, height)
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(45, width / height, 0.1, 100.0)
    glMatrixMode(GL_MODELVIEW)
    return pyglet.event.EVENT_HANDLED


@window.event
def on_mouse_motion(x, y, dx, dy):
    global yaw, pitch
    yaw += dx * mouse_sensitivity
    pitch += dy * mouse_sensitivity
    pitch = max(-89.0, min(89.0, pitch))


@window.event
def on_key_press(symbol, modifiers):
    keys_held.add(symbol)
    if symbol == key.ESCAPE:
        pyglet.app.exit()


@window.event
def on_key_release(symbol, modifiers):
    if symbol in keys_held:
        keys_held.remove(symbol)


def check_collision(new_pos):
    for obj in scene_objects:
        cube_center = np.array([(obj[0][0] + obj[1][0]) / 2,
                                (obj[0][1] + obj[3][1]) / 2,
                                (obj[0][2] + obj[4][2]) / 2])
        cube_size = 1.0

        dist = np.linalg.norm(new_pos - cube_center)

        if dist < 1.2:
            return True
    return False


def update(dt):
    global camera_pos

    front = np.array([
        math.cos(math.radians(pitch)) * math.sin(math.radians(yaw)),
        0.0,
        -math.cos(math.radians(pitch)) * math.cos(math.radians(yaw))
    ])
    front /= np.linalg.norm(front)

    right = np.cross(front, np.array([0.0, 1.0, 0.0]))
    right /= np.linalg.norm(right)

    velocity = movement_speed * dt

    if key.W in keys_held:
        new_pos = camera_pos + front * velocity
        if not check_collision(new_pos):
            camera_pos = new_pos

    if key.S in keys_held:
        new_pos = camera_pos - front * velocity
        if not check_collision(new_pos):
            camera_pos = new_pos

    if key.A in keys_held:
        new_pos = camera_pos - right * velocity
        if not check_collision(new_pos):
            camera_pos = new_pos

    if key.D in keys_held:
        new_pos = camera_pos + right * velocity
        if not check_collision(new_pos):
            camera_pos = new_pos

    if key.SPACE in keys_held:
        camera_pos[1] += velocity
    if key.LSHIFT in keys_held:
        camera_pos[1] -= velocity


glEnable(GL_DEPTH_TEST)
glClearColor(0.1, 0.1, 0.1, 1.0)

pyglet.clock.schedule(update)
pyglet.app.run()
        </code></pre>
        <h3>2. RTS-гра (Real-Time Strategy) створенням юнітів і простим AI</h3>
        <pre><code>
import pyglet
from pyglet.window import mouse, key
import numpy as np
import random
import math

window = pyglet.window.Window(800, 600, caption="RTS-гра на Pyglet")
batch = pyglet.graphics.Batch()

unit_speed = 100
enemy_speed = 40

units = []
enemies = []
selected_unit = None


class Unit:
    def __init__(self, x, y):
        self.sprite = pyglet.shapes.Circle(x, y, 10, color=(50, 200, 50), batch=batch)
        self.target = None

    def update(self, dt):
        if self.target:
            dx, dy = self.target[0] - self.sprite.x, self.target[1] - self.sprite.y
            dist = math.hypot(dx, dy)
            if dist < 2:
                self.target = None
                return
            dx, dy = dx / dist, dy / dist
            self.sprite.x += dx * unit_speed * dt
            self.sprite.y += dy * unit_speed * dt

    def is_clicked(self, x, y):
        return math.hypot(self.sprite.x - x, self.sprite.y - y) < self.sprite.radius + 5

    def set_selected(self, selected=True):
        self.sprite.color = (0, 255, 0) if selected else (50, 200, 50)


class Enemy:
    def __init__(self):
        x, y = random.randint(0, 800), 600
        self.sprite = pyglet.shapes.Circle(x, y, 10, color=(200, 50, 50), batch=batch)

    def update(self, dt):
        if units:
            target_unit = min(units, key=lambda u: math.hypot(self.sprite.x - u.sprite.x, self.sprite.y - u.sprite.y))
            dx = target_unit.sprite.x - self.sprite.x
            dy = target_unit.sprite.y - self.sprite.y
            dist = math.hypot(dx, dy)
            if dist > 1:
                dx, dy = dx / dist, dy / dist
                self.sprite.x += dx * enemy_speed * dt
                self.sprite.y += dy * enemy_speed * dt


@window.event
def on_mouse_press(x, y, button, modifiers):
    global selected_unit

    if button == mouse.LEFT:
        selected_unit = None
        for u in units:
            if u.is_clicked(x, y):
                selected_unit = u
                break
        for u in units:
            u.set_selected(u == selected_unit)

    elif button == mouse.RIGHT and selected_unit:
        selected_unit.target = (x, y)


@window.event
def on_key_press(symbol, modifiers):
    if symbol == key.SPACE:
        new_unit = Unit(random.randint(50, 750), random.randint(50, 550))
        units.append(new_unit)
    if symbol == key.E:
        enemies.append(Enemy())
    if symbol == key.ESCAPE:
        pyglet.app.exit()


@window.event
def on_draw():
    window.clear()
    batch.draw()


def update(dt):
    for u in units:
        u.update(dt)
    for e in enemies:
        e.update(dt)

    to_remove_units = []
    to_remove_enemies = []

    attack_map = {}

    for e in enemies:
        for u in units:
            dist = math.hypot(e.sprite.x - u.sprite.x, e.sprite.y - u.sprite.y)
            if dist < 15:
                if u not in attack_map:
                    attack_map[u] = []
                attack_map[u].append(e)

    for u, attackers in attack_map.items():
        if len(attackers) == 1:
            to_remove_units.append(u)
            to_remove_enemies.append(attackers[0])
        elif len(attackers) > 1:
            to_remove_units.append(u)

    for u in to_remove_units:
        if u in units:
            units.remove(u)
            u.sprite.delete()
    for e in to_remove_enemies:
        if e in enemies:
            enemies.remove(e)
            e.sprite.delete()

pyglet.clock.schedule_interval(update, 1 / 60.0)
pyglet.app.run()
        </code></pre>
        <h3>3. Ритм-гра в стилі “Guitar Hero”</h3>
        <pre><code>
import pyglet
from pyglet.window import key
import random

window = pyglet.window.Window(800, 600, caption="Rhythm Hero")
batch = pyglet.graphics.Batch()

lanes = ['A', 'S', 'D', 'F']
lane_keys = {
    key.A: 0,
    key.S: 1,
    key.D: 2,
    key.F: 3
}
lane_x_positions = [150, 300, 450, 600]

note_speed = 200
hit_zone_y = 100
hit_tolerance = 30

notes = []
score = 0
font = pyglet.font.load('Arial', 16)


class Note:
    def __init__(self, lane_index):
        self.lane = lane_index
        self.x = lane_x_positions[lane_index]
        self.y = 600
        self.hit = False
        self.sprite = pyglet.shapes.Rectangle(
            self.x - 25, self.y, 50, 20,
            color=(0, 255, 255),
            batch=batch
        )

    def update(self, dt):
        self.y -= note_speed * dt
        self.sprite.y = self.y

    def is_in_hit_zone(self):
        return abs(self.y - hit_zone_y) < hit_tolerance

    def is_missed(self):
        return self.y < hit_zone_y - hit_tolerance


@window.event
def on_draw():
    window.clear()
    batch.draw()

    for i, x in enumerate(lane_x_positions):
        hit_zone = pyglet.shapes.Rectangle(x - 25, hit_zone_y - 10, 50, 20, color=(255, 255, 0))
        hit_zone.draw()

    score_label = pyglet.text.Label(f"Score: {score}", font_size=18, x=10, y=570)
    score_label.draw()

    instruction = pyglet.text.Label("Натискай A S D F вчасно!", x=10, y=540)
    instruction.draw()


@window.event
def on_key_press(symbol, modifiers):
    global score
    if symbol in lane_keys:
        lane = lane_keys[symbol]
        for note in notes:
            if note.lane == lane and note.is_in_hit_zone() and not note.hit:
                note.hit = True
                score += 1
                note.sprite.delete()
                notes.remove(note)
                break


def update(dt):
    for note in notes:
        note.update(dt)

    for note in notes[:]:
        if note.is_missed():
            notes.remove(note)
            note.sprite.delete()


def spawn_note(dt):
    new_lane = random.randint(0, 3)
    notes.append(Note(new_lane))


pyglet.clock.schedule_interval(update, 1 / 60.0)
pyglet.clock.schedule_interval(spawn_note, 1.0)

pyglet.app.run()
        </code></pre>
    </article>

    <h2>Графіка для ігор: Arcade</h2>
    <article>
        <h3>1. Shoot'em up — гра в стилі космічного шутера</h3>
        <pre><code>
import arcade
import random
import os

SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
SCREEN_TITLE = "Space Shooter — Arcade"

PLAYER_SPEED = 5
BULLET_SPEED = 10
ENEMY_SPEED = 2
POWERUP_SPEED = 1


class SpaceShooter(arcade.Window):
    def __init__(self):
        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)

        self.player_sprite = None
        self.player_list = None
        self.bullet_list = None
        self.enemy_list = None
        self.powerup_list = None

        self.score = 0
        self.lives = 3
        self.fire_power = 1

        self.assets_path = r"C:\Users\38067\Desktop\assets"

        arcade.set_background_color(arcade.color.BLACK)

    def setup(self):
        self.player_list = arcade.SpriteList()
        self.bullet_list = arcade.SpriteList()
        self.enemy_list = arcade.SpriteList()
        self.powerup_list = arcade.SpriteList()

        self.player_sprite = arcade.Sprite(os.path.join(self.assets_path, "player.png"))
        self.player_sprite.scale = 0.5
        self.player_sprite.center_x = SCREEN_WIDTH // 2
        self.player_sprite.center_y = 50
        self.player_list.append(self.player_sprite)

        arcade.schedule(self.spawn_enemy, 1.0)
        arcade.schedule(self.spawn_powerup, 10.0)

    def spawn_enemy(self, delta_time):
        enemy = arcade.Sprite(os.path.join(self.assets_path, "enemy.png"))
        enemy.scale = 0.5
        enemy.center_x = random.randint(20, SCREEN_WIDTH - 20)
        enemy.center_y = SCREEN_HEIGHT + 30
        enemy.change_y = -ENEMY_SPEED
        self.enemy_list.append(enemy)

    def spawn_powerup(self, delta_time):
        power = arcade.Sprite(os.path.join(self.assets_path, "powerup.png"))
        power.scale = 0.2
        power.center_x = random.randint(20, SCREEN_WIDTH - 20)
        power.center_y = SCREEN_HEIGHT + 30
        power.change_y = -POWERUP_SPEED
        self.powerup_list.append(power)

    def on_draw(self):
        self.clear()
        self.player_list.draw()
        self.bullet_list.draw()
        self.enemy_list.draw()
        self.powerup_list.draw()

        arcade.draw_text(f"Score: {self.score}", 10, 570, arcade.color.WHITE, 16)
        arcade.draw_text(f"Lives: {self.lives}", 10, 550, arcade.color.WHITE, 16)

    def on_update(self, delta_time):
        self.player_list.update()
        self.bullet_list.update()
        self.enemy_list.update()
        self.powerup_list.update()

        for bullet in self.bullet_list:
            if bullet.top > SCREEN_HEIGHT:
                bullet.remove_from_sprite_lists()

        for bullet in self.bullet_list:
            hit_list = arcade.check_for_collision_with_list(bullet, self.enemy_list)
            if hit_list:
                bullet.remove_from_sprite_lists()
                for enemy in hit_list:
                    enemy.remove_from_sprite_lists()
                    self.score += 1

        for enemy in self.enemy_list:
            if arcade.check_for_collision(enemy, self.player_sprite):
                enemy.remove_from_sprite_lists()
                self.lives -= 1
                if self.lives <= 0:
                    arcade.close_window()

        for power in self.powerup_list:
            if arcade.check_for_collision(power, self.player_sprite):
                power.remove_from_sprite_lists()
                self.fire_power = 2
                arcade.schedule(self.reset_power, 10.0)

    def reset_power(self, dt):
        self.fire_power = 1
        arcade.unschedule(self.reset_power)

    def on_key_press(self, key, modifiers):
        if key == arcade.key.LEFT:
            self.player_sprite.change_x = -PLAYER_SPEED
        elif key == arcade.key.RIGHT:
            self.player_sprite.change_x = PLAYER_SPEED
        elif key == arcade.key.SPACE:
            self.shoot()

    def on_key_release(self, key, modifiers):
        if key in (arcade.key.LEFT, arcade.key.RIGHT):
            self.player_sprite.change_x = 0

    def shoot(self):
        if self.fire_power == 1:
            bullet = arcade.Sprite(os.path.join(self.assets_path, "laser.jpg"))
            bullet.scale = 0.03
            bullet.center_x = self.player_sprite.center_x
            bullet.center_y = self.player_sprite.top
            bullet.change_y = BULLET_SPEED
            bullet.angle = -90
            self.bullet_list.append(bullet)
        elif self.fire_power == 2:
            for offset in [-15, 15]:
                bullet = arcade.Sprite(os.path.join(self.assets_path, "laser.jpg"))
                bullet.scale = 0.03 
                bullet.center_x = self.player_sprite.center_x + offset
                bullet.center_y = self.player_sprite.top
                bullet.change_y = BULLET_SPEED
                bullet.angle = -90
                self.bullet_list.append(bullet)


if __name__ == "__main__":
    game = SpaceShooter()
    game.setup()
    arcade.run()
        </code></pre>
        <h3>2. Tower Defense</h3>
        <pre><code>
import arcade
import math
import random

SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
SCREEN_TITLE = "Tower Defense"

ENEMY_SPEED = 10
BULLET_SPEED = 15
TOWER_RANGE = 150
TOWER_FIRE_RATE = 0.8

LIVES = 5


class Enemy(arcade.SpriteSolidColor):
    def __init__(self, path_points):
        super().__init__(20, 20, arcade.color.RED)
        self.path = path_points
        self.path_index = 0
        self.center_x, self.center_y = self.path[0]
        self.health = 100
        self.alive = True

    def on_update(self, delta_time):
        if not self.alive:
            return

        if self.path_index + 1 >= len(self.path):
            return

        dest_x, dest_y = self.path[self.path_index + 1]
        dx = dest_x - self.center_x
        dy = dest_y - self.center_y
        distance = math.hypot(dx, dy)

        movement_distance = ENEMY_SPEED * delta_time

        if distance <= movement_distance:
            self.center_x = dest_x
            self.center_y = dest_y
            self.path_index += 1
        else:
            dx /= distance
            dy /= distance
            self.center_x += dx * movement_distance
            self.center_y += dy * movement_distance


class Tower(arcade.SpriteSolidColor):
    def __init__(self, x, y):
        super().__init__(40, 40, arcade.color.BLUE)
        self.center_x = x
        self.center_y = y
        self.time_since_last_shot = 0

    def on_update(self, delta_time):
        self.time_since_last_shot += delta_time

    def can_fire(self):
        return self.time_since_last_shot >= TOWER_FIRE_RATE

    def reset_fire_timer(self):
        self.time_since_last_shot = 0


class Bullet(arcade.SpriteSolidColor):
    def __init__(self, x, y, target: arcade.Sprite):
        super().__init__(5, 5, arcade.color.YELLOW)
        self.center_x = x
        self.center_y = y
        self.target = target

    def on_update(self, delta_time):
        if not self.target or not self.target.alive:
            self.remove_from_sprite_lists()
            return

        dx = self.target.center_x - self.center_x
        dy = self.target.center_y - self.center_y
        dist = math.hypot(dx, dy)

        movement_distance = BULLET_SPEED * delta_time

        if dist <= movement_distance:
            self.remove_from_sprite_lists()
            return
        else:
            dx /= dist
            dy /= dist
            self.center_x += dx * movement_distance
            self.center_y += dy * movement_distance


class TowerDefenseGame(arcade.Window):
    def __init__(self):
        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)
        arcade.set_background_color(arcade.color.DARK_GREEN)

        self.enemy_list = arcade.SpriteList()
        self.tower_list = arcade.SpriteList()
        self.bullet_list = arcade.SpriteList()

        self.path = [
            (0, 300), (200, 300), (200, 500),
            (600, 500), (600, 100), (800, 100)
        ]

        self.spawn_timer = 0
        self.spawn_interval = 2.5 / 3
        self.lives = LIVES
        self.score = 0

    def on_draw(self):
        self.clear()

        # Draw path
        for i in range(len(self.path) - 1):
            arcade.draw_line(*self.path[i], *self.path[i + 1], arcade.color.LIGHT_GRAY, 5)

        self.enemy_list.draw()
        self.tower_list.draw()
        self.bullet_list.draw()

        arcade.draw_text(f"Lives: {self.lives}", 10, 570, arcade.color.WHITE, 16)
        arcade.draw_text(f"Score: {self.score}", 10, 550, arcade.color.WHITE, 16)

    def on_update(self, delta_time):
        self.spawn_timer += delta_time
        if self.spawn_timer > self.spawn_interval:
            self.spawn_timer = 0
            self.enemy_list.append(Enemy(self.path))

        for tower in self.tower_list:
            tower.on_update(delta_time)

        for enemy in self.enemy_list:
            enemy.on_update(delta_time)

        for bullet in self.bullet_list:
            bullet.on_update(delta_time)

        for enemy in self.enemy_list[:]:
            if enemy.path_index == len(self.path) - 1:
                enemy.remove_from_sprite_lists()
                enemy.alive = False
                self.lives -= 1
                if self.lives <= 0:
                    print("Game Over!")
                    arcade.close_window()

        for tower in self.tower_list:
            if tower.can_fire():
                target_enemy = None
                min_dist = TOWER_RANGE + 1
                for enemy in self.enemy_list:
                    if enemy.alive and enemy.path_index < len(enemy.path) - 1:
                        dist = arcade.get_distance_between_sprites(tower, enemy)
                        if dist <= TOWER_RANGE and dist < min_dist:
                            min_dist = dist
                            target_enemy = enemy

                if target_enemy:
                    bullet = Bullet(tower.center_x, tower.center_y, target_enemy)
                    self.bullet_list.append(bullet)
                    tower.reset_fire_timer()

        for bullet in self.bullet_list[:]:
            hit_enemies = arcade.check_for_collision_with_list(bullet, self.enemy_list)
            if hit_enemies:
                bullet.remove_from_sprite_lists()
                for enemy in hit_enemies:
                    if enemy.alive:
                        enemy.health -= 50
                        if enemy.health <= 0:
                            enemy.remove_from_sprite_lists()
                            enemy.alive = False
                            self.score += 1

    def on_mouse_press(self, x, y, button, modifiers):
        if button == arcade.MOUSE_BUTTON_LEFT:
            new_tower = Tower(x, y)
            self.tower_list.append(new_tower)


if __name__ == "__main__":
    game = TowerDefenseGame()
    arcade.run()
        </code></pre>
        <h3>3. Платформер з гравітацією</h3>
        <pre><code>
import arcade

SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
SCREEN_TITLE = "Platformer Puzzle — Arcade"

PLAYER_SPEED = 4
GRAVITY = 1
JUMP_SPEED = 20


class PuzzleGame(arcade.Window):
    def __init__(self):
        super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)
        arcade.set_background_color(arcade.color.AIR_FORCE_BLUE)

        self.player_list = None
        self.wall_list = None
        self.switch_list = None
        self.door_list = None

        self.player = None
        self.physics_engine = None

        self.door_open = False

        self.camera = arcade.camera.Camera2D()

    def setup(self):
        self.player_list = arcade.SpriteList()
        self.wall_list = arcade.SpriteList(use_spatial_hash=True)
        self.switch_list = arcade.SpriteList()
        self.door_list = arcade.SpriteList()

        self.player = arcade.SpriteSolidColor(32, 48, arcade.color.BLUE)
        self.player.center_x = 100
        self.player.center_y = 150
        self.player_list.append(self.player)

        for x in range(0, 3000, 64):
            wall = arcade.SpriteSolidColor(64, 32, arcade.color.BROWN)
            wall.center_x = x
            wall.center_y = 32
            self.wall_list.append(wall)

        platform = arcade.SpriteSolidColor(128, 32, arcade.color.DARK_BROWN)
        platform.center_x = 400
        platform.center_y = 200
        self.wall_list.append(platform)

        platform2 = arcade.SpriteSolidColor(200, 32, arcade.color.DARK_BROWN)
        platform2.center_x = 1000
        platform2.center_y = 300
        self.wall_list.append(platform2)

        switch = arcade.SpriteSolidColor(32, 10, arcade.color.YELLOW)
        switch.center_x = 400
        switch.center_y = 216
        self.switch_list.append(switch)

        door = arcade.SpriteSolidColor(40, 80, arcade.color.GRAY)
        door.center_x = 1200
        door.center_y = 96
        self.door_list.append(door)

        self.physics_engine = arcade.PhysicsEnginePlatformer(
            self.player,
            self.wall_list,
            gravity_constant=GRAVITY
        )

        self.center_camera_to_player()

    def on_draw(self):
        self.clear()
        self.camera.use()

        self.wall_list.draw()
        self.switch_list.draw()
        self.door_list.draw()
        self.player_list.draw()

    def on_update(self, delta_time):
        self.physics_engine.update()

        self.center_camera_to_player()

        if arcade.check_for_collision_with_list(self.player, self.switch_list):
            self.door_open = True
            for door in self.door_list:
                door.remove_from_sprite_lists()

    def on_key_press(self, key, modifiers):
        if key == arcade.key.LEFT or key == arcade.key.A:
            self.player.change_x = -PLAYER_SPEED
        elif key == arcade.key.RIGHT or key == arcade.key.D:
            self.player.change_x = PLAYER_SPEED
        elif key == arcade.key.UP or key == arcade.key.W:
            if self.physics_engine.can_jump():
                self.player.change_y = JUMP_SPEED

    def on_key_release(self, key, modifiers):
        if key in (arcade.key.LEFT, arcade.key.RIGHT, arcade.key.A, arcade.key.D):
            self.player.change_x = 0

    def center_camera_to_player(self):
        screen_center_x = self.player.center_x - self.camera.viewport_width / 12
        screen_center_y = self.player.center_y - self.camera.viewport_height / 12

        self.camera.position = (screen_center_x, screen_center_y)


if __name__ == "__main__":
    game = PuzzleGame()
    game.setup()
    arcade.run()
        </code></pre>
    </article>

    <h2>Графіка для ігор: Cocos2d</h2>
    <article>
        <h3>1. 2D-пригода з декількома сценами</h3>
        <pre><code>
import cocos
from cocos.scenes import transitions
from cocos.text import Label
from pyglet.window import key
import os
import pyglet

pyglet.resource.path = [r"C:\Users\38067\Desktop\assetss"]
pyglet.resource.reindex()


class Player(cocos.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__("player.png")
        self.position = x, y
        self.velocity_x = 0
        self.speed = 200

    def update(self, dt):
        self.x += self.velocity_x * dt


class RoomLayer(cocos.layer.Layer):
    is_event_handler = True

    def __init__(self, room_name, has_npc=False, next_scene_class=None):
        super().__init__()
        self.room_name = room_name
        self.has_npc = has_npc
        self.next_scene_class = next_scene_class

        self.player = Player(100, 100)
        self.add(self.player)

        self.label = Label(room_name, font_size=24, x=400, y=550, anchor_x='center')
        self.add(self.label)

        self.dialog_label = None
        self.in_dialog = False

        if has_npc:
            # ВИПРАВЛЕННЯ: Змінено на "npc.jpg"
            self.npc = cocos.sprite.Sprite("npc.jpg", position=(600, 100))
            self.add(self.npc)
        else:
            self.npc = None

        self.schedule(self.update)

    def on_key_press(self, symbol, modifiers):
        if symbol == key.RIGHT:
            self.player.velocity_x = self.player.speed
        elif symbol == key.LEFT:
            self.player.velocity_x = -self.player.speed

        elif symbol == key.SPACE:
            self.check_interaction()

        elif symbol == key.ENTER:
            if self.next_scene_class:
                new_scene = cocos.scene.Scene(self.next_scene_class())
                transition = transitions.FadeTransition(new_scene, duration=1.0)
                cocos.director.director.replace(transition)
            else:
                print("Немає наступної кімнати для переходу.")

    def on_key_release(self, symbol, modifiers):
        if symbol in (key.RIGHT, key.LEFT):
            self.player.velocity_x = 0

    def check_interaction(self):
        if self.in_dialog:
            self.remove(self.dialog_label)
            self.dialog_label = None
            self.in_dialog = False
            return

        if self.npc and abs(self.player.x - self.npc.x) < 100:
            self.dialog_label = Label("Привіт, мандрівнику! Натисни SPACE ще раз, щоб закрити діалог.", font_size=18,
                                      x=self.npc.x, y=self.npc.y + 80,
                                      anchor_x='center')
            self.add(self.dialog_label)
            self.in_dialog = True
        elif self.player.x > 750 and self.next_scene_class:
            pass

    def update(self, dt):
        self.player.update(dt)

        if self.player.x > cocos.director.director.window.width - 50 and self.next_scene_class:
            new_scene = cocos.scene.Scene(self.next_scene_class())
            transition = transitions.FadeTransition(new_scene,
                                                    duration=1.0)
            cocos.director.director.replace(transition)


class Room1(RoomLayer):
    def __init__(self):
        super().__init__("Кімната 1: Початок", has_npc=True, next_scene_class=Room2)


class Room2(RoomLayer):
    def __init__(self):
        super().__init__("Кімната 2: Наступний крок", has_npc=False, next_scene_class=None)


class MainMenu(cocos.layer.Layer):
    is_event_handler = True

    def __init__(self):
        super().__init__()
        label = Label("Натисни Enter, щоб почати пригоду", font_size=24, x=400, y=300, anchor_x='center')
        self.add(label)

    def on_key_press(self, symbol, modifiers):
        if symbol == key.ENTER:
            new_scene = cocos.scene.Scene(Room1())
            transition = transitions.FadeTransition(new_scene, duration=1.0)
            cocos.director.director.replace(transition)


def main():
    cocos.director.director.init(width=800, height=600, caption="Cocos2d Adventure")
    main_scene = cocos.scene.Scene(MainMenu())
    cocos.director.director.run(main_scene)


if __name__ == "__main__":
    main()
        </code></pre>
        <h3>2. Гра "Змійка" (Snake)</h3>
        <pre><code>
import cocos
from cocos.layer import ColorLayer
from cocos.scene import Scene
from cocos.text import Label
from pyglet.window import key
import random


CELL_SIZE = 20
GRID_WIDTH = 30
GRID_HEIGHT = 20
SCREEN_WIDTH = GRID_WIDTH * CELL_SIZE
SCREEN_HEIGHT = GRID_HEIGHT * CELL_SIZE

DIRECTIONS = {
    key.UP: (0, 1),
    key.DOWN: (0, -1),
    key.LEFT: (-1, 0),
    key.RIGHT: (1, 0),
    key.W: (0, 1),
    key.S: (0, -1),
    key.A: (-1, 0),
    key.D: (1, 0)
}


class SnakeGame(ColorLayer):
    is_event_handler = True

    def __init__(self):
        super().__init__(0, 0, 0, 255)

        self.schedule_interval(self.update, 0.15)

        self.snake = [(10, 10), (9, 10), (8, 10)]
        self.snake_dir = (1, 0)

        self.food = self.spawn_food()
        self.score = 0

        self.snake_segments = []
        self.food_object = None

        self.label = Label(f"Score: {self.score}", x=10, y=SCREEN_HEIGHT - 30, font_size=16, anchor_x="left")
        self.add(self.label)

        self.draw_game()

    def spawn_food(self):
        while True:
            pos = (random.randint(0, GRID_WIDTH - 1), random.randint(0, GRID_HEIGHT - 1))
            if pos not in self.snake:
                return pos

    def on_key_press(self, symbol, modifiers):
        if symbol in DIRECTIONS:
            new_dir = DIRECTIONS[symbol]
            if (new_dir[0] * -1, new_dir[1] * -1) != self.snake_dir:
                self.snake_dir = new_dir

    def update(self, dt):
        head_x, head_y = self.snake[0]
        dx, dy = self.snake_dir
        new_head = (head_x + dx, head_y + dy)

        if (new_head in self.snake or
                new_head[0] < 0 or new_head[0] >= GRID_WIDTH or
                new_head[1] < 0 or new_head[1] >= GRID_HEIGHT):
            self.unschedule(self.update)
            game_over = Label("Гра завершена!", font_size=32, x=SCREEN_WIDTH // 2,
                              y=SCREEN_HEIGHT // 2, anchor_x="center")
            self.add(game_over)
            return

        self.snake.insert(0, new_head)

        if new_head == self.food:
            self.score += 1
            self.food = self.spawn_food()
            self.label.element.text = f"Score: {self.score}"
        else:
            self.snake.pop()

        self.draw_game()

    def draw_game(self):
        for segment_obj in self.snake_segments:
            if segment_obj.parent:
                self.remove(segment_obj)
        self.snake_segments = []

        if self.food_object and self.food_object.parent:
            self.remove(self.food_object)
        self.food_object = None

        for i, (x, y) in enumerate(self.snake):
            color = (0, 255, 0) if i == 0 else (50, 200, 50)

            segment = cocos.layer.ColorLayer(color[0], color[1], color[2], 255,
                                             width=CELL_SIZE, height=CELL_SIZE)
            segment.position = x * CELL_SIZE, y * CELL_SIZE
            self.add(segment)
            self.snake_segments.append(segment)

        fx, fy = self.food
        apple = cocos.layer.ColorLayer(255, 0, 0, 255, width=CELL_SIZE, height=CELL_SIZE)
        apple.position = fx * CELL_SIZE, fy * CELL_SIZE
        self.add(apple)
        self.food_object = apple


def main():
    cocos.director.director.init(width=SCREEN_WIDTH, height=SCREEN_HEIGHT, caption="Snake — Cocos2d")
    scene = Scene(SnakeGame())
    cocos.director.director.run(scene)


if __name__ == "__main__":
    main()
        </code></pre>
        <h3>3. Flappy Bird</h3>
        <pre><code>
import cocos
import random
from pyglet.window import key
import pyglet


SCREEN_WIDTH = 400
SCREEN_HEIGHT = 600
GRAVITY = -500
JUMP_SPEED = 200
PIPE_SPEED = 100
PIPE_INTERVAL = 2.0
GAP_HEIGHT = 10


class Bird(cocos.sprite.Sprite):
    def __init__(self):
        image = pyglet.image.SolidColorImagePattern((255, 255, 0, 255)).create_image(30, 30)
        super().__init__(image)
        self.position = 100, SCREEN_HEIGHT // 2
        self.velocity_y = 0

    def update(self, dt):
        self.velocity_y += GRAVITY * dt
        self.y += self.velocity_y * dt


class PipePair(cocos.layer.Layer):
    def __init__(self, x):
        super().__init__()

        gap_y = random.randint(150, SCREEN_HEIGHT - 150)

        self.top = cocos.layer.ColorLayer(34, 139, 34, 255, width=60, height=SCREEN_HEIGHT)
        self.top.position = x, gap_y + GAP_HEIGHT // 2 + SCREEN_HEIGHT // 2
        self.add(self.top)

        self.bottom = cocos.layer.ColorLayer(34, 139, 34, 255, width=60, height=SCREEN_HEIGHT)
        self.bottom.position = x, gap_y - GAP_HEIGHT // 2 - SCREEN_HEIGHT
        self.add(self.bottom)

        self.scored = False

    def update(self, dt):
        self.top.x -= PIPE_SPEED * dt
        self.bottom.x -= PIPE_SPEED * dt

    def is_off_screen(self):
        return self.top.x + self.top.width < 0

    def passed_by(self, bird):
        return not self.scored and self.top.x + self.top.width < bird.x


class FlappyLayer(cocos.layer.Layer):
    is_event_handler = True

    def __init__(self):
        super().__init__()
        self.bird = Bird()
        self.add(self.bird)

        self.pipes = []
        self.score = 0
        self.label = cocos.text.Label("0", font_size=36, x=SCREEN_WIDTH//2, y=SCREEN_HEIGHT - 50, anchor_x="center")
        self.add(self.label)

        self.schedule(self.update)
        self.schedule_interval(self.spawn_pipe, PIPE_INTERVAL)

    def spawn_pipe(self, dt):
        pipe = PipePair(SCREEN_WIDTH + 100)
        self.pipes.append(pipe)
        self.add(pipe)

    def on_key_press(self, symbol, modifiers):
        if symbol in (key.SPACE, key.W, key.UP):
            self.bird.velocity_y = JUMP_SPEED

    def update(self, dt):
        self.bird.update(dt)

        if self.bird.y < 0 or self.bird.y > SCREEN_HEIGHT:
            self.game_over()
            return

        for pipe in list(self.pipes):
            pipe.update(dt)

            if self.collides(self.bird, pipe.top) or self.collides(self.bird, pipe.bottom):
                self.game_over()
                return

            if pipe.passed_by(self.bird):
                self.score += 1
                self.label.element.text = str(self.score)
                pipe.scored = True

            if pipe.is_off_screen():
                self.remove(pipe)
                self.pipes.remove(pipe)

    def collides(self, bird, rect):
        bird_box = bird.get_rect()
        pipe_box = cocos.rect.Rect(rect.x, rect.y, rect.width, rect.height)
        return bird_box.intersects(pipe_box)

    def game_over(self):
        self.unschedule(self.update)
        self.unschedule(self.spawn_pipe)
        game_over_label = cocos.text.Label("Game Over", font_size=36,
                                           x=SCREEN_WIDTH//2, y=SCREEN_HEIGHT//2,
                                           anchor_x="center", color=(255, 0, 0, 255))
        self.add(game_over_label)


def main():
    cocos.director.director.init(width=SCREEN_WIDTH, height=SCREEN_HEIGHT, caption="Flappy Bird")
    scene = cocos.scene.Scene(FlappyLayer())
    cocos.director.director.run(scene)


if __name__ == "__main__":
    main()
        </code></pre>
    </article>

    <h2>Спеціалізовані бібліотеки: Manim</h2>
    <article>
        <h3>1. Геометрія з анімацією</h3>
        <pre><code>
from manim import *

class GeometryScene(Scene):
    def construct(self):
        circle = Circle(radius=1, color=BLUE).shift(LEFT * 3)
        square = Square(side_length=2, color=GREEN).shift(RIGHT * 3)
        triangle = Triangle().scale(1.5).set_color(RED)

        self.play(Create(circle))
        self.wait(1)

        self.play(Transform(circle, square))
        self.wait(1)

        self.play(Transform(circle, triangle))
        self.wait(1)

        self.play(Rotate(circle, angle=PI), run_time=2)

        self.play(FadeOut(circle))
        </code></pre>
        <h3>2. побудова графіка функції f(x) = sin(x)</h3>
        <pre><code>
from manim import *

class SineGraph(Scene):
    def construct(self):
        axes = Axes(
            x_range=[-4, 4],
            y_range=[-1.5, 1.5],
            x_length=8,
            y_length=3,
            axis_config={"include_numbers": False},
        ).to_edge(DOWN)

        x_label = Text("x", font_size=24).next_to(axes.x_axis, RIGHT)
        y_label = Text("f(x)", font_size=24).next_to(axes.y_axis, UP)

        self.play(Create(axes), FadeIn(x_label), FadeIn(y_label))
        self.wait(0.5)

        graph = axes.plot(lambda x: np.sin(x), color=BLUE)

        dot = Dot(color=YELLOW).move_to(graph.get_start())
        tracer = always_redraw(lambda: Dot(color=YELLOW).move_to(dot.get_center()))

        self.add(tracer)
        self.play(Create(graph), run_time=2)
        self.play(MoveAlongPath(dot, graph), run_time=4)

        self.wait(1)
        self.play(FadeOut(graph), FadeOut(dot), FadeOut(tracer), FadeOut(x_label), FadeOut(y_label))
        </code></pre>
        <h3>3. Лінійне перетворення векторів</h3>
        <pre><code>
from manim import *

class LinearTransformScene(Scene):
    def construct(self):
        grid = NumberPlane(x_range=[-5, 5], y_range=[-5, 5])
        self.play(Create(grid))
        self.wait(0.5)

        v1 = Vector([2, 1], color=BLUE)
        v2 = Vector([-1, 2], color=GREEN)

        self.play(GrowArrow(v1), GrowArrow(v2))
        self.wait(1)

        label1 = Text("v₁", font_size=24).next_to(v1.get_end(), RIGHT)
        label2 = Text("v₂", font_size=24).next_to(v2.get_end(), LEFT)
        self.play(Write(label1), Write(label2))
        self.wait(1)

        matrix = [[1, 1],
                  [0, 1]]

        self.play(ApplyMatrix(matrix, grid), run_time=3)
        self.play(ApplyMatrix(matrix, v1), ApplyMatrix(matrix, v2), run_time=2)
        self.wait(2)
        </code></pre>
    </article>

    <h2>Спеціалізовані бібліотеки: Basemap</h2>
    <article>
        <h3>1. Світова карта з містами</h3>
        <pre><code>
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap

fig = plt.figure(figsize=(10, 6))
m = Basemap(projection='mill', llcrnrlat=-60, urcrnrlat=80,
            llcrnrlon=-180, urcrnrlon=180, resolution='c')

m.drawcoastlines()
m.drawcountries()
m.drawmapboundary(fill_color='lightblue')
m.fillcontinents(color='palegoldenrod', lake_color='lightblue')
m.drawparallels(range(-90, 91, 30), labels=[1, 0, 0, 0])
m.drawmeridians(range(-180, 181, 60), labels=[0, 0, 0, 1])

cities = {
    "Kyiv": (30.52, 50.45),
    "Tokyo": (139.69, 35.68),
    "New York": (-74.00, 40.71),
}

for name, (lon, lat) in cities.items():
    x, y = m(lon, lat)
    m.plot(x, y, 'ro', markersize=5)
    plt.text(x + 50000, y + 50000, name, fontsize=10, fontweight='bold')

plt.title("Світова карта з основними містами")
plt.tight_layout()
plt.show()
        </code></pre>
        <h3>2. Температурна картограма</h3>
        <pre><code>
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
import numpy as np

fig = plt.figure(figsize=(12, 6))

ax = fig.add_subplot(111)

m = Basemap(projection='robin', lon_0=0, resolution='c', ax=ax)

m.drawcoastlines()
m.drawcountries()
m.drawmapboundary(fill_color='lightblue')
m.fillcontinents(color='lightyellow', lake_color='lightblue')
m.drawparallels(np.arange(-90, 91, 30))
m.drawmeridians(np.arange(-180, 181, 60))

temperature_data = [
    ("Kyiv", 30.52, 50.45, 18),
    ("Tokyo", 139.69, 35.68, 27),
    ("New York", -74.00, 40.71, 22),
    ("Cairo", 31.24, 30.04, 35),
    ("Sydney", 151.21, -33.87, 16),
    ("Rio", -43.17, -22.91, 26),
]

temps = [temp for _, _, _, temp in temperature_data]
norm = plt.Normalize(min(temps), max(temps))
cmap = plt.cm.hot

for name, lon, lat, temp in temperature_data:
    x, y = m(lon, lat)
    color = cmap(norm(temp))
    m.scatter(x, y, s=200, c=[color], edgecolors='black', zorder=5)
    plt.text(x + 50000, y + 50000, f"{name}\n{temp}°C", fontsize=9, color='black', ha='left', va='bottom')

sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
sm.set_array([])
cax = fig.add_axes([0.88, 0.15, 0.02, 0.7])

plt.colorbar(sm, cax=cax, label="Температура, °C")

plt.title("Картограма температур по містах світу")
plt.show()
        </code></pre>
        <h3>3. Геодезична траєкторія польоту</h3>
        <pre><code>
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap

kyiv_lon, kyiv_lat = 30.52, 50.45
tokyo_lon, tokyo_lat = 139.69, 35.68

fig = plt.figure(figsize=(12, 6))
m = Basemap(projection='robin', lon_0=90, resolution='l')

m.drawcoastlines()
m.drawcountries()
m.fillcontinents(color='beige', lake_color='lightblue')
m.drawmapboundary(fill_color='lightblue')
m.drawparallels(range(-90, 91, 30))
m.drawmeridians(range(0, 361, 60))

kyiv_x, kyiv_y = m(kyiv_lon, kyiv_lat)
tokyo_x, tokyo_y = m(tokyo_lon, tokyo_lat)

m.plot(kyiv_x, kyiv_y, 'ro', markersize=8)
m.plot(tokyo_x, tokyo_y, 'ro', markersize=8)

plt.text(kyiv_x + 100000, kyiv_y + 100000, "Kyiv", fontsize=10)
plt.text(tokyo_x + 100000, tokyo_y + 100000, "Tokyo", fontsize=10)

m.drawgreatcircle(kyiv_lon, kyiv_lat, tokyo_lon, tokyo_lat, linewidth=2, color='blue')

plt.title("Геодезична траєкторія польоту: Київ → Токіо")
plt.tight_layout()
plt.show()
        </code></pre>
    </article>

    <h2>Спеціалізовані бібліотеки: Cartopy</h2>
    <article>
        <h3>1. Базова світова карта</h3>
        <pre><code>
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature

fig = plt.figure(figsize=(12, 6))
ax = plt.axes(projection=ccrs.Robinson())

ax.add_feature(cfeature.LAND, facecolor='lightgreen')
ax.add_feature(cfeature.OCEAN, facecolor='lightblue')
ax.add_feature(cfeature.BORDERS, linestyle=':', edgecolor='gray')
ax.add_feature(cfeature.COASTLINE)
ax.add_feature(cfeature.LAKES, alpha=0.5)
ax.add_feature(cfeature.RIVERS)

gl = ax.gridlines(draw_labels=True, linewidth=0.5, color='gray', alpha=0.5)
gl.top_labels = False
gl.right_labels = False

plt.title("Базова світова карта з Cartopy")
plt.tight_layout()
plt.show()
        </code></pre>
        <h3>2. Траєкторія польоту Київ → Токіо</h3>
        <pre><code>
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
from cartopy.geodesic import Geodesic
import numpy as np

kyiv = (30.52, 50.45)
tokyo = (139.69, 35.68)

kyiv_lon, kyiv_lat = kyiv
tokyo_lon, tokyo_lat = tokyo


fig = plt.figure(figsize=(12, 6))
ax = plt.axes(projection=ccrs.PlateCarree())
ax.set_global()

ax.add_feature(cfeature.LAND, facecolor='lightgray')
ax.add_feature(cfeature.OCEAN, facecolor='lightblue')
ax.add_feature(cfeature.BORDERS, linestyle=':')
ax.coastlines()

ax.plot(kyiv_lon, kyiv_lat, marker='o', color='red', markersize=5, transform=ccrs.PlateCarree(), label="Kyiv")
ax.text(kyiv_lon + 5, kyiv_lat + 3, "Kyiv", transform=ccrs.PlateCarree())

ax.plot(tokyo_lon, tokyo_lat, marker='o', color='red', markersize=5, transform=ccrs.PlateCarree(), label="Tokyo")
ax.text(tokyo_lon + 5, tokyo_lat + 3, "Tokyo", transform=ccrs.PlateCarree())


geod = Geodesic()

inverse_result = geod.inverse(kyiv, tokyo)
distance, initial_azimuth, _ = inverse_result[0]


num_points = 100
distances = np.linspace(0, distance, num_points)

direct_result = geod.direct(kyiv, initial_azimuth, distances)

lons = direct_result[:, 0]
lats = direct_result[:, 1]


ax.plot(lons, lats, color='blue', linewidth=2, transform=ccrs.PlateCarree(), label="Flight Path")

plt.title("Траєкторія польоту: Київ \u2192 Токіо (геодезична лінія)", fontsize=14)
plt.tight_layout()
plt.show()
        </code></pre>
        <h3>3. Візуалізація землетрусів</h3>
        <pre><code>
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import numpy as np

earthquakes = [
    (142.37, 38.30, 7.2),
    (-72.33, -36.12, 8.8),
    (95.98, 3.30, 9.1),
    (178.09, -38.32, 7.1),
    (30.52, 50.45, 4.5),
    (-118.24, 34.05, 5.9),
]

magnitudes = [mag for _, _, mag in earthquakes]
cmap = plt.cm.viridis
norm = plt.Normalize(min(magnitudes), max(magnitudes))

fig = plt.figure(figsize=(12, 6))
ax = plt.axes(projection=ccrs.PlateCarree())
ax.set_global()

ax.add_feature(cfeature.LAND, facecolor='lightgray')
ax.add_feature(cfeature.OCEAN, facecolor='lightblue')
ax.add_feature(cfeature.BORDERS)
ax.coastlines()

for lon, lat, mag in earthquakes:
    ax.scatter(
        lon, lat,
        s=mag**3,
        color=cmap(norm(mag)),
        alpha=0.8,
        transform=ccrs.PlateCarree(),
        edgecolors='black',
        linewidth=0.5
    )

sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
sm.set_array([])

plt.colorbar(sm, ax=ax, label="Магнітуда землетрусу", orientation="vertical", shrink=0.6)

plt.title("Карта землетрусів (псевдо-дані)")
plt.tight_layout()
plt.show()
        </code></pre>
    </article>
    
    <h2>Спеціалізовані бібліотеки: Folium</h2>
    <article>
        <h3>1. Базова інтерактивна карта з маркерами</h3>
        <pre><code>
import folium

map_center = [40.0, 50.0]
my_map = folium.Map(location=map_center, zoom_start=2)

cities = [
    ("Kyiv", 50.45, 30.52, "Столиця України"),
    ("Tokyo", 35.68, 139.69, "Столиця Японії"),
    ("New York", 40.71, -74.00, "Місто в США"),
]

for name, lat, lon, desc in cities:
    folium.Marker(
        location=[lat, lon],
        popup=f"<b>{name}</b><br>{desc}",
        tooltip=name,
        icon=folium.Icon(color="blue", icon="info-sign")
    ).add_to(my_map)

my_map.save("map_with_markers.html")
print('map_with_markers.html')
        </code></pre>
        <h3>2. Теплова карта</h3>
        <pre><code>
import folium
from folium.plugins import HeatMap

map_center = [48.0, 30.0]
my_map = folium.Map(location=map_center, zoom_start=2)

heat_data = [
    [50.45, 30.52, 0.9],
    [35.68, 139.69, 0.8],
    [40.71, -74.00, 0.7],
    [51.50, -0.12, 0.6],
    [48.85, 2.35, 0.5],
    [34.05, -118.24, 0.4],
    [55.75, 37.61, 0.3],
]

HeatMap(heat_data, radius=25, blur=15, max_zoom=6).add_to(my_map)

my_map.save("heatmap.html")
print('heatmap.html')
        </code></pre>
        <h3>3. Маршрут на карті (GPS-траєкторія)</h3>
        <pre><code>
import folium
from folium import PolyLine

map_center = [50.0, 15.0]
my_map = folium.Map(location=map_center, zoom_start=4)

route = [
    ("Kyiv", [50.45, 30.52]),
    ("Warsaw", [52.23, 21.01]),
    ("Berlin", [52.52, 13.40]),
    ("Paris", [48.85, 2.35]),
]

for name, coord in route:
    folium.Marker(
        location=coord,
        popup=f"<b>{name}</b>",
        tooltip=name,
        icon=folium.Icon(color="green", icon="road")
    ).add_to(my_map)

path_coords = [coord for _, coord in route]

PolyLine(locations=path_coords, color="blue", weight=5, opacity=0.7).add_to(my_map)

my_map.save("route_map.html")
print('route_map.html')
        </code></pre>
    </article>

    <h2>Спеціалізовані бібліотеки: Blender Python API</h2>
    <article>
        <h3>1. Процедурна генерація набору кубів із градієнтом</h3>
        <pre><code>
import bpy

bpy.ops.wm.read_factory_settings(use_empty=True)

size = 1.0
spacing = 2.0
rows = cols = layers = 5

for x in range(rows):
    for y in range(cols):
        for z in range(layers):
            loc = (x * spacing, y * spacing, z * spacing)
            bpy.ops.mesh.primitive_cube_add(size=size, location=loc)
            obj = bpy.context.view_layer.objects.active

            factor = 1 + 0.2 * (x + y + z)
            obj.scale = (factor, factor, factor)

            mat = bpy.data.materials.new(name=f"Mat_{x}_{y}_{z}")
            mat.use_nodes = True

            bsdf = None
            for node in mat.node_tree.nodes:
                if node.type == 'BSDF_PRINCIPLED':
                    bsdf = node
                    break

            if bsdf is None:
                bsdf = mat.node_tree.nodes.new('ShaderNodeBsdfPrincipled')
                output = mat.node_tree.nodes.get('Material Output')
                mat.node_tree.links.new(bsdf.outputs['BSDF'], output.inputs['Surface'])

            color = (x / (rows - 1), y / (cols - 1), z / (layers - 1), 1)
            bsdf.inputs["Base Color"].default_value = color

            obj.data.materials.append(mat)
        </code></pre>
        <h3>2. Анімація кульки з гравітацією та відбиванням</h3>
        <pre><code>
import bpy
import mathutils

bpy.ops.wm.read_factory_settings(use_empty=True)

bpy.ops.mesh.primitive_uv_sphere_add(radius=1, location=(0, 0, 5))
ball = bpy.context.view_layer.objects.active  # Отримуємо активний об'єкт через view_layer

ball.keyframe_insert(data_path="location", frame=1)

frames_up = 20
frames_down = 20
bounciness = 0.6
ground_z = 1.0

ball.location.z = 10
ball.keyframe_insert(data_path="location", frame=frames_up)

ball.location.z = ground_z
ball.keyframe_insert(data_path="location", frame=frames_up + frames_down)

ball.location.z = 5 * bounciness + ground_z
ball.keyframe_insert(data_path="location", frame=frames_up + frames_down + frames_down * bounciness)

for fcurve in ball.animation_data.action.fcurves:
    for kp in fcurve.keyframe_points:
        kp.interpolation = 'LINEAR'
        </code></pre>
        <h3>3. Процедурний ландшафт з підняттям вершин (дисперсія)</h3>
        <pre><code>
import bpy
import bmesh
import random
import math

bpy.ops.wm.read_factory_settings(use_empty=True)

bpy.ops.mesh.primitive_grid_add(x_subdivisions=50, y_subdivisions=50, size=10)

plane = bpy.context.view_layer.objects.active

mesh = plane.data
bm = bmesh.new()
bm.from_mesh(mesh)

def noise(x, y):
    return random.uniform(-1, 1)

for v in bm.verts:
    # Координати у [0,1]
    u = (v.co.x / 10 + 0.5)
    w = (v.co.y / 10 + 0.5)
    h = noise(u * 5, w * 5) * 2  # масштаб висоти
    v.co.z = h

bm.to_mesh(mesh)
bm.free()

mat = bpy.data.materials.new("LandscapeMat")
mat.use_nodes = True

nodes = mat.node_tree.nodes
bsdf = None

for node in nodes:
    if node.type == 'BSDF_PRINCIPLED':
        bsdf = node
        break

if bsdf is None:
    bsdf = nodes.new(type='ShaderNodeBsdfPrincipled')

bsdf.inputs["Base Color"].default_value = (0.2, 0.8, 0.2, 1)

plane.data.materials.append(mat)

cam = bpy.data.objects.new("Camera", bpy.data.cameras.new("Camera"))
bpy.context.collection.objects.link(cam)
cam.location = (30, -30, 20)
cam.rotation_euler = (math.radians(60), 0, math.radians(45))
bpy.context.scene.camera = cam
        </code></pre>
    </article>

    <h2>Анімація: Manim</h2>
    <article>
        <h3>1. Анімація руху вектора по колу</h3>
        <pre><code>
from manim import *

class RotatingVector(Scene):
    def construct(self):
        circle = Circle(radius=2, color=BLUE)
        vector = Arrow(ORIGIN, RIGHT * 2, buff=0, color=YELLOW)

        label = Text("Рух по колу", font_size=24).to_edge(UP)

        self.play(Create(circle), Write(label))
        self.wait(0.5)

        self.play(GrowArrow(vector))
        self.wait(0.5)

        self.play(Rotate(vector, angle=2 * PI, about_point=ORIGIN), run_time=4)
        self.wait(1)
        </code></pre>
        <h3>2. Анімація з масштабуванням і переміщенням об’єкта</h3>
        <pre><code>
from manim import *

class TransformShapes(Scene):
    def construct(self):
        square = Square(color=GREEN)
        circle = Circle(color=BLUE)
        circle.shift(RIGHT * 3)
        label = Text("Трансформація", font_size=24).to_edge(UP)

        self.play(Create(square), Write(label))
        self.wait(0.5)

        self.play(square.animate.shift(LEFT * 3), run_time=2)

        self.play(Transform(square, circle), run_time=2)

        self.play(square.animate.scale(1.5), run_time=1.5)

        self.wait(1)
        </code></pre>
    </article>

    <h2>Анімація: Matplotlib.animation</h2>
    <article>
        <h3>1. Анімація синусоїди, що рухається</h3>
        <pre><code>    
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

fig, ax = plt.subplots()
x = np.linspace(0, 2 * np.pi, 100)
line, = ax.plot(x, np.sin(x))

def update(frame):
    line.set_ydata(np.sin(x + frame / 10))
    return line,

ani = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=True)
plt.title("Анімація синусоїди")
plt.show()
        </code></pre>
        <h3>2. Частинка, яка рухається по колу</h3>
        <pre><code>    
        import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

fig, ax = plt.subplots()
ax.set_aspect('equal')
ax.set_xlim(-1.2, 1.2)
ax.set_ylim(-1.2, 1.2)

point, = ax.plot([], [], 'ro', markersize=10)

circle = plt.Circle((0, 0), 1.0, fill=False, color='gray', linestyle='--')
ax.add_patch(circle)


def update(frame):
    angle = 2 * np.pi * frame / 100
    x = np.cos(angle)
    y = np.sin(angle)

    point.set_data([x], [y])
    return point,


ani = animation.FuncAnimation(fig, update, frames=100, interval=50, blit=False)

plt.title("Рух по колу")
plt.show()
        </code></pre>
    </article>

    <h2>Анімація: Pillow (GIF-анімація)</h2>
    <article>
        <h3>1. Рухома кулька по горизонталі</h3>
        <pre><code> 
from PIL import Image, ImageDraw

frames = []
width, height = 200, 100
ball_radius = 10

start_x_center = ball_radius
end_x_center = width - ball_radius

num_frames = 50

for i in range(num_frames):
    ball_center_x = int(start_x_center + (end_x_center - start_x_center) * (i / (num_frames - 1)))

    ball_center_y = height // 2

    img = Image.new("RGB", (width, height), "white")
    draw = ImageDraw.Draw(img)

    draw.ellipse((ball_center_x - ball_radius, ball_center_y - ball_radius,
                  ball_center_x + ball_radius, ball_center_y + ball_radius), fill="red")
    frames.append(img)

frames[0].save("ball.gif", save_all=True, append_images=frames[1:], duration=40, loop=0)
print("ball.gif")
        </code></pre>
        <h3>2. Анімація кольорової хвилі</h3>
        <pre><code> 
from PIL import Image, ImageDraw
import math

frames = []
width, height = 300, 100

for frame in range(60):
    img = Image.new("RGB", (width, height), "white")
    draw = ImageDraw.Draw(img)

    for x in range(width):
        y = int((math.sin((x + frame * 5) * 0.05) + 1) * height / 2)
        draw.point((x, y), fill=(0, 0, 255))

    frames.append(img)

frames[0].save("wave.gif", save_all=True, append_images=frames[1:], duration=30, loop=0)
print("wave.gif")
        </code></pre>
    </article>

    <h2>Інші: Cairo</h2>
    <article>
        <h3>1. Побудова кола, прямокутника та тексту</h3>
        <pre><code> 
import cairo

WIDTH, HEIGHT = 400, 300

surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, WIDTH, HEIGHT)
ctx = cairo.Context(surface)

ctx.set_source_rgb(1, 1, 1)
ctx.paint()

ctx.set_source_rgb(0.2, 0.4, 0.8)
ctx.arc(200, 150, 80, 0, 2 * 3.14)
ctx.fill()

ctx.set_source_rgb(0.2, 0.8, 0.2)
ctx.rectangle(50, 50, 100, 60)
ctx.fill()

ctx.set_source_rgb(0, 0, 0)
ctx.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)
ctx.set_font_size(24)
ctx.move_to(100, 280)
ctx.show_text("Hello Cairo!")

surface.write_to_png("drawing1.png")
print("drawing1.png")
        </code></pre>
        <h3>2. Малювання спіралі</h3>
        <pre><code> 
import cairo
import math

WIDTH, HEIGHT = 400, 400
surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, WIDTH, HEIGHT)
ctx = cairo.Context(surface)

ctx.set_source_rgb(1, 1, 1)
ctx.paint()

ctx.translate(WIDTH / 2, HEIGHT / 2)

ctx.set_source_rgb(1, 0, 0)
ctx.set_line_width(2)

angle = 0
radius = 1
ctx.move_to(0, 0)

while radius < 150:
    x = radius * math.cos(angle)
    y = radius * math.sin(angle)
    ctx.line_to(x, y)
    angle += 0.2
    radius += 0.8

ctx.stroke()

surface.write_to_png("spiral.png")
print("spiral.png")
        </code></pre>
    </article>

    <h2>Інші: Aggdraw</h2>
    <article>
        <h3>1. Малювання фігур: коло, прямокутник і лінії</h3>
        <pre><code>
from PIL import Image
import aggdraw

img = Image.new("RGB", (400, 300), "white")
draw = aggdraw.Draw(img)

pen = aggdraw.Pen("black", 2)
brush_red = aggdraw.Brush("red")
brush_blue = aggdraw.Brush("blue")

draw.ellipse((100, 100, 200, 200), pen, brush_red)

draw.rectangle((250, 100, 350, 180), pen, brush_blue)

draw.line((50, 250, 350, 250), aggdraw.Pen("green", 4))

draw.flush()
img.save("aggdraw_shapes.png")
print("aggdraw_shapes.png")
        </code></pre>
        <h3>2. Годинник з стрілками</h3>
        <pre><code>
from PIL import Image
import aggdraw
import math

width, height = 400, 400
center = (width // 2, height // 2)
radius = 150

img = Image.new("RGB", (width, height), "white")
draw = aggdraw.Draw(img)

pen_black = aggdraw.Pen("black", 2)
pen_red = aggdraw.Pen("red", 4)
brush_center = aggdraw.Brush("black")

draw.ellipse((center[0] - radius, center[1] - radius,
              center[0] + radius, center[1] + radius),
             pen_black)

for h in range(12):
    angle = math.radians(h * 30)
    x1 = center[0] + radius * math.cos(angle)
    y1 = center[1] + radius * math.sin(angle)
    x2 = center[0] + (radius - 10) * math.cos(angle)
    y2 = center[1] + (radius - 10) * math.sin(angle)
    draw.line((x1, y1, x2, y2), pen_black)

angle_hour = math.radians(-60)
xh = center[0] + 60 * math.cos(angle_hour)
yh = center[1] + 60 * math.sin(angle_hour)
draw.line((center[0], center[1], xh, yh), pen_red)

angle_min = math.radians(-180)
xm = center[0] + 90 * math.cos(angle_min)
ym = center[1] + 90 * math.sin(angle_min)
draw.line((center[0], center[1], xm, ym), pen_black)

draw.ellipse((center[0] - 4, center[1] - 4, center[0] + 4, center[1] + 4),
             None, brush_center)

draw.flush()
img.save("aggdraw_clock.png")
print("aggdraw_clock.png")
        </code></pre>
    </article>

    <h2>Інші: SVGwrite</h2>
    <article>
        <h3>1. Прямокутник, коло та текст</h3>
        <pre><code>
import svgwrite

dwg = svgwrite.Drawing("example1_shapes.svg", size=("400px", "300px"))

dwg.add(dwg.rect(insert=(50, 50), size=(100, 60), fill="lightblue", stroke="black"))

dwg.add(dwg.circle(center=(250, 100), r=40, fill="orange", stroke="black"))

dwg.add(dwg.text("Привіт, SVG!", insert=(120, 200), font_size="24px", fill="green"))

dwg.save()
print("example1_shapes.svg")
        </code></pre>
        <h3>2. Побудова координатної сітки + синусоїда</h3>
        <pre><code>
import svgwrite
import math

dwg = svgwrite.Drawing("example2_grid_wave.svg", size=("500px", "300px"))

for x in range(0, 500, 50):
    dwg.add(dwg.line(start=(x, 0), end=(x, 300), stroke="lightgray"))
for y in range(0, 300, 50):
    dwg.add(dwg.line(start=(0, y), end=(500, y), stroke="lightgray"))

dwg.add(dwg.line(start=(0, 150), end=(500, 150), stroke="black"))
dwg.add(dwg.line(start=(250, 0), end=(250, 300), stroke="black"))

points = []
for x in range(0, 500):
    y = 150 - 50 * math.sin((x / 500) * 4 * math.pi)
    points.append((x, y))

dwg.add(dwg.polyline(points=points, stroke="red", fill="none", stroke_width=2))

dwg.save()
print("example2_grid_wave.svg")
        </code></pre>
    </article>
</section>


<!-- Контакти -->

    <section id="contact" class="contact">
        <h2>Контакти</h2>
        <p>Автор курсової роботи: <strong>Кульман Денис</strong></p>
        <p>Email: <a href="mailto:your-email@example.com">your-email@example.com</a></p>
        <p>GitHub: <a href="https://github.com/yourprofile" target="_blank">github.com/yourprofile</a></p>
    </section>

    <footer>
        <p>&copy; 2024 Курсовий проєкт Дениса Кульмана</p>
    </footer>
</body>
</html>